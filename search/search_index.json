{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Computational Stem Cell Biology","text":"<p>This is a companion website for the class</p> <p>EN 580.447/647    Computational Stem Cell Biology Spring, 2026 (3 credits, EQ) Please monitor your email and the Canvas page for notifications and announcements.</p>"},{"location":"index.html#education-team","title":"Education Team","text":"<ul> <li> <p>Patrick Cahan, Ph.D. Course Instructor </p> <p>Associate Professor of Biomedical Engineering</p> <p>patrick [dot] cahan [at] jhmi [dot] edu</p> <p>Office hours: Right after class. Or email me so we can schedule a time.</p> <p> Cahan Lab</p> </li> <li> <p>Communication </p> <p>Email: compscbio@gmail.com </p> </li> <li> <p>Catherine Rutledge Teaching Assistant </p> <p>Ph.D student in Biomedical Engineering</p> <p>crutled3 [at] jh [dot] edu</p> <p>Office hours: Tuesdays and Thursdays, 4:30-5:30, Clark 210 (or Zoom by request)</p> </li> </ul>"},{"location":"index.html#class-meetings","title":"Class Meetings","text":"<ul> <li>12noon to 1:15 PM on Tuesdays and Thursdays</li> <li>Maryland Room 110</li> <li>Attendance is encouraged</li> <li>Zoom:<ul> <li>https://wse.zoom.us/j/98485708835</li> <li>Requires authentication via Hopkins SSO to join</li> </ul> </li> </ul>"},{"location":"index.html#course-information","title":"Course Information","text":"<p>This course teaches students about high-throughput, genome-wide single cell measurements, and approaches to appropriately analyze such data. Real world examples from stem cell biology and developmental biology provide the biological context and motivation, but the computational expertise gained will be broadly applicable. Please see the lecture schedule below for specific topics. By the end of this course, the student should</p> <ul> <li> <p>Become conversant in the language of sc-omics technologies</p> </li> <li> <p>Become a confident practitioner in state-of-the art computational methods needed to analyze sc-omic data</p> </li> <li> <p>Learn the fundamentals of stem cell biology</p> </li> <li> <p>Gain experience leveraging sc-omics to address perennial questions in the field</p> </li> </ul>"},{"location":"index.html#recommended-background","title":"Recommended Background","text":"<ul> <li>EN.580.151 \u2013 Structural Biology of Cells , or equivalent</li> <li>Prior hands on experience coding in Python </li> </ul>"},{"location":"index.html#course-goals","title":"Course Goals","text":"<p>This course will address the following 'Criterion 3' Student Outcomes:</p> <ul> <li>An ability to apply knowledge of mathematics, science and engineering to solve problems related to stem cell engineering</li> <li>An ability to analyze and interpret data using statistical, computational or mathematical methods</li> <li>An ability to function on multidisciplinary teams (Criteria 3(d))</li> <li>An understanding of professional and ethical responsibility (Criteria 3(f))</li> <li>An ability to communicate effectively (writing) (Criteria 3(g))</li> <li>An ability to communicate effectively (oral presentation) (Criteria 3(g))</li> </ul>"},{"location":"index.html#course-topics","title":"Course Topics","text":"<ul> <li>Stem cell biology</li> <li>Single cell omics technologies</li> <li>Computational tools for the analysis of single cell omics data</li> </ul>"},{"location":"index.html#ethics","title":"Ethics","text":"<p>The strength of the university depends on academic and personal integrity. In this course, you must be honest and truthful. Ethical violations include plagiarism, reuse of assignments, improper use of the Internet and electronic devices, unauthorized collaboration, alteration of graded assignments, forgery and falsification, lying, facilitating academic dishonesty, and unfair competition. In addition, the specific ethics guidelines for this course are:</p> <ol> <li>Homeworks are to be completed by each student alone. Do not share your projects with other students or use material from prior years.</li> <li>The use of Large language models (LLMs) such as ChatGPT are allowed for the homeworks and final project, when doing so is consistent with the stated Course goals and Course expected outcomes (see above). As a guideline, please use LLMs to augment your understanding of the material in the course, to help you to explore algorithmic ideas that might otherwise be challenging to implement, and more generally, to help you to become a more creative problem-solver.</li> </ol> <p>Report any ethics violations you witness to the teaching team. JHU has more information about university misconduct policies for undergraduate students and graduate students.</p>"},{"location":"index.html#grades","title":"Grades","text":"<ul> <li>Homeworks: 10% per homework. 50% total<ul> <li>Detailed expectations will be described for each HW</li> <li>Individual work; assistance from LLMs is allowed per guidelines in the Ethics section above</li> <li>Assignments submitted up to 24 hours late receive a 20 pt penalty per 24 hours late</li> <li>Assignments will not be accepted after next class has begun (during which the assignment answers will be discussed).</li> </ul> </li> <li>Tests: 12.5% per test. 50% total<ul> <li>1 per module; 4 total</li> <li>No devices allowed; Multiple choice, short and longer answer format</li> </ul> </li> </ul>"},{"location":"glossary.html","title":"Stem Cell Biology and Single Cell Omics Glossary","text":"<p>Filter by topic: All Terms Cell Biology Developmental Biology Stem Cell Biology Single Cell Technology Single Cell Analysis</p>  Showing all terms  <p>This glossary is a living document. Please suggest additions or corrections as needed.</p>"},{"location":"glossary.html#blastocyst","title":"Blastocyst","text":"<p>The early embryonic structure formed approximately 5 days after fertilization in mammals, consisting of an inner cell mass (which will form the embryo), a fluid-filled cavity (blastocoel), and an outer layer of cells (trophectoderm).</p> <p>Tags: dev-bio</p>"},{"location":"glossary.html#cell-fate","title":"Cell Fate","text":"<p>The ultimate developmental outcome or identity that a cell will acquire, which may be determined long before visible differentiation occurs.</p> <p>Tags: dev-bio, cell-bio</p>"},{"location":"glossary.html#commitment","title":"Commitment","text":"<p>The process by which a cell becomes restricted to a particular developmental pathway and loses the ability to differentiate into alternative cell types, often irreversibly.</p> <p>Tags: dev-bio, stem-bio</p>"},{"location":"glossary.html#competence","title":"Competence","text":"<p>The ability of a cell or tissue to respond to specific developmental signals at a particular time in development.</p> <p>Tags: dev-bio</p>"},{"location":"glossary.html#differentiation","title":"Differentiation","text":"<p>The process by which less specialized cells become more specialized cell types with distinct morphological characteristics and functional properties.</p> <p>Tags: dev-bio, stem-bio, cell-bio</p>"},{"location":"glossary.html#embryoid-body-eb","title":"Embryoid Body (EB)","text":"<p>A three-dimensional aggregate of pluripotent stem cells that spontaneously differentiates to form derivatives of all three germ layers, mimicking early embryonic development.</p> <p>Tags: stem-bio, dev-bio</p>"},{"location":"glossary.html#gastrulation","title":"Gastrulation","text":"<p>The fundamental reorganization of the embryo during which the three primary germ layers (ectoderm, mesoderm, and endoderm) are established through coordinated cell movements.</p> <p>Tags: dev-bio</p>"},{"location":"glossary.html#germ-layers","title":"Germ Layers","text":"<p>The three primary tissue layers (ectoderm, mesoderm, and endoderm) formed during gastrulation that give rise to all tissues and organs in the body.</p> <p>Tags: dev-bio</p>"},{"location":"glossary.html#hematopoiesis","title":"Hematopoiesis","text":"<p>The process of blood cell formation, including the generation and differentiation of all blood cell lineages from hematopoietic stem cells.</p> <p>Tags: stem-bio, cell-bio</p>"},{"location":"glossary.html#induction","title":"Induction","text":"<p>The process by which one group of cells influences the developmental fate of adjacent cells through signaling molecules.</p> <p>Tags: dev-bio</p>"},{"location":"glossary.html#lineage-tracing","title":"Lineage Tracing","text":"<p>Experimental techniques used to track the developmental history and fate of cells and their progeny over time.</p> <p>Tags: dev-bio, stem-bio</p>"},{"location":"glossary.html#morphogen","title":"Morphogen","text":"<p>A signaling molecule that forms a concentration gradient and elicits different cellular responses depending on its local concentration.</p> <p>Tags: dev-bio</p>"},{"location":"glossary.html#neurulation","title":"Neurulation","text":"<p>The process during embryonic development in which the neural plate folds to form the neural tube, the precursor to the central nervous system.</p> <p>Tags: dev-bio</p>"},{"location":"glossary.html#organogenesis","title":"Organogenesis","text":"<p>The phase of embryonic development during which the three germ layers differentiate to form internal organs.</p> <p>Tags: dev-bio</p>"},{"location":"glossary.html#potency","title":"Potency","text":"<p>The range of cell types that a stem cell can potentially differentiate into.</p> <p>Tags: stem-bio</p>"},{"location":"glossary.html#primitive-streak","title":"Primitive Streak","text":"<p>A structure that forms during gastrulation in amniote embryos, marking the site where cells ingress to form mesoderm and endoderm.</p> <p>Tags: dev-bio</p>"},{"location":"glossary.html#somite","title":"Somite","text":"<p>Segmented blocks of mesoderm that form along the anterior-posterior axis of the embryo and give rise to vertebrae, ribs, skeletal muscle, and dermis.</p> <p>Tags: dev-bio</p>"},{"location":"glossary.html#specification","title":"Specification","text":"<p>The first step in cell fate determination where a cell is biased toward a particular developmental pathway but can still be redirected by environmental signals.</p> <p>Tags: dev-bio, stem-bio</p>"},{"location":"glossary.html#colony-forming-unit-cfu","title":"Colony Forming Unit (CFU)","text":"<p>A measure of stem or progenitor cell function based on the ability of a single cell to proliferate and form a colony of differentiated progeny in culture or in vivo.</p> <p>Tags: stem-bio</p>"},{"location":"glossary.html#dedifferentiation","title":"Dedifferentiation","text":"<p>The process by which differentiated cells revert to a less specialized or more primitive state.</p> <p>Tags: stem-bio, cell-bio</p>"},{"location":"glossary.html#embryonic-stem-cells-escs","title":"Embryonic Stem Cells (ESCs)","text":"<p>Pluripotent stem cells derived from the inner cell mass of blastocyst-stage embryos that can self-renew indefinitely and differentiate into all cell types of the body.</p> <p>Tags: stem-bio</p>"},{"location":"glossary.html#hematopoietic-stem-cell-hsc","title":"Hematopoietic Stem Cell (HSC)","text":"<p>A multipotent stem cell that gives rise to all blood cell lineages and can reconstitute the entire hematopoietic system.</p> <p>Tags: stem-bio</p>"},{"location":"glossary.html#induced-pluripotent-stem-cells-ipscs","title":"Induced Pluripotent Stem Cells (iPSCs)","text":"<p>Pluripotent stem cells generated from somatic cells through the forced expression of specific transcription factors (typically Oct4, Sox2, Klf4, and c-Myc).</p> <p>Tags: stem-bio</p>"},{"location":"glossary.html#mesenchymal-stem-cells-mscs","title":"Mesenchymal Stem Cells (MSCs)","text":"<p>Multipotent stromal cells that can differentiate into adipocytes, chondrocytes, and osteoblasts, among other cell types.</p> <p>Tags: stem-bio</p>"},{"location":"glossary.html#multipotent","title":"Multipotent","text":"<p>The ability of a stem cell to differentiate into multiple but limited cell types, typically within a single lineage or germ layer.</p> <p>Tags: stem-bio</p>"},{"location":"glossary.html#niche","title":"Niche","text":"<p>The specialized microenvironment that houses stem cells and regulates their self-renewal and differentiation through physical and molecular signals.</p> <p>Tags: stem-bio</p>"},{"location":"glossary.html#pluripotent","title":"Pluripotent","text":"<p>The ability of a stem cell to differentiate into any cell type of the three germ layers (ectoderm, mesoderm, endoderm) but not extraembryonic tissues.</p> <p>Tags: stem-bio</p>"},{"location":"glossary.html#progenitor-cell","title":"Progenitor Cell","text":"<p>A descendant of a stem cell that is more committed to a particular lineage but retains limited proliferative and differentiation capacity.</p> <p>Tags: stem-bio, cell-bio</p>"},{"location":"glossary.html#quiescence","title":"Quiescence","text":"<p>A reversible state of cell cycle arrest (G0 phase) in which stem cells are metabolically less active but can re-enter the cell cycle in response to appropriate signals.</p> <p>Tags: stem-bio, cell-bio</p>"},{"location":"glossary.html#reprogramming","title":"Reprogramming","text":"<p>The process of converting a differentiated cell into a pluripotent state, either through somatic cell nuclear transfer or induced pluripotency.</p> <p>Tags: stem-bio</p>"},{"location":"glossary.html#self-renewal","title":"Self-renewal","text":"<p>The ability of stem cells to divide and generate daughter cells that maintain stem cell properties, preserving the stem cell pool.</p> <p>Tags: stem-bio, cell-bio</p>"},{"location":"glossary.html#totipotent","title":"Totipotent","text":"<p>The ability of a cell to differentiate into all cell types of an organism, including both embryonic and extraembryonic tissues (e.g., zygote and early blastomeres).</p> <p>Tags: stem-bio</p>"},{"location":"glossary.html#unipotent","title":"Unipotent","text":"<p>The ability of a stem cell to produce only one differentiated cell type while maintaining self-renewal capacity.</p> <p>Tags: stem-bio</p>"},{"location":"glossary.html#cell-cycle","title":"Cell Cycle","text":"<p>The ordered series of events in which a cell grows, replicates its DNA, and divides into two daughter cells, consisting of G1, S, G2, and M phases.</p> <p>Tags: cell-bio</p>"},{"location":"glossary.html#checkpoint","title":"Checkpoint","text":"<p>Control mechanisms in the cell cycle that ensure proper completion of one phase before progression to the next, preventing errors in DNA replication and chromosome segregation.</p> <p>Tags: cell-bio</p>"},{"location":"glossary.html#g0-phase","title":"G0 Phase","text":"<p>A quiescent state outside the active cell cycle where cells are metabolically active but not actively dividing.</p> <p>Tags: cell-bio</p>"},{"location":"glossary.html#mitosis","title":"Mitosis","text":"<p>The phase of the cell cycle during which nuclear division occurs, resulting in two daughter nuclei with identical genetic content.</p> <p>Tags: cell-bio</p>"},{"location":"glossary.html#s-phase","title":"S Phase","text":"<p>The synthesis phase of the cell cycle during which DNA replication occurs.</p> <p>Tags: cell-bio</p>"},{"location":"glossary.html#10x-genomics","title":"10x Genomics","text":"<p>A widely used commercial platform for high-throughput droplet-based single-cell RNA sequencing.</p> <p>Tags: single-cell-tech</p>"},{"location":"glossary.html#batch-effect","title":"Batch Effect","text":"<p>Technical variation between samples processed at different times or under different conditions that can confound biological interpretation.</p> <p>Tags: single-cell-analysis</p>"},{"location":"glossary.html#cell-barcode","title":"Cell Barcode","text":"<p>A unique nucleotide sequence attached to all cDNA molecules from an individual cell, allowing transcripts to be traced back to their cell of origin after sequencing.</p> <p>Tags: single-cell-tech</p>"},{"location":"glossary.html#cell-hashing","title":"Cell Hashing","text":"<p>A technique that uses oligonucleotide-conjugated antibodies to label cells with unique barcodes, enabling sample multiplexing and doublet detection.</p> <p>Tags: single-cell-tech</p>"},{"location":"glossary.html#cell-ranger","title":"Cell Ranger","text":"<p>Software developed by 10x Genomics for processing single-cell RNA sequencing data, including demultiplexing, alignment, and quantification.</p> <p>Tags: single-cell-analysis</p>"},{"location":"glossary.html#cite-seq","title":"CITE-seq","text":"<p>Cellular Indexing of Transcriptomes and Epitopes by Sequencing - A method that simultaneously measures RNA expression and surface protein levels in single cells using antibody-derived tags.</p> <p>Tags: single-cell-tech</p>"},{"location":"glossary.html#doublet","title":"Doublet","text":"<p>An artifact in single-cell sequencing where two or more cells are captured together and appear as a single cell, potentially leading to false cell type identification.</p> <p>Tags: single-cell-analysis</p>"},{"location":"glossary.html#dropout","title":"Dropout","text":"<p>The failure to detect a transcript that is present in a cell, often due to low mRNA abundance, inefficient capture, or stochastic sampling during library preparation.</p> <p>Tags: single-cell-tech</p>"},{"location":"glossary.html#library-preparation","title":"Library Preparation","text":"<p>The process of converting RNA from single cells into sequencing-ready cDNA libraries with appropriate adapters and barcodes.</p> <p>Tags: single-cell-tech</p>"},{"location":"glossary.html#multiplexing","title":"Multiplexing","text":"<p>The process of pooling multiple samples together in a single sequencing run, often using cell hashing or genetic variation to distinguish samples.</p> <p>Tags: single-cell-tech</p>"},{"location":"glossary.html#smart-seq","title":"Smart-seq","text":"<p>A full-length transcript sequencing protocol that captures complete mRNA sequences from single cells, allowing detection of alternative splicing and allelic variation.</p> <p>Tags: single-cell-tech</p>"},{"location":"glossary.html#spike-in-controls","title":"Spike-in Controls","text":"<p>Known quantities of synthetic RNA molecules added to samples to assess technical variation and enable normalization.</p> <p>Tags: single-cell-tech</p>"},{"location":"glossary.html#unique-molecular-identifier-umi","title":"Unique Molecular Identifier (UMI)","text":"<p>A short random nucleotide sequence added to individual RNA molecules before amplification, allowing correction for PCR amplification bias by counting unique molecules rather than reads.</p> <p>Tags: single-cell-tech</p>"},{"location":"glossary.html#ambient-rna","title":"Ambient RNA","text":"<p>Cell-free RNA present in the suspension that can contaminate droplets and lead to false-positive gene expression signals.</p> <p>Tags: single-cell-analysis</p>"},{"location":"glossary.html#batch-correction","title":"Batch Correction","text":"<p>Computational methods used to remove technical variation between experimental batches while preserving biological variation.</p> <p>Tags: single-cell-analysis</p>"},{"location":"glossary.html#cell-type-annotation","title":"Cell Type Annotation","text":"<p>The process of assigning biological cell type identities to clusters based on marker gene expression and prior knowledge.</p> <p>Tags: single-cell-analysis</p>"},{"location":"glossary.html#clustering","title":"Clustering","text":"<p>Computational grouping of cells based on similarity in gene expression patterns to identify distinct cell populations or states.</p> <p>Tags: single-cell-analysis</p>"},{"location":"glossary.html#data-integration","title":"Data Integration","text":"<p>Methods for combining multiple single-cell datasets while accounting for technical differences and batch effects.</p> <p>Tags: single-cell-analysis</p>"},{"location":"glossary.html#differential-expression-de-analysis","title":"Differential Expression (DE) Analysis","text":"<p>Statistical methods for identifying genes that are expressed at significantly different levels between cell populations or conditions.</p> <p>Tags: single-cell-analysis</p>"},{"location":"glossary.html#dimensionality-reduction","title":"Dimensionality Reduction","text":"<p>Techniques for reducing high-dimensional gene expression data to a smaller number of dimensions for visualization and analysis (e.g., PCA, t-SNE, UMAP).</p> <p>Tags: single-cell-analysis</p>"},{"location":"glossary.html#feature-selection","title":"Feature Selection","text":"<p>The process of identifying the most informative genes (highly variable genes) for downstream analysis while filtering out noise.</p> <p>Tags: single-cell-analysis</p>"},{"location":"glossary.html#gene-signature","title":"Gene Signature","text":"<p>A set of genes whose coordinated expression pattern characterizes a specific cell type, state, or biological process.</p> <p>Tags: single-cell-analysis</p>"},{"location":"glossary.html#highly-variable-genes-hvgs","title":"Highly Variable Genes (HVGs)","text":"<p>Genes that show significant variation in expression across cells, often used for dimensionality reduction and clustering.</p> <p>Tags: single-cell-analysis</p>"},{"location":"glossary.html#imputation","title":"Imputation","text":"<p>Computational methods to estimate and fill in missing values (dropouts) in single-cell expression matrices.</p> <p>Tags: single-cell-analysis</p>"},{"location":"glossary.html#louvain-clustering","title":"Louvain Clustering","text":"<p>A community detection algorithm commonly used to identify clusters in single-cell data based on a k-nearest neighbor graph.</p> <p>Tags: single-cell-analysis</p>"},{"location":"glossary.html#marker-gene","title":"Marker Gene","text":"<p>A gene whose expression is highly specific to a particular cell type or state, used for cell type identification and annotation.</p> <p>Tags: single-cell-analysis</p>"},{"location":"glossary.html#normalization","title":"Normalization","text":"<p>Statistical methods to account for technical variation in sequencing depth and efficiency across cells, making expression levels comparable.</p> <p>Tags: single-cell-analysis</p>"},{"location":"glossary.html#principal-component-analysis-pca","title":"Principal Component Analysis (PCA)","text":"<p>A linear dimensionality reduction technique that identifies the directions of maximum variance in high-dimensional data.</p> <p>Tags: single-cell-analysis</p>"},{"location":"glossary.html#quality-control-qc","title":"Quality Control (QC)","text":"<p>The process of filtering out low-quality cells and genes based on metrics such as total counts, number of detected genes, and mitochondrial gene percentage.</p> <p>Tags: single-cell-analysis</p>"},{"location":"glossary.html#seurat","title":"Seurat","text":"<p>A widely used R package for single-cell RNA sequencing analysis, including QC, normalization, clustering, and visualization.</p> <p>Tags: single-cell-analysis</p>"},{"location":"glossary.html#t-sne","title":"t-SNE","text":"<p>t-distributed Stochastic Neighbor Embedding - A nonlinear dimensionality reduction technique for visualizing high-dimensional data in 2D or 3D space.</p> <p>Tags: single-cell-analysis</p>"},{"location":"glossary.html#umap","title":"UMAP","text":"<p>Uniform Manifold Approximation and Projection - A nonlinear dimensionality reduction technique that preserves both local and global structure, commonly used for visualizing single-cell data.</p> <p>Tags: single-cell-analysis</p>"},{"location":"glossary.html#differentiation-trajectory","title":"Differentiation Trajectory","text":"<p>The developmental path cells follow as they transition from one cell state to another, often visualized as a continuous path in reduced dimensional space.</p> <p>Tags: single-cell-analysis</p>"},{"location":"glossary.html#monocle","title":"Monocle","text":"<p>A software package for analyzing single-cell trajectories and inferring developmental progression using pseudotime analysis.</p> <p>Tags: single-cell-analysis</p>"},{"location":"glossary.html#pseudotime","title":"Pseudotime","text":"<p>A computational measure representing the progress of individual cells along a biological process (e.g., differentiation) based on gene expression patterns, independent of actual sampling time.</p> <p>Tags: single-cell-analysis</p>"},{"location":"glossary.html#rna-velocity","title":"RNA Velocity","text":"<p>A method for predicting future cell states by analyzing the ratio of unspliced to spliced mRNA, providing information about the direction and speed of transcriptional changes.</p> <p>Tags: single-cell-analysis</p>"},{"location":"glossary.html#trajectory-inference","title":"Trajectory Inference","text":"<p>Computational methods for reconstructing continuous developmental processes and lineage relationships from single-cell snapshots.</p> <p>Tags: single-cell-analysis</p>"},{"location":"glossary.html#transition-state","title":"Transition State","text":"<p>An intermediate cell state during differentiation or other dynamic processes, often characterized by expression of genes from multiple cell types.</p> <p>Tags: single-cell-analysis, stem-bio</p>"},{"location":"glossary.html#waddington-landscape","title":"Waddington Landscape","text":"<p>A conceptual model visualizing cell differentiation as cells rolling down valleys in a landscape, with cell fate determined by the path taken.</p> <p>Tags: stem-bio, dev-bio</p>"},{"location":"glossary.html#cell-cell-communication","title":"Cell-Cell Communication","text":"<p>Computational inference of intercellular signaling based on expression of ligands in sender cells and receptors in receiver cells.</p> <p>Tags: single-cell-analysis, cell-bio</p>"},{"location":"glossary.html#cellular-heterogeneity","title":"Cellular Heterogeneity","text":"<p>The variation in cell states, types, or behaviors within a population, observable through differences in gene expression or other molecular features.</p> <p>Tags: single-cell-analysis, cell-bio</p>"},{"location":"glossary.html#multimodal-analysis","title":"Multimodal Analysis","text":"<p>Simultaneous measurement of multiple molecular modalities (e.g., RNA, protein, chromatin accessibility) in the same single cells.</p> <p>Tags: single-cell-tech</p>"},{"location":"glossary.html#perturbation-sequencing-perturb-seq","title":"Perturbation Sequencing (Perturb-seq)","text":"<p>A method combining CRISPR-based genetic perturbations with single-cell RNA sequencing to study gene function at scale.</p> <p>Tags: single-cell-tech</p>"},{"location":"glossary.html#regulatory-network-inference","title":"Regulatory Network Inference","text":"<p>Computational methods for identifying transcription factors and their target genes that control cell state transitions.</p> <p>Tags: single-cell-analysis</p>"},{"location":"glossary.html#spatial-transcriptomics","title":"Spatial Transcriptomics","text":"<p>Technologies that measure gene expression while preserving spatial location information within tissues.</p> <p>Tags: single-cell-tech</p>"},{"location":"glossary.html#transcription-factor-tf","title":"Transcription Factor (TF)","text":"<p>A protein that binds to specific DNA sequences to control the rate of transcription of genetic information from DNA to RNA.</p> <p>Tags: cell-bio, dev-bio</p>"},{"location":"readings.html","title":"Readings","text":"<p>Access to materials listed here is available to current students</p> <p>Files listed for download below can only be accessed after authenticating via Hopkin's SSO</p>"},{"location":"readings.html#week-1-jan-2022-intro-to-course-and-single-cell-omics","title":"Week 1 (Jan 20/22): Intro to course and single cell omics","text":"<ol> <li> <p>New York Times article: A potential cure for type one diabetes pdf</p> </li> <li> <p>Macosko EZ, Basu A, Satija R, et al. Highly Parallel Genome-wide Expression Profiling of Individual Cells Using Nanoliter Droplets. Cell. 2015;161(5):1202-1214. doi:10.1016/j.cell.2015.05.002 pmid:26000488/ pdf </p> </li> </ol>"},{"location":"readings.html#week-2-jan-2729-analysis-of-single-cell-omics","title":"Week 2 (Jan 27/29): analysis of single cell omics","text":"<ol> <li>Luecken MD, Theis FJ. Current best practices in single-cell RNA-seq analysis: a tutorial. Mol Syst Biol. 2019 Jun 19;15(6):e8746. doi: 10.15252/msb.20188746. PMID: 31217225; PMCID: PMC6582955. pdf</li> </ol>"},{"location":"readings.html#week-3-feb-35-more-analysis-of-single-cell-omics","title":"Week 3 (Feb 3/5): more analysis of single cell omics","text":"<ol> <li> <p>The cell cycle From The Science of Stem Cells by Jonathan Slack pdf</p> </li> <li> <p>Ringn\u00e9r M. What is principal component analysis? Nat Biotechnol. 2008 Mar;26(3):303-4. doi: 10.1038/nbt0308-303. PMID: 18327243 pdf</p> </li> <li> <p>D'haeseleer P. How does gene expression clustering work? Nat Biotechnol. 2005 Dec;23(12):1499-501. doi: 10.1038/nbt1205-1499. PMID: 16333293 pdf</p> </li> </ol>"},{"location":"refs.html","title":"References","text":""},{"location":"schedule.html","title":"Schedule","text":"<p>There are four chapters, or broad themes, that we will cover in this course:</p> <ol> <li>single cell genomics</li> <li>cell identity</li> <li>trajectory inference and fate potential</li> <li>regulatory networks</li> </ol> <p>Access to videos and slides listed here is available to current students</p> <p>The lecture videos and slides can only be accessed after authenticating via Hopkin's SSO</p> What Date Chapter Topic video slides other Lecture 1 01-20-26 1 Course introduction intro to course slides Lecture 2 01-22-26 1 scRNAseq data generation dropseq slides Lecture 3 01-27-26 1 Hematopoiesis; scRNAseq analysis I tutorial notebook Colab setup Lecture 4 01-29-26 1 scRNAseq analysis II scRNAseq analysis II notebook HW 1 due 01-30-26 11:59pm 1 HW1: scRNAseq analysis I HW 1 Lecture 5 02-03-26 1 scRNAseq analysis III; cell cycle scRNAseq analysis III - Lecture 6 02-05-26 1 Early applications of sc omics to stem cells - - HW 2 due 02-13-26 11:59pm 1 HW2: more scRNAseq analysis HW 2 Test 1 02-10-26 1 sc omics HW 3 due 02-25-26 2 HW3: cell identity - Test 2 03-05-26 2 cell identity HW 4 due 03-27-26 3 HW4: trajectories and fate potential - Test 3 04-02-26 3 trajectories and fate potential HW 5 due 04-17-26 4 HW5: regulatory networks - Test 4 04-23-26 4 regulatory networks"},{"location":"hws/index.html","title":"Guidelines","text":"<p>Each homework entails applying what you have learned in class to analyze real (or realistic) single cell data. In some cases, you will be asked to devise new approaches to analze the data, or to adapt existing ones. In all cases, you will be asked to interpret your results in the context of the literature to which you have been exposed. Each Homework will have a Deliverables section that explicitly states what you must provide to receive full credit. </p> <p>Check you submissions</p> <p>All submissions must include all code necessary to replicate your results. And the must adhere to the posted guidelines for code documentation, cogent written reports, and meaningful figures (see below).</p>"},{"location":"hws/index.html#style-guide-checklist","title":"Style guide checklist","text":"<p>Before turning in your assignments, please consult this checklist. This will make your work easier for us to understand, so that we can grade efficiently and fairly and provide more useful feedback. Check out the style guide example (below) to see what this looks like in practice. </p> <ul> <li>Organization:<ul> <li> The code and answers are in the same order as the questions in the assignment, OR </li> <li> There are reasonable deviations from the prescribed order, but the first chunk provides a table of contents or clear explanation. </li> </ul> </li> <li>Communication:<ul> <li> Statements about data/results are in Markdown chunks, not code comments.</li> <li> Code comments usually answer \"why?\" not \"what?\"[^1]    </li> </ul> </li> </ul> <p>[^1] Our comments will often violate \"why not what\" because we need to convey what the code does to everyone in the class, even if they are new to Python and/or genomics. By contrast, you are writing for an audience with some experience (us), so you should follow \"why not what\" even if you see us breaking this rule.</p>"},{"location":"hws/final_project.html","title":"Final Project","text":"<p>'I heard the jury is still out on science' --GOB from Arrested Development</p> <p>Now is your chance to flex your single cell analysis muscles. You are a beast. Show us what you can do!  In the final project, you will develop a new analysis method, benchmark it, and then you will use it to address an open question in stem cell biology. </p> <p>Deadline: Wednesday May 7th 11:59pm</p> <p>Absolutely NO Extensions</p> <p>Really, no extensions.</p>"},{"location":"hws/final_project.html#introduction","title":"Introduction","text":"<p>DNA copy number alterations (CNA) have been detected in embryonic stem cells (ESC) and induced pluripotent stem cells (iPSC -- we will refer to pluripotent stem cells of any variety as PSCs). The origins of CNAs in PSCs is varied. Some likely arise as an adaptation to life in culture.<sup>1</sup> Some may arise from somatic mosaicism in iPSC founder cell population<sup>2</sup>. And some may arise during the programming process itself.<sup>3</sup>,<sup>4</sup> </p> <p>CNAs in PSCs can be problematic. The lesions may be tumorigenic, they may hinder differentiation generally or derivation of specific lineages<sup>5</sup>, and they may obscure disease-specific phenotypes when the PSC is used for disease modeling. (Please check out this review<sup>6</sup> and references therein for a comprehensive discussion). Therefore, methods to detect CNAs in PSCs would be highly useful. There are lots of experimental ways to detect CNAs, including karyotyping, FISH, array comparative genomic hybridization, single nucleotide polymorphism (SNP) arrays<sup>3</sup>, and genome sequencing. In 2010, a method called e-karyotyping was published that attempted to infer CNAs based on expression of genes co-located in the genome<sup>7</sup>. This is cool because it leverages data that already exists. In effect, this method is a 'twofer': where you get two things for the price of one. However, it makes the assumption that DNA copy number is reflected by expression levels of genes that are co-located in the genome.</p> <p>The pressing question for your team is to define the distribution of CNAs in human PSCs using available scRNA-seq data. To achieve this, you will have to develop a tool that identifies CNAs from scRNA-seq, evaluate its performance, apply it to PSCs, and synthesize your findings with those previously reported in the literature. More details can be found below as well as specifications that distinguish what is required for 447 and 647 teams.</p> <p>Terminology</p> <p>Sometimes I might refer to CNAs as CNVs. I use these terms interchangably but some might argure that they are different things. Regardless, if you see a mention of 'CNV' here, just mentally substitute in 'CNA'</p>"},{"location":"hws/final_project.html#your-mission","title":"Your mission","text":""},{"location":"hws/final_project.html#task-1-create-a-method-that-infers-cnas-from-scrna-seq-data","title":"Task 1: Create a method that infers CNAs from scRNA-seq data","text":"<p>Write a Python package that allows users to define the genotype and genomic region of CNAs from scRNA-seq data. genotype in this case can be either 'gain' or 'loss'. The minimal input is an annData object that contains raw expression counts of genes that are named in the .var slot across the cells listed in the .obs slot. The output should be:</p> <ol> <li>a list of CNAs where each CNA is defined by genomic region (chromosome, start, stop,) and some indication of the type of CNA (e.g. 'gain' | loss')</li> <li>an assignment of CNAs to cells, or to groups of cells.</li> </ol> <p>This output should be structured to facilitate CNA visualization as we show below. It is OK for your function to add this output to the input adata.</p> <p>Other requirements:</p> <ul> <li>The method must be written in Python</li> <li>The code must be housed at GitHub</li> <li>The code must be organized following Python package conventions. See this tutorial as a guide. Note that you do not have to upload it to PyPI. </li> <li>Your repo must contain documentation that describes how to install your package and how to use it. The easiest place to put this information is in a README.md file.</li> </ul> <p>Here are some more things to consider:</p> <ul> <li>Most of the time, annData objects do not contain genomic regions for their genes, so you need to do something about this. </li> <li>Other attempts to solve this problem include gene-specific normalization based on comparison of each cell or sample to a diploid control. How these control samples use for comparison is selected is important.</li> <li>We recommend that you test your ideas on minimally sufficient slices of the test data that we provide.</li> <li>Check out the following papers and resources for ideas:<ul> <li>Benchmarking CNA prediction methods paper<sup>8</sup></li> <li>Python port of the InferCNV method</li> </ul> </li> </ul>"},{"location":"hws/final_project.html#task-2-assessment","title":"Task 2: Assessment","text":""},{"location":"hws/final_project.html#task-2a-assess-the-performance-of-your-method","title":"Task 2A: Assess the performance of your method","text":"<p>Apply your method to the test data that we provided. Analze your method's performance in terms of standard metrics such as accuracy, or area under precision recall curves. If your method scores CNAs to reflect confidence in their prediction, then also evaluate this aspect. If your method has tunable parameters, then evaluate its performance across a well-justified range of parameter value combinations.</p> <p>Other requirements:</p> <ul> <li>Explore the impact of read depth on your method's performance. Scanpy has functions for down-sampling</li> <li>Notebooks that document this task's analysis must be included in your GitHub repo</li> </ul>"},{"location":"hws/final_project.html#task-2b-augment-assessment-with-better-gold-standard-data","title":"Task 2B: Augment assessment with better gold standard data","text":"<p>647 only!</p> <p>This task is required for only for 647 teams. 447 teams are allowed to complete it for extra credit.</p> <p>The validatation data is very limited. There are only 3 CNAs, and they do not vary much in size or frequency. To assess your method more robustly, generate or acquire gold standard data that has CNAs that:</p> <ul> <li>have wider range of sizes</li> <li>have wider ranges of frequencies</li> </ul> <p>Use this extended gold standard data to evaluate your methods ability to resolve CNAs from small to large, and to detect CNAs across frequencies. </p> <p>If you choose to simulate a gold standard data as we have done, then you must include your simulation functionality in your method's package. If you acquire gold standard data, then you must report the precise source, how the CNA's were defined, and include in your repo any pre-processing of the data required to make it amenable to your analysis.</p> <p>Other requirements: * Notebooks that document this task's analysis must be included in your GitHub repo</p>"},{"location":"hws/final_project.html#task-3-measure-cna-in-pscs","title":"Task 3: Measure CNA in PSCs","text":"<p>Now that you have developed and assessed your method, it is time to use it! Take a look at the list of PSC scRNA-seq data below. Find an optimal subset of these datasets to see if you can infer previously reported PSC CNAs and to discover new ones.</p> <p>Things to consider:</p> <ul> <li>You do not have to analyze all of these data sets</li> <li>You may analyze other data sets that you find as long as they are either human PSCs or their derivatives</li> <li>You may need to integrate data across studies to infer CNAs that are cell line specific</li> </ul> <p>Other requirements: * Notebooks that document this task's analysis must be included in your GitHub repo</p>"},{"location":"hws/final_project.html#task-4-predict-cna-impact","title":"Task 4: Predict CNA impact","text":"<p>Extra credit</p> <p>This task is not required. It is a bonus task and will be scored as extra-credit.</p> <p>Devise and apply a method to predict the functional impact on PSCs of CNAs in catalog that you generated in Task 3. </p> <p>Other requirements: * Notebooks that document this task's analysis must be included in your GitHub repo </p>"},{"location":"hws/final_project.html#deliverables","title":"Deliverables","text":"<p>Your grade in this project has a team component and an individual component. All team members will receive the same grade on the team component, but individuals from the same team can receive different grades on the individual component. Below is a summary of each deliverable in the Team and Individual parts. </p>"},{"location":"hws/final_project.html#team-deliverables","title":"Team deliverables","text":"<ol> <li>A link to a GitHub repository that is home to your Python package. This link should be included in the paper that you send us (see deliverable 2).</li> <li>Write a paper that describes your tool and its application to characterize CNAs in PSCs. Your paper should follow the 'Problem solving article' format described here for the journal Briefings in Bioinformatics. This article type is described as:</li> </ol> <p>Paper format</p> <p>Problem solving protocols: development of methods based on comparison, new software, or new pipeline of existing software for solving a specific bioinformatics problem. Real experimental data must be analyzed. Problem solving protocol papers should demonstrate a new methodological application to a meaningful biological problem. Original algorithms also accepted. (2000-5000 words)</p> <p>Your paper must address how you completed each Task and your results. If your team went after Task 4, then your approach and results should also be included in the paper. You must include display items that clearly represent your work. Please try to format the display items as if you were really going to submit this to a journal. For example, each figure should fit on one page, axes clearly labeled. This makes the reading experience so much more enjoyable for your audience and these positive vibes tend to translate into higher scores.</p> <ol> <li>A pre-recorded presentation in which you show off your tool and what you learned by its application. Send us your slides, too.</li> <li>Attendance at the presentation viewing and Q &amp; A session on the morning of May 12th. At least one team member must participate (in person or via Zoom) and be prepared to answer questions following the showing of their teams video. </li> </ol>"},{"location":"hws/final_project.html#individual-deliverables","title":"Individual deliverables","text":"<ol> <li> <p>Your assessment of your teamates contributions to the final project. </p> <ul> <li>Please score each team member from 1 (superlative) to 10 (unacceptable) in the following categories:<ul> <li>Contributed to team discussions and planning</li> <li>Fulfilled their assigned tasks</li> <li>Timeliness of contributions</li> <li>Responsiveness to intra-team communications</li> <li>Pro-active member of the team</li> </ul> </li> <li>For each team member, write 1-3 sentences that summarizes their role in the project and any other comments</li> </ul> </li> <li> <p>Your assessment of another team's final project. Each student will be assigned to read another teams paper or test their code. In this deliverable, you must score the code or paper with the scoring system: 1 (superlative) to 10 (unacceptable) for the following categories.</p> <ul> <li>Paper<ul> <li>Does the paper address Task 1?</li> <li>Does the paper address Task 2?</li> <li>Does the paper address Task 3?</li> <li>Clarity of writing</li> <li>Depth of thought in discussion</li> <li>Appropriate framing of background in Introduction</li> <li>Use of appropriate display items (i.e. tables and figures)</li> <li>Finish your paper evaluation with a written summary of one paragraph and overall score (1-10). The summary might include specific examples from the paper for improvement or examples of excellent work.</li> </ul> </li> <li>Code<ul> <li>Ease of installation</li> <li>Clarity of documentation, including guidance for any parameter tuning</li> <li>Ease of running example(s) provided in README</li> <li>Experience when applying to a user-provided dataset</li> <li>Reproducibility of Task analysis notebooks</li> </ul> </li> </ul> </li> </ol>"},{"location":"hws/final_project.html#data","title":"Data","text":""},{"location":"hws/final_project.html#cna-benchmarking-data","title":"CNA benchmarking data","text":"<p>PBMC_simulated_cnas_041025.h5ad. We have created a scRNAseq dataset with defined CNAs. It is based on the PBMC data used earlier in course, but we have simulated the impact on expression of genes that overlap with three CNAs. One is on Chr X (a copy number gain), one is on Chr 22 (a homozygous loss -- both alleles were deleted), and one is on Chr 6 (a heterozygous loss -- only one allele was deleted). The CNA genotype (that is, the set of specfic genetic variants of a sample -- in this case, the set of CNAs that a cell has) of each cells is stored in <code>adata.obs[\"simulated_cnvs\"]</code>, which also indicates the precise genomic coordinates of the CNAs and its copy number (CN):</p> <pre><code>adata.obs['simulated_cnvs'].value_counts()\nsimulated_cnvs\n                                                           6312\nX:106533974-112956833 (CN 4)                               1731\n6:25435484-35035259 (CN 1)                                  895\n22:19807132-29743868 (CN 0), 6:25435484-35035259 (CN 1)     700\n22:19807132-29743868 (CN 0)                                 671 \n</code></pre> <p>The CNAs were simulated in a cell-type specific manner, meaning that each CNA appears only in one cell type, but not in all cells of that cell type. In this case, CD4 T cells have the ChrX gain, and CD14 monocytes have the Chr6 and Chr22 losses. This is a bit more complicated a situation that one might expect to face when inferrring CNAs from undifferentiated PSCs, but we include it here because some of the PSC data provided also include differentiated progeny. To quickly view how the CNAs impact expression, you could plot a heatmap in which the cells are the rows, grouped by genotype, and the columns are genes, ordered by genomic position:</p> <pre><code># get slice of cd14 monocytes and Chr22\nadMono = adata[adata.obs['cell_type'] == 'CD14 monocyte'].copy()\nadChr22 = adMono[:,adMono.var['chromosome']=='22'].copy()\n# Raw counts on left\nsc.pl.heatmap(adChr22, adChr22.var_names, groupby='simulated_cnvs',layer=\"counts\", log=True)\n# gene-scaled on right makes the CNA footprint more apparent\nsc.pl.heatmap(adChr22, adChr22.var_names, groupby='simulated_cnvs',layer=\"counts\", log=True, standard_scale='var')\n</code></pre> <p></p> <p>The CNA is evident as a region with no expression in a subset of the cells.</p>"},{"location":"hws/final_project.html#psc-scrnaseq-data","title":"PSC scRNAseq data","text":"<p>Here is a list of publicly available scRNA-seq data of human PSCs and/or their differentiated progeny. Note that in some cases, we were able to easily find the name of the PSC cell line(s), but in other cases you will have to do this yourself.</p> <ol> <li>2D gastruloids<ul> <li>Data: https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE262081</li> <li>Paper: https://pubmed.ncbi.nlm.nih.gov/38585971/</li> </ul> </li> <li>PSC-derived kidney organoids<ul> <li>Data: https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE252104</li> <li>Paper: https://www.ncbi.nlm.nih.gov/pubmed/39482314</li> </ul> </li> <li>iPSC -&gt; HSC<ul> <li>Data: https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE263152</li> </ul> </li> <li>PGP1 line:<ul> <li>https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE277604</li> </ul> </li> <li>Somitoids, days 1 - 5<ul> <li>hiPSC line NCRM1 human IPSC</li> <li>https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE194214</li> <li>https://pubmed.ncbi.nlm.nih.gov/35088712/</li> </ul> </li> <li>hESC -&gt; endothelial<ul> <li>H9 hESC cell line</li> <li>https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE131736</li> <li>https://pubmed.ncbi.nlm.nih.gov/31242503/</li> </ul> </li> <li>Somitoids and segmentoids<ul> <li>https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE195467</li> <li>day 0 -&gt; day 7</li> </ul> </li> <li>CM differentiation<ul> <li>days 0,2,4,10</li> <li>https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE130731</li> <li>2 cell lines were pooled! Can you distinguish them from scRNA-seq?</li> </ul> </li> <li>Fibroblasts reprogrammed to iPSCs<ul> <li>Available from ArrayExpress with accession E-MTAB-10060</li> <li>Paper: https://link.springer.com/article/10.1186/s13059-021-02293-3</li> </ul> </li> <li>Embryoid bodies<ul> <li>Paper: https://www.nature.com/articles/s41467-020-14457-z </li> <li>Data:  https://zenodo.org/records/3625024#.Xil-0y2cZ0s</li> </ul> </li> <li>CM differentiation from PSC<ul> <li>Paper: https://www.ahajournals.org/doi/10.1161/CIRCRESAHA.118.312913?doi=10.1161/CIRCRESAHA.118.312913</li> <li>Data: https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE116555</li> </ul> </li> <li>Embryoid body differentiation from hESCs<ul> <li>https://www.sciencedirect.com/science/article/pii/S2213671119300244</li> </ul> </li> <li>TF overexpression in hiPSCs<ul> <li>Paper: https://pubmed.ncbi.nlm.nih.gov/36608654/</li> <li>Data: https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE216481 </li> </ul> </li> <li>Embryoid bodies<ul> <li>Data: https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE125416</li> <li>Paper: https://www.biorxiv.org/content/10.1101/2022.07.20.500831v2.full</li> </ul> </li> <li>KOLF2.1J iPSC -&gt; neurons<ul> <li>Data: https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE243112</li> <li>Paper: https://www.ncbi.nlm.nih.gov/pubmed/38575728</li> <li>Note that it was later discovered that this cell line harbors some very small CNAs. See https://pmc.ncbi.nlm.nih.gov/articles/PMC11857058/.</li> </ul> </li> <li>hESC to microglia<ul> <li>Data: https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE139550</li> <li>Paper: https://www.ncbi.nlm.nih.gov/pubmed/33558694</li> </ul> </li> <li>PSC -&gt; CM<ul> <li>Note this data is multiplexed and unclear if there is sufficient information in the GEO access to de-multiplex</li> <li>Data: https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE202398</li> <li>Paper: https://elifesciences.org/articles/80075</li> </ul> </li> </ol>"},{"location":"hws/final_project.html#references","title":"References","text":"<ol> <li> <p>Screening ethnically diverse human embryonic stem cells identifies a chromosome 20 minimal amplicon conferring growth advantage Nat Biotechnol. 2011 Nov 27;29(12):1132-44. doi: 10.1038/nbt.2051. PMID: 22119741; \u21a9</p> </li> <li> <p>Abyzov A, Mariani J, Palejev D, Zhang Y, Haney MS, Tomasini L, Ferrandino AF, Rosenberg Belmaker LA, Szekely A, Wilson M, Kocabas A, Calixto NE, Grigorenko EL, Huttner A, Chawarska K, Weissman S, Urban AE, Gerstein M, Vaccarino FM. Somatic copy number mosaicism in human skin revealed by induced pluripotent stem cells. Nature. 2012 Dec 20;492(7429):438-42. doi: 10.1038/nature11629. Epub 2012 Nov 18. PMID: 23160490; PMCID: PMC3532053. \u21a9</p> </li> <li> <p>Laurent LC, Ulitsky I, Slavin I, Tran H, Schork A, Morey R, Lynch C, Harness JV, Lee S, Barrero MJ, Ku S, Martynova M, Semechkin R, Galat V, Gottesfeld J, Izpisua Belmonte JC, Murry C, Keirstead HS, Park HS, Schmidt U, Laslett AL, Muller FJ, Nievergelt CM, Shamir R, Loring JF. Dynamic changes in the copy number of pluripotency and cell proliferation genes in human ESCs and iPSCs during reprogramming and time in culture. Cell Stem Cell. 2011 Jan 7;8(1):106-18. doi: 10.1016/j.stem.2010.12.003. PMID: 21211785; PMCID: PMC3043464. \u21a9\u21a9</p> </li> <li> <p>Hussein SM, Batada NN, Vuoristo S, Ching RW, Autio R, N\u00e4rv\u00e4 E, Ng S, Sourour M, H\u00e4m\u00e4l\u00e4inen R, Olsson C, Lundin K, Mikkola M, Trokovic R, Peitz M, Br\u00fcstle O, Bazett-Jones DP, Alitalo K, Lahesmaa R, Nagy A, Otonkoski T. Copy number variation and selection during reprogramming to pluripotency. Nature. 2011 Mar 3;471(7336):58-62. doi: 10.1038/nature09871. PMID: 21368824. \u21a9</p> </li> <li> <p>Markouli C, Couvreu De Deckersberg E, Regin M, Nguyen HT, Zambelli F, Keller A, Dziedzicka D, De Kock J, Tilleman L, Van Nieuwerburgh F, Franceschini L, Sermon K, Geens M, Spits C. Gain of 20q11.21 in Human Pluripotent Stem Cells Impairs TGF-\u03b2-Dependent Neuroectodermal Commitment. Stem Cell Reports. 2019 Jul 9;13(1):163-176. doi: 10.1016/j.stemcr.2019.05.005. Epub 2019 Jun 6. PMID: 31178415; \u21a9</p> </li> <li> <p>Halliwell J, Barbaric I, Andrews PW. Acquired genetic changes in human pluripotent stem cells: origins and consequences. Nat Rev Mol Cell Biol. 2020 Dec;21(12):715-728. doi: 10.1038/s41580-020-00292-z. Epub 2020 Sep 23. PMID: 32968234. \u21a9</p> </li> <li> <p>Mayshar Y, Ben-David U, Lavon N, Biancotti JC, Yakir B, Clark AT, Plath K, Lowry WE, Benvenisty N. Identification and classification of chromosomal aberrations in human induced pluripotent stem cells. Cell Stem Cell. 2010 Oct 8;7(4):521-31. doi: 10.1016/j.stem.2010.07.017. PMID: 20887957. \u21a9</p> </li> <li> <p>Song M, Ma S, Wang G, Wang Y, Yang Z, Xie B, Guo T, Huang X, Zhang L. Benchmarking copy number aberrations inference tools using single-cell multi-omics datasets. Brief Bioinform. 2025 Mar 4;26(2):bbaf076. doi:10.1093/bib/bbaf076. PMID: 40037644; PMCID: PMC11879432. \u21a9</p> </li> </ol>"},{"location":"hws/guidelines.html","title":"Guidelines","text":"<p>Each homework entails applying what you have learned in class to analyze real (or realistic) single cell data. In some cases, you will be asked to devise new approaches to analze the data, or to adapt existing ones. In all cases, you will be asked to interpret your results in the context of the literature to which you have been exposed. Each Homework will have a Deliverables section that explicitly states what you must provide to receive full credit. </p> <p>Check you submissions</p> <p>All submissions must include all code necessary to replicate your results. And the must adhere to the posted guidelines for code documentation, cogent written reports, and meaningful figures (see below).</p>"},{"location":"hws/guidelines.html#style-guide-checklist","title":"Style guide checklist","text":"<p>Before turning in your assignments, please consult this checklist. This will make your work easier for us to understand, so that we can grade efficiently and fairly and provide more useful feedback. Check out the style guide example (below) to see what this looks like in practice. </p> <ul> <li>Organization:<ul> <li> The code and answers are in the same order as the questions in the assignment, OR </li> <li> There are reasonable deviations from the prescribed order, but the first chunk provides a table of contents or clear explanation. </li> </ul> </li> <li>Communication:<ul> <li> Statements about data/results are in Markdown chunks, not code comments.</li> <li> Code comments usually answer \"why?\" not \"what?\"<sup>1</sup> </li> </ul> </li> </ul> <ol> <li> <p>Our comments will often violate \"why not what\" because we need to convey what the code does to everyone in the class, even if they are new to Python and/or genomics. By contrast, you are writing for an audience with some experience (us), so you should follow \"why not what\" even if you see us breaking this rule.\u00a0\u21a9</p> </li> </ol>"},{"location":"hws/hw_1.html","title":"Homework 1","text":"<p>Homework 1: Fundamentals of scRNA-seq analysis in Python</p> <p>Deadline: Friday, Jan 30th 2026 11:59pm</p>"},{"location":"hws/hw_1.html#background","title":"Background","text":"<p>We discussed hematopoiesis and the types of cells found in peripheral blood mononuclear cells (PBMCs) in Lecture 3. We also walked through the analysis of a human PBMC scRNA-seq data set, from CellRanger output to a cleaned anndata object decorated with cell type annotations for each cell. In this homework, you are going to explore what scRNA-seq tells us about PBMC cell type composition, and you are going to explore the impact of varying steps in the analysis pipeline on your estimate of cell type composition.</p> <p>Cell type composition</p> <p>You should think about and compute Cell type composition relative to the total number of cells sampled. For example, after you perform QC on Sample 1, maybe your anndata object has 10,000 cells. Downstream analysis (i.e. all the steps from filtering to annotation) results in 7500 cells labeled as 'T cell'. In this case, the T cell fraction of the cell composition is 75%.</p>"},{"location":"hws/hw_1.html#cell-types-in-pbmcs-and-their-distinctive-genes","title":"Cell types in PBMCs and their distinctive genes","text":""},{"location":"hws/hw_1.html#composition-as-claimed-in-literature","title":"Composition, as claimed in literature","text":"<ul> <li>T cell: 70%</li> <li>B cell: 15%</li> <li>Natural killer (NK) cells: 10%</li> <li>Monocyte: 5%</li> <li>Dendritic cells: 1%</li> <li> Yes, the total is 101%. Don't look at me. I am just reporting what is listed in the literature.</li> </ul>"},{"location":"hws/hw_1.html#marker-genes","title":"Marker genes","text":""},{"location":"hws/hw_1.html#monocyte","title":"Monocyte","text":"<ul> <li>LYZ (Lysozyme), CD14, CD68</li> <li>sub-types:<ul> <li>Classical:  CD14, LYZ, S100A8/S100A9, CCR2</li> <li>Intermediate: FCGR3A (CD16), CD163, IL1B</li> <li>non-classical: CX3CR1, FCGR3A (CD16), CCR5</li> </ul> </li> </ul>"},{"location":"hws/hw_1.html#natural-killer-cell","title":"Natural killer cell","text":"<ul> <li>NCAM1 , KIR2DL1, KIR2DL3, KIR2DL4, KIR3DL1, KIR3DL2, NKG2A/C/E (KLRC1/KLRC2/KLRC3), NKG2D (KLRK1), GNLY, GZMB</li> <li>Note that some are also expressed by subsets of T cell</li> </ul>"},{"location":"hws/hw_1.html#b-cell","title":"B cell","text":"<ul> <li>CD19, CD79A, CD79B, CD20</li> <li>Will leave sub-type exploration to student</li> </ul>"},{"location":"hws/hw_1.html#t-cell","title":"T cell","text":"<ul> <li>CD3D, CD3E, CD3G</li> <li>Will leave sub-type exploration to student</li> </ul>"},{"location":"hws/hw_1.html#dendritic-cell","title":"Dendritic cell","text":"<ul> <li>FLT3, CD11C CD1C</li> <li>CD123 &amp; CLEC4C  (plasmacytoid dendritic cell)</li> </ul>"},{"location":"hws/hw_1.html#granulocytes-and-megakaryocytes","title":"Granulocytes and Megakaryocytes","text":"<ul> <li>Not widely recognized as occurring in PBMC</li> <li>If you suspect that these cells are present in the data, then you should identify and include makers thereof in your analysis</li> </ul>"},{"location":"hws/hw_1.html#data","title":"Data","text":"<p>This is the same Sample 1 as we used in Lecture 4. Here are some more details:</p> <ul> <li>11,769  PBMCs from a healthy Donor. Data generated using 10X genomics v3 chemistry and processed with Cell Ranger 3.0.0</li> <li>Sequenced on Illumina NovaSeq with approximately 54,000 reads per cell</li> <li>10X Genomics web page for this data</li> <li>URL to h5 file:<ul> <li>https://cf.10xgenomics.com/samples/cell-exp/3.0.0/pbmc_10k_v3/pbmc_10k_v3_filtered_feature_bc_matrix.h5</li> </ul> </li> </ul> <p>Your mission</p> <p>Analyze the provided data to address the questions listed below</p> <ol> <li> <p>What cell types are present in the data and in what proportions?</p> <p>Deliverables:</p> <ul> <li> new .obs column indicating cell type</li> <li> appropriate visualization (i.e. UMAP with clusters labeled, supported by dotplot that shows expression of marker genes)</li> </ul> </li> <li> <p>How does this estimate of cell composition compare to prior literature?     To evaluate this rapidly and efficiently, generate a figure that depicts cell type composition as a stacked barplot. Your figure should show one stacked bar representing the scRNAseq cell type proportions, and one that represents the proportions from the literature as listed above. To be clear, each rectangle in stacked bar should reflect the percent of a sample that is annotated as cell type X.</p> <p>Deliverables:</p> <ul> <li> Show your code</li> <li> The figure</li> </ul> </li> <li> <p>What are the transcriptional signatures of each of the PBMC cell types? We know about some genes that are preferentially expressed in each PBMC cell type (in fact, you used some of these to perform cluster annotation). But one of the benefits of performing genome-wide analyses is that it can identify genes previously unlinked to the phenomenon under study. Your task here is to identify all genes that are preferentially expressed in each PBMC cell type. </p> <p>Deliverables:</p> <ul> <li> Show your code</li> <li> The lists of signature genes for each cell type.</li> <li> Visualization: plot the cell type signatures using the builtin scanpy functions for heatmaps, matrixplot and dotplot. Use your judgement to select n, the top n set of genes to display for each cell type. Indicate in each figure the marker genes listed above.</li> </ul> </li> </ol> <p>ALL SUBMISSIONS MUST...</p> <p>... include all code necessary to replicate the results, and must adhere to posted guidelines for code documentation, cogent written reports, and meaningful figures.</p>"},{"location":"hws/hw_2.html","title":"Homework 2","text":"<p>Homework 2: Parameter Parcheesi</p> <p>Deadline: Friday, Feb 13th 2026 11:59pm</p>"},{"location":"hws/hw_2.html#background","title":"Background","text":"<p>This homework will ask you to to explore the impact of varying steps in the scRNA-seq analysis pipeline (as applied in HW1) on your estimate of cell type composition.</p> <p>Data</p> <p>Some data is the same as in HW1 but there are additional samples, too.</p>"},{"location":"hws/hw_2.html#data","title":"Data","text":""},{"location":"hws/hw_2.html#sample-1","title":"Sample 1","text":"<p>This is the same Sample 1 as we used in Lecture 4. Here are some more details:</p> <ul> <li>10k PBMCs from a Healthy Donor (v3 chemistry) Single Cell Gene Expression Dataset by Cell Ranger 3.0.0</li> <li>Peripheral blood mononuclear cells (PBMCs) from a healthy donor (the same cells were used to generate pbmc_1k_v2, pbmc_10k_v3). PBMCs are primary cells with relatively small amounts of RNA (~1pg RNA/cell).</li> <li>11,769 cells detected by CellRanger</li> <li>Sequenced on Illumina NovaSeq with approximately 54,000 reads per cell</li> <li>10X Genomics web page for this data</li> <li>pbmc_10k_v3_filtered_feature_bc_matrix.h5</li> </ul>"},{"location":"hws/hw_2.html#sample-2","title":"Sample 2","text":"<ul> <li>20k Human PBMCs, 3\u2019 HT v3.1, Chromium X</li> <li>Sourced from a healthy female donor</li> <li>23,837 cells</li> <li>35,000 reads per cell</li> <li>link to downlad</li> </ul>"},{"location":"hws/hw_2.html#sample-3","title":"Sample 3","text":"<ul> <li>Single Cell 3' v2</li> <li>2,909 cells</li> <li>115,061 reads per cell</li> <li>healthy donor</li> <li>download</li> </ul>"},{"location":"hws/hw_2.html#your-mission","title":"Your mission","text":"<p>Analyze the provided data to address the following questions:</p> <ol> <li>You are curious about some of the steps in the processing pipeline. While some seem reasonable, others seem highly arbitrary. How does altering the pipeline impact cell composition estimates? If so, in what ways? Only use Sample 1 data here.<ul> <li>Specifically, determine how each of the following changes (independently) impacts the estimated cell composition:<ul> <li>Don't filter cells based on MT content</li> <li>Don't filter cells based on total counts</li> <li>Don't normalize expression (so skip both <code>sc.pp.normalize_total()</code> and <code>sc.pp.log1p()</code></li> <li>Don't use PCs for kNN graph</li> <li>Test extreme values of n_pcs (e.g. n_pcs = 3, n_pcs = 50) when computing kNN graph</li> <li>Test extreme values of n_neighbors when computing kNN graph</li> <li>In what ways do these parameter adjustments alter the cell type gene signatures that you defined? </li> </ul> </li> <li>Deliverables:<ul> <li>Efficient visualisation of the cell type proportions across pipeline variant. Ideally the students will use their barplot function and pass it the adatas that result from annotation each of the outcomes of each variation to the pipeline.</li> <li>Written summary detailing effect of each change to the pipeline and an explanation (or speculation) for this result.</li> </ul> </li> </ul> </li> <li>To what extent do cell type compositions as estimated by scRNA-seq vary between samples? From your work on qustion 1 above, you have arrived at an opinion as to the best pipeline. (by 'pipeline' here we mean the set of processing steps and parameter choices that lead to final clustering results). Apply that to pipeline the Samples 2 and 3. Compare all three samples to the cell type proportion estimates from the literature (see HW1). Do you think that the variation that you observe in the scRNAseq-based estimates primarily reflect real biological variation, or do they reflect technical variation due to the vicissitudes of scRNAseq data generation and analysis? Justify your answer. <ul> <li>Deliverables:<ul> <li>Stacked barplots showing cell type compositions across samples and literature</li> <li>Written answer to questions about source of variation plus justification.</li> </ul> </li> </ul> </li> <li>Adult stem cells are typically not as numerous as their downstream progeny. This makes you wonder about the factors that impact scRNA-seq's sensitivty for detecting rare cell populations. Some factors include read depth (the number of UMIs per cell), size of the 'rare' population, the degree of distinctness of its transcriptome, and the analysis pipeline. Use existing Scanpy functions to explore the impact of read depth, population size, and analysis pipeline steps/parameters on the power to detect rare populations.<ul> <li>Deliverables:<ul> <li>Written report including the strategy (including what cell type(s) you treated as 'rare' population'), rationale, and general lessons derived from the analyses with relevant figures. What is the most important factor? What is the minimum population size (expressed as fraction of total number of cells in sample) that yields a detectable distinct cluster? How does this vary with read depth? Which, if any, of the pipeline parameters substantially impact power to detect a rare population?</li> </ul> </li> </ul> </li> </ol> <p>ALL SUBMISSIONS MUST...</p> <p>... include all code necessary to replicate the results, and must adhere to posted guidelines for code documentation, cogent written reports, and meaningful figures.</p>"},{"location":"hws/hw_3.html","title":"Homework 3","text":"<p>The Mandocellorian: This is the way (to cell typing)</p> <p>The overall goal of this homework is for you to gain a sophisticated understanding of these 'cell-typing' techniques and their relative merits in the context of cell fate engineering.</p> <p>Deadline: Monday, March 3rd 2025 11:59pm</p>"},{"location":"hws/hw_3.html#background","title":"Background","text":"<p>We have discussed different approaches for determining the identity of cells in scRNAseq data, including:</p> <ol> <li>Manual annotation by identifying known marker occurrence in clusters. Sometimes referred to as 'cluster-then-annotate'<sup>1</sup></li> <li>Integration with a reference data set for which cell annotations have been determined<sup>2</sup></li> <li>Applying a classifier that has been trained on a reference data set<sup>3</sup></li> </ol> <p>We have provided three scRNAseq data sets as described in the 'Data' section below. You will use these data and the 3 cell-typing approaches (i.e. 'cluster-then-annotate', BKKNN, and PySingleCellNet) to address the questions listed below. </p> <p>A bit of important background: Cell fate engineering (e.g. directed differentiation, direct conversion, etc) frequently generates populations of cells that exhibit mixed identities. Let's call these hybrids. Unlike the Tooth Fairy, Easter Bunny, or Santa Claus, hybrids are real (sorry if that was a spoiler). Hybrids are not doublets. And hybrids are not frequently observed in physiological contexts. In other words, we do not see them in scRNA-seq atlases from nominally normal tissues. </p>"},{"location":"hws/hw_3.html#question-1","title":"Question 1","text":"<p>How do manual annotation, classification, and integration compare in terms of accurately and sensitively predicting cell type identity? You should answer this by using each method to predict cell identities of the validation data. Select the best metric(s), compute these metrics for each method, and compare the results to answer the question.</p>"},{"location":"hws/hw_3.html#question-2","title":"Question 2","text":"<p>How do you think an ideal cell-typing method should handle hybrids? Discuss strategies for distinguishing true hybrids from doublets. The answer to this part does not require code or analysis. You just need to cogently describe your viewpoint. Keep in mind various use cases, such as application to cells from 'normal tissues', to cells from pathological contexts, and to cells derived via cell fate engineering.</p>"},{"location":"hws/hw_3.html#question-3","title":"Question 3","text":"<p>How well do the three cell-typing methods above perform when analyzing populations that include hybrids? To answer this question, you should</p> <ul> <li> <p>Generate synthetic hybrids by summing or averaging the expression profiles of cells of different identities from the validation data. You should generate various hybrid populations based on the cell types mixed, and the proportion of each. You could even explore which genes to use rather than randomly sampling from all genes.</p> </li> <li> <p>Combine your new synthetic data that includes hybrids with the validation data to make a new validation data set</p> </li> <li> <p>Predict cell identity of the new validation data using all three cell-typing methods</p> </li> <li> <p>Compute prediction metrics of all three cell-typing methods</p> </li> <li> <p>Please characterize the types of failures that are common and unique to each method and discuss how these failures could impact the analysis of real engineered cell</p> </li> </ul>"},{"location":"hws/hw_3.html#question-4","title":"Question 4","text":"<p>How does transplantation affect engineered pancreatic-like cells? More specifically:</p> <ul> <li> <p>Does the proportion of cells of uncertain identity change?</p> </li> <li> <p>Do the proportion of cell types differ between transplanted and non-transplanted cells? If so, do you think that these differences reflect real biology or could they just reflect sampling variation?</p> </li> <li> <p>How does transplantation affect transcriptional state of the cell types? To answer this ...</p> <ul> <li> <p>Use the cell-type predictions of the query data from your preferred cell-typing method</p> </li> <li> <p>For each cell type, perform differential gene expression analysis comparing transplanted vs non-transplanted cells of that cell type</p> <ul> <li> <p>What are the top 10 genes differentially expressed? Select a maximally informative and efficient visualization to show these genes and their expression patterns in the transplanted vs non-transplanted cells.</p> </li> <li> <p>What biological processes or pathways distinguish the transplanted and non-transplanted cells? You should answer this by performing enrichment analysis. As above, select a maximally informative and efficient visualization to illustrate these pathways.</p> </li> </ul> </li> <li> <p>Are there shared genes across pancreatic cell types that are commonly dysregulated in un-transplanted versus transplanted cells? </p> </li> </ul> </li> </ul>"},{"location":"hws/hw_3.html#extra-credit","title":"Extra-credit","text":"<p>Implement a function that computes a 'hybrid identity' score. Use this function to evaluate my assertion above that hybrid cells are not typically seen in normal contexts but are observed in engineered populations.</p>"},{"location":"hws/hw_3.html#data","title":"Data","text":"<p>The training and validation data sets are of human cadaver-derived pancreatic islet cells. The query data set is derived from pluripotent stem cells that have been engineered with the intention of producing insulin-producing beta cells. Some of the engineered cells were transplanted into mice and subsequently recovered to see how the in vivo environment impacted their identity. All scRNAseq data here was produced using the 10x platform. We have performed some data cleaning and trimming.</p>"},{"location":"hws/hw_3.html#training-data","title":"Training data<sup>4</sup>","text":"<ul> <li>Sorted human pancreatic islet cells from 3 donors</li> <li>raw counts</li> <li>cells QC-ed</li> <li>cell type annotation in .obs['cell_type']</li> <li>h5ad: adTrain_n110_CSCB_HW3.h5ad</li> </ul>"},{"location":"hws/hw_3.html#validation-data","title":"Validation data<sup>5</sup>","text":"<ul> <li>pancreatic islets from 4 donors</li> <li>raw counts</li> <li>cells QC-ed</li> <li>cell type annotation in .obs['cell_type']</li> <li>h5ad: adValidation_n300_CSCB_HW3.h5ad</li> </ul>"},{"location":"hws/hw_3.html#query-data","title":"Query data<sup>6</sup>","text":"<ul> <li>Directed differentiation of hESCs and iPSCs towards beta-like cells (6 stage differentiation)</li> <li>transplanted into mouse kidney capsule, then cells subsequently recovered</li> <li>cells QC-ed and contaminating mouse cells removed</li> <li>raw counts</li> <li>h5ad: adQuery_n2000_CSCB_HW3.h5ad</li> </ul>"},{"location":"hws/hw_3.html#marker-genes","title":"Marker genes","text":"<p>Here are solid marker genes of the major cell types that you can expect to encounter in this HW:</p> <pre><code>marker_genes_dict = {\n    'Acinar': ['PRSS2', 'REG1A'],\n    'Ductal': ['MMP7', 'KRT19'],\n    'Alpha': ['GCG', 'TTR', 'HIGD1A'],\n    'Beta': ['INS', 'IAPP', \"G6PC2\"],\n    'Delta': ['SST', 'RBP4', 'LEPR'],\n    'Gamma': ['PPY', 'ID2', \"GCNT3\"],\n    'Episilon': [\"GHRL\", \"NNMT\", \"APOH\"],\n    'Macrophage': ['IFI30', 'LAPTM5'],\n    'Mast': ['TPSB2', \"PTPRC\"],\n    'Stellate': ['COL1A2', 'COL6A2'],\n}\n</code></pre> <ol> <li> <p>Challenges in unsupervised clustering of single-cell RNA-seq data. Kiselev VY, Andrews TS, Hemberg M. Nat Rev Genet. 2019 May;20(5):273-282. doi: 10.1038/s41576-018-0088-9. PMID: 30617341 \u21a9</p> </li> <li> <p>Benchmarking atlas-level data integration in single-cell genomics. Luecken MD, B\u00fcttner M, Chaichoompu K, Danese A, Interlandi M, Mueller MF, Strobl DC, Zappia L, Dugas M, Colom\u00e9-Tatch\u00e9 M, Theis FJ. Nat Methods. 2022 Jan;19(1):41-50. doi: 10.1038/s41592-021-01336-8. Epub 2021 Dec 23. PMID: 34949812 \u21a9</p> </li> <li> <p>SingleCellNet: A Computational Tool to Classify Single Cell RNA-Seq Data Across Platforms and Across Species.Tan Y, Cahan P. Cell Syst. 2019 Aug 28;9(2):207-213.e2. doi: 10.1016/j.cels.2019.06.004. Epub 2019 Jul 31. PMID: 31377170 \u21a9</p> </li> <li> <p>van Gurp L, Fodoulian L, Oropeza D, Furuyama K, Bru-Tari E, Vu AN, Kaddis JS, Rodr\u00edguez I, Thorel F, Herrera PL. Generation of human islet cell type-specific identity genesets. Nat Commun. 2022 Apr 19;13(1):2020. doi: 10.1038/s41467-022-29588-8. PMID: 35440614 \u21a9</p> </li> <li> <p>Xin Y, Dominguez Gutierrez G, Okamoto H, Kim J, Lee AH, Adler C, Ni M, Yancopoulos GD, Murphy AJ, Gromada J. Pseudotime Ordering of Single Human \u03b2-Cells Reveals States of Insulin Production and Unfolded Protein Response. Diabetes. 2018 Sep;67(9):1783-1794. doi: 10.2337/db18-0365. Epub 2018 Jun 27. PMID: 29950394 \u21a9</p> </li> <li> <p>Augsornworawat P, Maxwell KG, Velazco-Cruz L, Millman JR. Single-Cell Transcriptome Profiling Reveals \u03b2 Cell Maturation in Stem Cell-Derived Islets after Transplantation. Cell Rep. 2020 Aug 25;32(8):108067. doi: 10.1016/j.celrep.2020.108067. Erratum in: Cell Rep. 2021 Mar 9;34(10):108850. PMID: 32846125 \u21a9</p> </li> </ol>"},{"location":"hws/hw_4.html","title":"Homework 4","text":"<p>Do you believe in fate, Neo?</p> <p>The overall goal of this homework is for you to gain experience in using trajectory inference (TI) and cell fate potency methods. </p> <p>Deadline: Tues, March 25th 2025 11:59pm</p>"},{"location":"hws/hw_4.html#background","title":"Background","text":"<p>Gastrulation marks the point during embryonic development at which some pluripotent epiblast cells commit to endoderm or mesoderm fates. Gastrulation initiates with posterior epiblast cells undergoing an epithelial-to-mesenchymal transition (EMT). These cells delaminate, ingress through, and ultimately migrate away from, the primitive streak.  The fate of many embryonic cells and their progeny are determined by where and when they undergo this process. In general, cells located anteriorly and that delaminte early during gastrulation (i.e. anterior primitive streak or APS) are fated to become definitive endoderm (DE) cells. Cells that delaminate later and are located more posteriorly are generally fated to become mesoderm lineages cells. </p> <p>We have provided a scRNA-seq data set from mouse embryos at the gastrula-stage as described in the Data section. In brief, it consists of epiblast cells, nascent mesoderm, anterior primitive streak, and visceral endoderm cells from E6.5 to E8.5 stage mouse embryos. Starting at E6.5, some epiblast cells will undergo the processes described above, and they will ultimately give rise to definitive endoderm or mesoderm cells. However, visceral endoderm cells are specified earlier in development and are not derived from the epiblast cells present in this data set. </p> <p>TI pitfalls</p> <ol> <li>TI analysis typically assumes that the input cells are developmentally interlinked. Even when data violate this assumption, most TI methods will still try to link them purely on the basis of transcriptional similarity. This is bad. </li> <li>TI analysis also typically requires the user to input a start point or 'root' of a trajectory. </li> </ol>"},{"location":"hws/hw_4.html#task-1-perform-cell-typing","title":"Task 1: Perform cell-typing","text":"<p>Before you can reliably appy TI to this data, you must perform cell-typing to (A) identify and exclude VE cells, and (B) to identify the epiblast, mesoderm, and anterior primitive streak cells. This will allow you to suggest a root for the TI analysis. To help you with this part, here are some well-established marker genes:</p> <ul> <li>Epiblast: Utf1, Slc7a3, Pou3f1</li> <li>Mesoderm: Mesp1, Fgf3, Snai1</li> <li>Anterior primitive streak: Foxa2, Gsc, Sox17</li> <li>Visceral endoderm: Use your highly refined literature-mining skills to find these. Please select 3-5 genes that are reported to be VE-specific from the literature. You must cite the primary papers in which each gene has been demonstrated to be a marker of murine VE. </li> </ul> <p>You will know that you are done with Task 1 when you have clearly annotated each cell and have excluded the VE cells from the input data.</p>"},{"location":"hws/hw_4.html#task-2-infer-trajectory-and-pseudotime","title":"Task 2: Infer trajectory and pseudotime","text":"<p>Use scFates to reconstruct a trajectory that connects epiblast to APS, and epiblast to mesoderm. Then predict the pseudotime for each cell. To receive full credit for Part 2, you must infer the tree, justify your parameter selections, and visualize the resulting tree with labeled branches and milestones, and visualize pseudotime.</p>"},{"location":"hws/hw_4.html#task-3-discover-regulators-of-differentiation","title":"Task 3: Discover regulators of differentiation","text":"<p>What transcription factors might promote the transition from epiblast to mesoderm or to endoderm? Develop a critiera for ranking transcription factors (TFs) accoring to their predicted importance or influence on differentiation. This could be simply the p-value from scFates's association test, or you might conceive of other criteria. Use this criteria to select the top X TFs (where X &gt;4) that specifically promotes mesoderm or endoderm differentiation from the epiblast. Mine the literature around each of your candidate TFs to assess the extent to which your criteria and application of scFates recovered bona fide regulators of gastrulation. Your answer should cite the primary papers that you use here. You must have two sets of X candidates TFs, one for mesoderm differentiation, and one for endoderm differentiation.</p>"},{"location":"hws/hw_4.html#task-4-discover-regulators-of-pluripotency","title":"Task 4: Discover regulators of pluripotency","text":"<p>What transcription factors potentially oppose epiblast cells from differentiation, and thus promote pluripotency? Perform the same kind of analysis as you did for Task 3 here, but now apply it to find TFs that inhibit epiblast differentaition.</p>"},{"location":"hws/hw_4.html#task-5-compare-cytotrace-to-pseudotime","title":"Task 5: Compare Cytotrace to pseudotime","text":"<p>To what extent do Cytotrace and scFtes pseudotime agree? Compute Cytotrace's cell potency on this data and compute its correlation with scFates pseudotime. Do they agree? If not, perform further analyses to explore why this might be the case. </p>"},{"location":"hws/hw_4.html#data","title":"Data","text":""},{"location":"hws/hw_4.html#scrna-seq-data-of-mouse-gastrulation-embryonic-cells","title":"scRNA-seq data of mouse gastrulation embryonic cells","text":"<ul> <li>h5ad: adHW3_2024.h5ad</li> <li>Includes only VE, APS, nascent mesoderm, and epiblast cells</li> <li>We have already performed cell quality control. You will want to perform gene quality control and standard downstream processing.</li> <li>There should be roughly equivalent numbers of cells per population.</li> </ul>"},{"location":"hws/hw_4.html#list-of-mouse-transcription-factors","title":"List of mouse transcription factors:","text":"<ul> <li>allTFs_mm_aertslab_011924.txt</li> </ul>"},{"location":"hws/hw_5.html","title":"Homework 5","text":"<p>Warning</p> <p>The goal of this homework is for you to gain experience in using gene regulatory network inference methods and to apply them to simulate cell state dynamics.</p> <p>Deadline: Thurs, April 3rd 2025 11:59pm</p>"},{"location":"hws/hw_5.html#background","title":"Background","text":"<p>We have discussed why groups are attempting to engineer cell fate, and we have discussed various experimental approaches, namely directed differentiation of pluripotent stem cells and direct conversion from one somatic cell type into another. We have also seen how time-consuming and resource-intensive it is to try to empirically devise experimental protocols to produce a given cell type. Several computational tools have been invented to amerliorate this problem. In general, these methods tend to leverage expression data and regulatory networks in an attempt to prioritize targeting the most impactful nodes. The overall goal of this homework is for you to gain some experience with computational methods for cell fate engineering. This will entail reversen engineering gene regulatory networks, and using them to simulate the effect of over-expressing and knocking down transcription factors on fate outcomes. You will also build on what you have learned about trajectory inference and cell typing to complete this homework.</p> <p>Your mission is to predict a minimal set of perturbations to apply to mouse embryonic stem cells so that they will differentiate to a) nascent mesoderm, and to b) anterior primitive streak/nascent endoderm. To achieve this, you will be asked to reverse engineer the GRN that underpins the differentiation of epiblast to mesoderm or APS/endoderm, and then use this GRN to simulate the fate outcome from perturbing TFs that you select. We have provied a scRNA-seq data set (specifications in Data section) that you are now familar with: it is the mouse embryo data set of epiblast cells, nascent mesoderm, and anterior primitive streak cells. This is the data set that you should use to infer the GRN. Note that we have excluded visceral endoderm cells from this data set. We have also provided a scRNA-seq data set of mouse embryonic stem cells in an undifferentiated state, which should be used to set the initial state of the cells for your simulations.</p>"},{"location":"hws/hw_5.html#task-1-trajectory-inference","title":"Task 1: trajectory inference","text":"<p>After loading the gastrulation data, use scFates to reconstruct a trajectory tree that connects epiblast to APS, and epiblast to mesoderm, and also use scFates to predict a pseudotime for each cell. If you did well on HW4 part 2, this part should be super easy for you.</p>"},{"location":"hws/hw_5.html#task-2-tf-selection","title":"Task 2: TF selection","text":"<p>Select 10-15 TFs to use for GRN reconstruction. You can choose to use functions in scFates to identify these TFs, or another approach such as differential gene expression, or another method of your choicee. Describe how you identified these TFs and justify why your choice is a good one.</p>"},{"location":"hws/hw_5.html#task-3-reconstruct-gene-regulatory-network","title":"Task 3: Reconstruct gene regulatory network","text":"<p>Use oneSC to infer the GRN assoicated with the gastrulation data set. You need to limit your analysis to TFs identified in Task 2, and ensure that the state graph is consistent with what you know about development. If oneSC's state graph conflicts with this, then you should manually define this.</p>"},{"location":"hws/hw_5.html#task-4-find-minimal-tf-set","title":"Task 4: Find minimal TF set","text":"<p>Devise a strategy to predict a minimal set of TFs that, when perturbed in mouse embryonic stem cells, will yield the highest proportion of APS cells. Your method should be based on the GRN you inferred in Task 3, and optionally on the scRNA-seq data provided below. Use the method to generate a set of candidate TFs and then check how your prediction performs by simulating the impact of the perturbation using oneSC. You should compare the performance of your method to a judiciously chosen baseline method.</p> <p>Now apply your method to predict TFs to perturb in mESCs to yield the highest proportion of nascent mesoderm cells. Evaluate your predictions as above (i.e. perform simulations with your perturbations, qunatify cell type numbers, and compare to results using a baseline method). </p> <p>Did your method outperform the baseline method? Discuss why or why not.</p>"},{"location":"hws/hw_5.html#data","title":"Data","text":""},{"location":"hws/hw_5.html#list-of-mouse-transcription-factors","title":"List of mouse transcription factors:","text":"<ul> <li>allTFs_mm_aertslab_011924.txt</li> </ul>"},{"location":"hws/hw_5.html#scrna-seq-data-of-mouse-gastrulation-embryonic-cells","title":"scRNA-seq data of mouse gastrulation embryonic cells","text":"<ul> <li>h5ad: adHW5_EpiMesoAPS_n500.h5ad</li> <li>Includes only APS, nascent mesoderm, and epiblast cells</li> <li>We have already performed cell quality control. You will want to perform gene quality control and standard downstream processing.</li> </ul>"},{"location":"hws/hw_5.html#scrna-seq-data-of-pluripotent-mouse-embryonic-stem-cells","title":"scRNA-seq data of pluripotent mouse embryonic stem cells","text":"<ul> <li>h5ad: adHW5_mESC.h5ad</li> </ul>"},{"location":"hws/hw_example.html","title":"Example homework assignment","text":"<p>Warning</p> <p>This is not a real assignment for CSCB! It's just a realistic example to demonstrate the style guide.</p>"},{"location":"hws/hw_example.html#goal","title":"Goal","text":"<p>The goal of this assignment is to give you some experience in data wrangling and quality control of scRNA-seq data.</p>"},{"location":"hws/hw_example.html#due-date-jan-1st-2001","title":"Due date: Jan 1st, 2001.","text":""},{"location":"hws/hw_example.html#data","title":"Data","text":"<p>In this assignment, you will perform a few initial steps in the analysis of a dataset from a tech-dev paper showing off an unusual combination of cababilities. The paper includes several large experiments with genetic perturbations followed by a scRNA-seq readout (Replogle et al 2020). These assays are applied to mostly the K562 leukemia cell line.  We'll focus on just the CRISPRa multiplexing experiment, which does gene overexpression followed by scRNA. </p>"},{"location":"hws/hw_example.html#your-mission","title":"Your mission","text":""},{"location":"hws/hw_example.html#task-1","title":"Task 1","text":"<ul> <li>Tidy the dataset so that it fits in an AnnData object.</li> <li>For each overexpressed gene, how many cells are measured?</li> </ul>"},{"location":"hws/hw_example.html#task-2","title":"Task 2","text":"<ul> <li>Compute typical scRNA quality metrics and filter out genes and cells as discussed in class.</li> <li>As you apply each filter, print the number of cells remaining so that anyone following your code can see which filtering steps are most impactful.</li> </ul>"},{"location":"hws/hw_example.html#task-3","title":"Task 3","text":"<ul> <li>Write code to visualize the data using scanpy.</li> <li>Run the code and describe the results.</li> </ul>"},{"location":"hws/hw_example.html#resources","title":"Resources","text":"<p>You may use the provided code (<code>ingestion.py</code>) to convert gene names from Ensembl gene id's (example: <code>ENSG00000109101</code>) to more readable Entrez gene symbols (example: <code>Foxn1</code>).</p>"},{"location":"hws/hw_example.html#deliverables","title":"Deliverables","text":"<p>A Jupyter notebook that contains documented code achieving Tasks 1, 2, and 3. For an example submission, [['HWEX Done']].</p>"},{"location":"lectures/index.html","title":"Schedule","text":"<p>There are four chapters, or broad themes, that we will cover in this course:</p> <ol> <li>single cell genomics</li> <li>cell typing and data integration</li> <li>trajectory inference and differentiation potential</li> <li>gene regulatory networks</li> </ol> <p>Access to lecture videos is available to current students</p> <p>The lecture videos below can only be viewed after authenticating via Hopkin's SSO</p> Lecture Date Chapter Topic link to video lecture slides 1 01-20-26 1 Course introduction intro to course slides 2 01-22-26 1 scRNAseq data generation dropseq slides <pre><code>             |\n</code></pre> <p>| 2      | 01-23-25 | Single cell biology | game show video | NA | | 3      | 01-28-25 | scRNAseq data generation | dropseq | slides | | 4      | 01-30-25 | Scanpy tutorial | scanpy analysis | notebook | | 5      | 02-04-25 | Data integration and cell typing | hcl,scmap,bbknn,scn | slides| | 6      | 02-06-25 | Integration &amp; typing tutorial | cell typing and integration | notebook | | 7      | 02-11-25 | Trajectory inference and pseudotime | theory | TI slides| | 8      | 02-13-25 | TI tutorial | video | notebook | | 9     | 02-18-25 | Fate potency and stemness (pre-recorded) | video | slides | | 10     | 02-20-25 | How-to infer fate potency (pre-recorded) | video | notebook | | 11     | 02-25-25 | Gene regulatory networks  | video | slides| | 12     | 02-27-25 | scGRN | video | slides | | 13     | 03-04-25 | Computational approaches to cell fate engineering | video | slides | | 14      | 03-06-25 | Simulating single cell trajectories | video | slides | | 15      | 03-11-25 | Intro to ST and Cell-to-cell communications | video | slides | | 16      | 03-13-25 | Machine Learning for Spatial and Network Biology (In Malone 228; Uhtsav Chitra) | - | -| | --      | 03-18-25 | Spring break | - | - | | --      | 03-20-25 | Spring break | - | - | | 17      | 03-25-25 | Early development and signaling| video | slides | | 18      | 03-27-25 | Till and McCulloch | video | slides | | 19      | 04-01-25 | Final project overview | video | slides | | 20      | 04-03-25 | Epigenomics | video | slides | | 21      | 04-08-25 | Multiomics | video | slides | | 22      | 04-15-25 | Chromatin accessibility &amp; ChIP-seq analysis | video | slides | | 23A      | 04-17-25 | RNA Velocity | video | slides | | 23B      | 04-17-25 | Cell modeling | video | slides | | 24      | 04-22-25 | Controversies in the stem cell world | - | - | | 25      | 04-24-25 | Clinical trials with stem cells | - | - |</p>"},{"location":"lectures/topics.html","title":"Lectures","text":"<p>The topics that we cover can be broadly split into three categories: stem cell biology, single cell data generation platforms, and computational methods for analyses of these data.</p> <p>!!warning \"Acces to lecture videos is available to current students\"</p> <pre><code>The lecture videos below can only be viewed after authenticating via [Hopkin's SSO](https://my.jh.edu/html/myjh.html)\n</code></pre> Number Date Topic link to video slides 1 01-21-25 Course introduction video topics/intro.md 2 01-23-25 Single cell biology [topics/"},{"location":"lectures/topics.html#stem-cell-biology","title":"(Stem) cell biology","text":"<p>We will cover some basic cell biology and then discuss the main areas of focus in stem cell biology.</p> <ul> <li>Stem cell biology basics</li> <li>Cell identity</li> <li>Development and differentiation</li> <li>Cell fate engineering</li> <li>Gene regulatory networks</li> <li>Cell-to-cell communication</li> <li>Controversies</li> </ul>"},{"location":"lectures/topics.html#single-cell-data-generation-platforms","title":"Single cell data generation platforms","text":"<p>The course will mainly use scRNA-seq data but we will also discuss other data modalities.</p> <ul> <li>Single cell RNA-seq</li> <li>Single cell ATAC-seq</li> <li>Spatial transcriptomics</li> <li>Lineage tracing</li> </ul>"},{"location":"lectures/topics.html#computational-methods","title":"Computational methods","text":"<p>In addition to the basic standard analysis pipelines, we will also cover more advanced methods.</p> <ul> <li>Integration and cell typing</li> <li>Trajectory inference</li> <li>Fate potential</li> <li>Forecasting and simulations</li> </ul>"},{"location":"notebooks/index.html","title":"Topics","text":"<p>The topics covered can be broadly split into three categories: stem cell biology, single cell data generation platforms, and computational methods for analyses of these data.</p>"},{"location":"notebooks/index.html#stem-cell-biology","title":"(Stem) cell biology","text":"<p>We will cover some basic cell biology and then discuss the main areas of focus in stem cell biology.</p> <ul> <li>Stem cell biology basics</li> <li>Cell identity</li> <li>Development and differentiation</li> <li>Cell fate engineering</li> <li>Gene regulatory networks</li> <li>Cell-to-cell communication</li> <li>Controversies</li> </ul>"},{"location":"notebooks/index.html#single-cell-data-generation-platforms","title":"Single cell data generation platforms","text":"<p>The course will mainly use scRNA-seq data but we will also discuss other data modalities.</p> <ul> <li>Single cell RNA-seq</li> <li>Single cell ATAC-seq</li> <li>Spatial transcriptomics</li> <li>Lineage tracing</li> </ul>"},{"location":"notebooks/index.html#computational-methods","title":"Computational methods","text":"<p>In addition to the basic standard analysis pipelines, we will also cover more advanced methods.</p> <ul> <li>Integration and cell typing</li> <li>Trajectory inference</li> <li>Fate potential</li> <li>Forecasting and simulations</li> </ul>"},{"location":"notebooks/colab.html","title":"Colab","text":""},{"location":"notebooks/colab.html#google-colab","title":"Google Colab\u00b6","text":"<p>You may already know about Jupyter and how to use it. For this course, students are encouraged to use Google's Colab cloud platform to perform analysis of scRNA-seq data. This platform allows users to run analyses on the cloud for free using Jupyter. But, you need a Google account to do so.</p> <ol> <li><p>Please create a Google account, if you do not already have one.</p> </li> <li><p>Log in to your Google account, if you are not already logged in.</p> </li> <li><p>Test your access to Google Colab. You should see a screen like the following:</p> </li> </ol> Screenshot of Colab diaglog box <ol> <li><p>Create a new notebook. If you see the dialog shown above, then click 'create notebook'. You can also create a notebook using the Menu at the top of the page: File -&gt; New notebook in Drive. Either will result in the launching of a new Jupyter notebook.</p> </li> <li><p>The End. You are done and can close the browser page on Colab.</p> </li> </ol>"},{"location":"notebooks/hwex_done.html","title":"HWEX Done","text":"<p>This is not a real assignment for CSCB! It's just a realistic example to demonstrate the style guide.</p> In\u00a0[7]: Copied! <pre>import warnings\nwarnings.filterwarnings('ignore')\nimport os\nimport shutil\nimport importlib\nimport matplotlib.colors as colors\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nimport scanpy as sc\nimport seaborn as sns\nimport anndata\nfrom IPython.display import display, HTML\n\n# Import the code provided with the assignment\nimport importlib\nimport sys\nsys.path.append(\"setup\")\nimport ingestion\nimportlib.reload(ingestion)\n\n# visualization settings\n%matplotlib inline\nplt.rcParams['figure.figsize'] = [6, 4.5]\nplt.rcParams[\"savefig.dpi\"] = 300\n\n# Some useful gene annotation files\ngeneAnnotationPath = \"../accessory_data/gencode.v35.annotation.gtf.gz\"       # Downloaded from https://www.gencodegenes.org/human/release_35.html\ncellcycleGenePath = \"../accessory_data/regev_lab_cell_cycle_genes.txt\"\n</pre> import warnings warnings.filterwarnings('ignore') import os import shutil import importlib import matplotlib.colors as colors import matplotlib.pyplot as plt import numpy as np import pandas as pd import scanpy as sc import seaborn as sns import anndata from IPython.display import display, HTML  # Import the code provided with the assignment import importlib import sys sys.path.append(\"setup\") import ingestion importlib.reload(ingestion)  # visualization settings %matplotlib inline plt.rcParams['figure.figsize'] = [6, 4.5] plt.rcParams[\"savefig.dpi\"] = 300  # Some useful gene annotation files geneAnnotationPath = \"../accessory_data/gencode.v35.annotation.gtf.gz\"       # Downloaded from https://www.gencodegenes.org/human/release_35.html cellcycleGenePath = \"../accessory_data/regev_lab_cell_cycle_genes.txt\"   In\u00a0[8]: Copied! <pre># Reading from .mtx is slow, so we memoize to h5ad. \ndataset_name = \"replogle\"\nif not os.path.exists(f\"not_ready/{dataset_name}/GSM4367986_exp8/overall.h5ad.gzip\"):\n    expression_quantified = sc.read_10x_mtx(f\"not_ready/{dataset_name}/GSM4367986_exp8/\")\n    expression_quantified.write_h5ad(f\"not_ready/{dataset_name}/GSM4367986_exp8/overall.h5ad.gzip\", compression=\"gzip\")\nelse:\n    expression_quantified = sc.read_h5ad(f\"not_ready/{dataset_name}/GSM4367986_exp8/overall.h5ad.gzip\")\n</pre> # Reading from .mtx is slow, so we memoize to h5ad.  dataset_name = \"replogle\" if not os.path.exists(f\"not_ready/{dataset_name}/GSM4367986_exp8/overall.h5ad.gzip\"):     expression_quantified = sc.read_10x_mtx(f\"not_ready/{dataset_name}/GSM4367986_exp8/\")     expression_quantified.write_h5ad(f\"not_ready/{dataset_name}/GSM4367986_exp8/overall.h5ad.gzip\", compression=\"gzip\") else:     expression_quantified = sc.read_h5ad(f\"not_ready/{dataset_name}/GSM4367986_exp8/overall.h5ad.gzip\") In\u00a0[9]: Copied! <pre># Typical reshaping of data and computation of QC metrics\nsc.pp.calculate_qc_metrics(expression_quantified, inplace = True)\ncell_metadata = pd.read_csv(f\"not_ready/{dataset_name}/GSM4367986_exp8/cell_identities.csv.gz\")\ncell_metadata.index = cell_metadata[\"cell_barcode\"]\ncell_metadata[\"target_symbol\"] = ingestion.convert_ens_to_symbol(\n    cell_metadata[\"target\"], \n    gtf=geneAnnotationPath, \n    strip_version = True)\nexpression_quantified.obs = pd.merge(expression_quantified.obs,\n                                     cell_metadata, \n                                     how = \"left\", \n                                     left_index = True, \n                                     right_index = True)\n\nexpression_quantified.obs[\"has_guide_annotations\"] = pd.notnull(expression_quantified.obs[\"coverage\"]).astype(\"int\")\nexpression_quantified.obs[\"good_coverage\"] = expression_quantified.obs[\"good_coverage\"].astype(\"str\")\nexpression_quantified.raw = expression_quantified.copy()\n</pre> # Typical reshaping of data and computation of QC metrics sc.pp.calculate_qc_metrics(expression_quantified, inplace = True) cell_metadata = pd.read_csv(f\"not_ready/{dataset_name}/GSM4367986_exp8/cell_identities.csv.gz\") cell_metadata.index = cell_metadata[\"cell_barcode\"] cell_metadata[\"target_symbol\"] = ingestion.convert_ens_to_symbol(     cell_metadata[\"target\"],      gtf=geneAnnotationPath,      strip_version = True) expression_quantified.obs = pd.merge(expression_quantified.obs,                                      cell_metadata,                                       how = \"left\",                                       left_index = True,                                       right_index = True)  expression_quantified.obs[\"has_guide_annotations\"] = pd.notnull(expression_quantified.obs[\"coverage\"]).astype(\"int\") expression_quantified.obs[\"good_coverage\"] = expression_quantified.obs[\"good_coverage\"].astype(\"str\") expression_quantified.raw = expression_quantified.copy() In\u00a0[10]: Copied! <pre>expression_quantified = expression_quantified[~expression_quantified.obs.target_symbol.isna(), :]\n</pre> expression_quantified = expression_quantified[~expression_quantified.obs.target_symbol.isna(), :] In\u00a0[11]: Copied! <pre>expression_quantified.var_names = ingestion.convert_ens_to_symbol(\n    expression_quantified.var_names, \n    gtf=geneAnnotationPath, \n)\ndisplay(expression_quantified.var.head())\ndisplay(expression_quantified.var_names[0:5])\n</pre> expression_quantified.var_names = ingestion.convert_ens_to_symbol(     expression_quantified.var_names,      gtf=geneAnnotationPath,  ) display(expression_quantified.var.head()) display(expression_quantified.var_names[0:5]) gene_ids feature_types n_cells_by_counts mean_counts log1p_mean_counts pct_dropout_by_counts total_counts log1p_total_counts RP11-34P13.3 ENSG00000243485 Gene Expression 14 0.000127 0.000127 99.987326 14.0 2.708050 FAM138A ENSG00000237613 Gene Expression 0 0.000000 0.000000 100.000000 0.0 0.000000 OR4F5 ENSG00000186092 Gene Expression 0 0.000000 0.000000 100.000000 0.0 0.000000 RP11-34P13.7 ENSG00000238009 Gene Expression 343 0.003105 0.003100 99.689486 343.0 5.840641 RP11-34P13.8 ENSG00000239945 Gene Expression 55 0.000498 0.000498 99.950209 55.0 4.025352 <pre>Index(['RP11-34P13.3', 'FAM138A', 'OR4F5', 'RP11-34P13.7', 'RP11-34P13.8'], dtype='object')</pre> In\u00a0[13]: Copied! <pre>n_cells_per_target = expression_quantified.obs.groupby(\"target_symbol\")[[\"cell_barcode\"]].count().sort_values(\"cell_barcode\")\nn_cells_per_target.columns = [\"n_cells\"]\nn_cells_per_target.reset_index(inplace = True)\ndisplay(n_cells_per_target)\nplt.rcParams['figure.figsize'] = [6, 9]\n</pre> n_cells_per_target = expression_quantified.obs.groupby(\"target_symbol\")[[\"cell_barcode\"]].count().sort_values(\"cell_barcode\") n_cells_per_target.columns = [\"n_cells\"] n_cells_per_target.reset_index(inplace = True) display(n_cells_per_target) plt.rcParams['figure.figsize'] = [6, 9] target_symbol n_cells 0 CEBPB 212 1 LHX4 238 2 PTPN1 284 3 CDKN1B 303 4 TBX21 315 ... ... ... 59 TTC6 1513 60 RPL30 1712 61 MTOR 1735 62 MAP2K3 1861 63 Non-Targeting 5126 <p>64 rows \u00d7 2 columns</p> In\u00a0[14]: Copied! <pre>sc.pl.highest_expr_genes(expression_quantified, n_top=30, palette=\"Blues\", width=.3)\n</pre> sc.pl.highest_expr_genes(expression_quantified, n_top=30, palette=\"Blues\", width=.3) In\u00a0[15]: Copied! <pre>expression_quantified.var['mt']   = expression_quantified.var_names.str.startswith((\"MT-\"))\nexpression_quantified.var['ribo'] = expression_quantified.var_names.str.startswith((\"RPS\",\"RPL\"))\nexpression_quantified.var['mt'].sum(), expression_quantified.var['ribo'].sum(),\n</pre> expression_quantified.var['mt']   = expression_quantified.var_names.str.startswith((\"MT-\")) expression_quantified.var['ribo'] = expression_quantified.var_names.str.startswith((\"RPS\",\"RPL\")) expression_quantified.var['mt'].sum(), expression_quantified.var['ribo'].sum(),  Out[15]: <pre>(13, 103)</pre> In\u00a0[16]: Copied! <pre>sc.pp.calculate_qc_metrics(expression_quantified, qc_vars=['ribo', 'mt'], percent_top=None, log1p=False, inplace=True)\n</pre> sc.pp.calculate_qc_metrics(expression_quantified, qc_vars=['ribo', 'mt'], percent_top=None, log1p=False, inplace=True) In\u00a0[17]: Copied! <pre>axs = sc.pl.violin(expression_quantified, ['n_genes_by_counts', \n                                           'total_counts', \n                                           'pct_counts_mt', \n                                           'pct_counts_ribo', \n                                           'pct_counts_in_top_50_genes'], \n                   jitter=0.5, multi_panel=True)\n</pre> axs = sc.pl.violin(expression_quantified, ['n_genes_by_counts',                                             'total_counts',                                             'pct_counts_mt',                                             'pct_counts_ribo',                                             'pct_counts_in_top_50_genes'],                     jitter=0.5, multi_panel=True) In\u00a0[18]: Copied! <pre>fig, ax = plt.subplots(1,1,figsize=(2,2))\nsc.pl.scatter(expression_quantified, x='total_counts', y='n_genes_by_counts', ax=ax)\n</pre> fig, ax = plt.subplots(1,1,figsize=(2,2)) sc.pl.scatter(expression_quantified, x='total_counts', y='n_genes_by_counts', ax=ax) In\u00a0[19]: Copied! <pre>print(\"Number of cells: \", expression_quantified.n_obs)\n\n# figure out the total counts == 95 percentile\nthresh = np.percentile(expression_quantified.obs['total_counts'], 99)\nprint(\"99th percentile: \", thresh)\n</pre> print(\"Number of cells: \", expression_quantified.n_obs)  # figure out the total counts == 95 percentile thresh = np.percentile(expression_quantified.obs['total_counts'], 99) print(\"99th percentile: \", thresh) <pre>Number of cells:  60725\n99th percentile:  17000.280000000006\n</pre> In\u00a0[20]: Copied! <pre>expression_quantified = expression_quantified[expression_quantified.obs['total_counts'] &lt; thresh, :].copy()\nprint(\"Number of cells: \", expression_quantified.n_obs)\n</pre> expression_quantified = expression_quantified[expression_quantified.obs['total_counts'] &lt; thresh, :].copy() print(\"Number of cells: \", expression_quantified.n_obs) <pre>Number of cells:  60117\n</pre> In\u00a0[21]: Copied! <pre>expression_quantified = expression_quantified[expression_quantified.obs[\"total_counts\"] &gt;= 2000, :].copy()\nprint(\"Number of cells: \", expression_quantified.n_obs)\n</pre> expression_quantified = expression_quantified[expression_quantified.obs[\"total_counts\"] &gt;= 2000, :].copy() print(\"Number of cells: \", expression_quantified.n_obs) <pre>Number of cells:  58809\n</pre> In\u00a0[22]: Copied! <pre>expression_quantified = expression_quantified[expression_quantified.obs[\"pct_counts_in_top_50_genes\"] &lt;= 40, :].copy()\nprint(\"Number of cells: \", expression_quantified.n_obs)\n</pre> expression_quantified = expression_quantified[expression_quantified.obs[\"pct_counts_in_top_50_genes\"] &lt;= 40, :].copy() print(\"Number of cells: \", expression_quantified.n_obs) <pre>Number of cells:  58589\n</pre> In\u00a0[23]: Copied! <pre># filter for % mt\nexpression_quantified = expression_quantified[expression_quantified.obs['pct_counts_mt'] &lt; 20, :].copy()\nprint(\"Number of cells: \", expression_quantified.n_obs)\n</pre> # filter for % mt expression_quantified = expression_quantified[expression_quantified.obs['pct_counts_mt'] &lt; 20, :].copy() print(\"Number of cells: \", expression_quantified.n_obs) <pre>Number of cells:  58484\n</pre> In\u00a0[24]: Copied! <pre># filter for % ribo &gt; 50%\nexpression_quantified = expression_quantified[expression_quantified.obs['pct_counts_ribo'] &lt; 30, :].copy()\nprint(\"Number of cells: \", expression_quantified.n_obs)\n</pre> # filter for % ribo &gt; 50% expression_quantified = expression_quantified[expression_quantified.obs['pct_counts_ribo'] &lt; 30, :].copy() print(\"Number of cells: \", expression_quantified.n_obs) <pre>Number of cells:  58415\n</pre> In\u00a0[25]: Copied! <pre>\"\"\" To verify the outcome of filtering cells \"\"\"\nsc.pp.calculate_qc_metrics(expression_quantified, qc_vars=['ribo', 'mt'], percent_top=None, log1p=False, inplace=True)\n</pre> \"\"\" To verify the outcome of filtering cells \"\"\" sc.pp.calculate_qc_metrics(expression_quantified, qc_vars=['ribo', 'mt'], percent_top=None, log1p=False, inplace=True) In\u00a0[26]: Copied! <pre>axs = sc.pl.violin(expression_quantified, ['n_genes_by_counts', \n                                           'total_counts', \n                                           'pct_counts_mt', \n                                           'pct_counts_ribo', \n                                           'pct_counts_in_top_50_genes'], \n                   jitter=0.4, multi_panel=True)\n</pre> axs = sc.pl.violin(expression_quantified, ['n_genes_by_counts',                                             'total_counts',                                             'pct_counts_mt',                                             'pct_counts_ribo',                                             'pct_counts_in_top_50_genes'],                     jitter=0.4, multi_panel=True) In\u00a0[27]: Copied! <pre>fig, ax = plt.subplots(1,1,figsize=(2,2))\nsc.pl.scatter(expression_quantified, x='total_counts', y='n_genes_by_counts', ax=ax)\n</pre> fig, ax = plt.subplots(1,1,figsize=(2,2)) sc.pl.scatter(expression_quantified, x='total_counts', y='n_genes_by_counts', ax=ax) In\u00a0[28]: Copied! <pre>print(\"Number of genes: \", expression_quantified.n_vars)\ngThresh = 10\n\nsc.pp.filter_genes(expression_quantified, min_cells=gThresh)\nprint(\"Number of genes: \", expression_quantified.n_vars)\n</pre> print(\"Number of genes: \", expression_quantified.n_vars) gThresh = 10  sc.pp.filter_genes(expression_quantified, min_cells=gThresh) print(\"Number of genes: \", expression_quantified.n_vars) <pre>Number of genes:  33694\nNumber of genes:  18811\n</pre> In\u00a0[30]: Copied! <pre>mito_genes = expression_quantified.var_names.str.startswith('MT-')\nribo_genes = expression_quantified.var_names.str.startswith((\"RPL\",\"RPS\"))\nmalat_gene = expression_quantified.var_names.str.startswith(\"MALAT1\")\n</pre> mito_genes = expression_quantified.var_names.str.startswith('MT-') ribo_genes = expression_quantified.var_names.str.startswith((\"RPL\",\"RPS\")) malat_gene = expression_quantified.var_names.str.startswith(\"MALAT1\") In\u00a0[32]: Copied! <pre>remove = np.add(mito_genes, ribo_genes)\nremove = np.add(remove, malat_gene)\nkeep = np.invert(remove)\nexpression_quantified = expression_quantified[:,keep].copy()\nprint(\"Number of genes: \", expression_quantified.n_vars)\n</pre> remove = np.add(mito_genes, ribo_genes) remove = np.add(remove, malat_gene) keep = np.invert(remove) expression_quantified = expression_quantified[:,keep].copy() print(\"Number of genes: \", expression_quantified.n_vars) <pre>Number of genes:  18700\n</pre> In\u00a0[33]: Copied! <pre>[idx for idx, n in enumerate(expression_quantified.var.index) if n.upper() == 'GAPDH']\n</pre> [idx for idx, n in enumerate(expression_quantified.var.index) if n.upper() == 'GAPDH'] Out[33]: <pre>[11180]</pre> In\u00a0[34]: Copied! <pre>sc.pl.highest_expr_genes(expression_quantified, n_top=20, palette=\"Blues\", width=.3)\n</pre> sc.pl.highest_expr_genes(expression_quantified, n_top=20, palette=\"Blues\", width=.3) In\u00a0[35]: Copied! <pre>\"\"\" To verify the outcome of filtering genes \"\"\"\nsc.pp.calculate_qc_metrics(expression_quantified, qc_vars=['ribo', 'mt'], percent_top=None, log1p=False, inplace=True)\n</pre> \"\"\" To verify the outcome of filtering genes \"\"\" sc.pp.calculate_qc_metrics(expression_quantified, qc_vars=['ribo', 'mt'], percent_top=None, log1p=False, inplace=True) In\u00a0[36]: Copied! <pre>axs = sc.pl.violin(expression_quantified, ['n_genes_by_counts', \n                                           'total_counts', \n                                           'pct_counts_mt', \n                                           'pct_counts_ribo', \n                                           'pct_counts_in_top_50_genes'], \n                   jitter=0.4, multi_panel=True)\n</pre> axs = sc.pl.violin(expression_quantified, ['n_genes_by_counts',                                             'total_counts',                                             'pct_counts_mt',                                             'pct_counts_ribo',                                             'pct_counts_in_top_50_genes'],                     jitter=0.4, multi_panel=True) In\u00a0[37]: Copied! <pre>fig, ax = plt.subplots(1,1,figsize=(2,2))\nsc.pl.scatter(expression_quantified, x='total_counts', y='n_genes_by_counts', ax=ax)\n</pre> fig, ax = plt.subplots(1,1,figsize=(2,2)) sc.pl.scatter(expression_quantified, x='total_counts', y='n_genes_by_counts', ax=ax) In\u00a0[44]: Copied! <pre>sc.pp.log1p(expression_quantified)\nsc.pp.highly_variable_genes(expression_quantified, min_mean=0.2, max_mean=4, min_disp=0.2, n_bins=50)\nsc.pl.highly_variable_genes(expression_quantified)\nwith warnings.catch_warnings():\n    sc.tl.pca(expression_quantified, n_comps=100)\nsc.pp.neighbors(expression_quantified)\nsc.tl.umap(expression_quantified)\nclusterResolutions = []\nsc.tl.leiden(expression_quantified)\ncc_genes = pd.read_csv(cellcycleGenePath, header = None)[0]\nsc.tl.score_genes_cell_cycle(expression_quantified, s_genes=cc_genes[:43], g2m_genes=cc_genes[43:])\nplt.rcParams['figure.figsize'] = [6, 4.5]\n</pre> sc.pp.log1p(expression_quantified) sc.pp.highly_variable_genes(expression_quantified, min_mean=0.2, max_mean=4, min_disp=0.2, n_bins=50) sc.pl.highly_variable_genes(expression_quantified) with warnings.catch_warnings():     sc.tl.pca(expression_quantified, n_comps=100) sc.pp.neighbors(expression_quantified) sc.tl.umap(expression_quantified) clusterResolutions = [] sc.tl.leiden(expression_quantified) cc_genes = pd.read_csv(cellcycleGenePath, header = None)[0] sc.tl.score_genes_cell_cycle(expression_quantified, s_genes=cc_genes[:43], g2m_genes=cc_genes[43:]) plt.rcParams['figure.figsize'] = [6, 4.5]  <pre>WARNING: adata.X seems to be already log-transformed.\n</pre> <pre>WARNING: genes are not in var_names and ignored: ['MLF1IP']\n</pre> In\u00a0[43]: Copied! <pre>sc.pl.umap(expression_quantified, color = [\n    # \"PTPRC\",\n    \"leiden\", \n    'total_counts', \n    'log1p_total_counts',\n    'pct_counts_in_top_50_genes', \n    'has_guide_annotations',\n    \"phase\",\n    \"target_symbol\",\n])\n</pre> sc.pl.umap(expression_quantified, color = [     # \"PTPRC\",     \"leiden\",      'total_counts',      'log1p_total_counts',     'pct_counts_in_top_50_genes',      'has_guide_annotations',     \"phase\",     \"target_symbol\", ]) <pre>Index(['n_genes_by_counts', 'log1p_n_genes_by_counts', 'total_counts',\n       'log1p_total_counts', 'pct_counts_in_top_50_genes',\n       'pct_counts_in_top_100_genes', 'pct_counts_in_top_200_genes',\n       'pct_counts_in_top_500_genes', 'cell_barcode', 'guide_identity',\n       'num_guides', 'gene', 'best_gamma', 'correction', 'distance', 'gamma_A',\n       'gamma_B', 'gene_type', 'protospacer_A', 'protospacer_B', 'rank_A',\n       'rank_B', 'sgID_A', 'sgID_B', 'type', 'target', 'umi_A', 'umi_B',\n       'read_count', 'UMI_count', 'coverage', 'good_coverage',\n       'number_of_cells', 'gemgroup', 'target_symbol', 'has_guide_annotations',\n       'total_counts_ribo', 'pct_counts_ribo', 'total_counts_mt',\n       'pct_counts_mt', 'leiden', 'S_score', 'G2M_score', 'phase'],\n      dtype='object')\n</pre>"},{"location":"notebooks/hwex_done.html#organization","title":"Organization\u00b6","text":"<p>After the usual imports, we follow the order as described in the assignment, except that out of convenience, some QC metrics are computed before the data reshaping is done.</p>"},{"location":"notebooks/hwex_done.html#1-tidy-the-dataset-so-that-it-fits-in-an-anndata-object","title":"1. Tidy the dataset so that it fits in an AnnData object.\u00b6","text":""},{"location":"notebooks/hwex_done.html#11-for-each-overexpressed-gene-how-many-cells-are-measured","title":"1.1 For each overexpressed gene, how many cells are measured?\u00b6","text":"<p>The code below shows that between 212 and 1861 cells are measured for any given perturbation, with ~5k controls.</p>"},{"location":"notebooks/hwex_done.html#2-compute-typical-scrna-quality-metrics-and-filter-out-genes-and-cells-as-discussed-in-class","title":"2. Compute typical scRNA quality metrics and filter out genes and cells as discussed in class.\u00b6","text":"<p>For this particular project, we prefer to err on the side of discarding real cells rather than risking inclusion of empty droplets, doublets, or other artifacts in our analysis. Out of an abundance of caution, we remove droplets with especially high or low total counts, and we remove droplets with high fractions of RNA from mitochondrial RNA's, ribosomal protein subunit RNA's, or high-expressed RNA's. Please consult the code below for exact thresholds and numbers.</p>"},{"location":"notebooks/hwex_done.html#basic-eda","title":"Basic EDA\u00b6","text":"<p>Visualize the data using scanpy.</p>"},{"location":"notebooks/hwex_done.html#31-run-the-code-and-describe-the-results","title":"3.1 Run the code and describe the results.\u00b6","text":"<p>The UMAP shows a roughly unimodal distribution a lot of variation driven by cell cycle and read depth. Cells do not obviously cluster by which gene was overexpressed. This suggests that most of these perturbations do not cause extensive reprogramming of cell state.</p>"},{"location":"notebooks/integration.html","title":"Integration","text":"In\u00a0[\u00a0]: Copied! In\u00a0[1]: Copied! <pre>import warnings\nwarnings.filterwarnings(\"ignore\", category=FutureWarning)\nimport os, sys\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport scanpy as sc\nimport pySingleCellNet as cn\n</pre> import warnings warnings.filterwarnings(\"ignore\", category=FutureWarning) import os, sys import numpy as np import pandas as pd import matplotlib.pyplot as plt import scanpy as sc import pySingleCellNet as cn In\u00a0[2]: Copied! <pre>adPijuan = sc.read_h5ad(\"ad_Pijuan_demo.h5ad\")\nadPijuan\n</pre> adPijuan = sc.read_h5ad(\"ad_Pijuan_demo.h5ad\") adPijuan Out[2]: <pre>AnnData object with n_obs \u00d7 n_vars = 2071 \u00d7 21133\n    obs: 'cell', 'stage', 'celltype'\n    var: 'ENSEMBL'</pre> In\u00a0[3]: Copied! <pre>adPijuan.obs['celltype'].value_counts()\n</pre> adPijuan.obs['celltype'].value_counts() Out[3]: <pre>celltype\nMeso.Cardio     300\nPGC             297\nEndo.Gut        296\nEpiblast        296\nAnterior.PS     294\nEcto.Neural     294\nMeso.Nascent    294\nName: count, dtype: int64</pre> In\u00a0[4]: Copied! <pre>adTrain = adPijuan\nadTrain.layers['counts'] = adTrain.X.copy()\nsc.pp.normalize_total(adTrain)\nsc.pp.log1p(adTrain)\nsc.pp.highly_variable_genes(adTrain, n_top_genes=2000, flavor='seurat_v3', layer='counts')\n</pre> adTrain = adPijuan adTrain.layers['counts'] = adTrain.X.copy() sc.pp.normalize_total(adTrain) sc.pp.log1p(adTrain) sc.pp.highly_variable_genes(adTrain, n_top_genes=2000, flavor='seurat_v3', layer='counts') In\u00a0[5]: Copied! <pre>sc.tl.pca(adTrain, mask_var='highly_variable')\nsc.pl.pca_variance_ratio(adTrain, n_pcs=50)\n</pre> sc.tl.pca(adTrain, mask_var='highly_variable') sc.pl.pca_variance_ratio(adTrain, n_pcs=50) In\u00a0[6]: Copied! <pre>def_npcs = 20\ndef_nneigh = 10\nsc.pp.neighbors(adTrain, n_neighbors = def_nneigh,  n_pcs = def_npcs)\n</pre> def_npcs = 20 def_nneigh = 10 sc.pp.neighbors(adTrain, n_neighbors = def_nneigh,  n_pcs = def_npcs) In\u00a0[7]: Copied! <pre>sc.tl.umap(adTrain)\nsc.pl.umap(adTrain, color=['celltype', 'stage'], size=30, alpha=.95,frameon=False)\n</pre> sc.tl.umap(adTrain) sc.pl.umap(adTrain, color=['celltype', 'stage'], size=30, alpha=.95,frameon=False) In\u00a0[8]: Copied! <pre>adGross = sc.read_h5ad(\"ad_Grosswendt_demo.h5ad\")\nadGross\n</pre> adGross = sc.read_h5ad(\"ad_Grosswendt_demo.h5ad\") adGross Out[8]: <pre>AnnData object with n_obs \u00d7 n_vars = 700 \u00d7 21133\n    obs: 'embryo', 'stage', 'celltype'\n    var: 'name'</pre> In\u00a0[9]: Copied! <pre>adPijuan = sc.read_h5ad(\"ad_Pijuan_demo.h5ad\")\nadPijuan.obs['study'] = 'Pijuan'\nadGross.obs['study'] = 'Grosswendt'\n</pre> adPijuan = sc.read_h5ad(\"ad_Pijuan_demo.h5ad\") adPijuan.obs['study'] = 'Pijuan' adGross.obs['study'] = 'Grosswendt' In\u00a0[10]: Copied! <pre>import anndata as ad\ndel(adPijuan.raw)\nadComb = ad.concat([adPijuan, adGross])\n</pre> import anndata as ad del(adPijuan.raw) adComb = ad.concat([adPijuan, adGross]) In\u00a0[11]: Copied! <pre>adComb.obs['study'].value_counts()\n</pre> adComb.obs['study'].value_counts() Out[11]: <pre>study\nPijuan        2071\nGrosswendt     700\nName: count, dtype: int64</pre> In\u00a0[12]: Copied! <pre>adComb.layers['counts'] = adComb.X.copy()\nsc.pp.normalize_total(adComb)\nsc.pp.log1p(adComb)\nsc.pp.highly_variable_genes(adComb, n_top_genes=2000, flavor='seurat_v3', layer='counts')\nsc.tl.pca(adComb, mask_var='highly_variable')\nsc.pl.pca_variance_ratio(adComb, n_pcs=50)\n</pre> adComb.layers['counts'] = adComb.X.copy() sc.pp.normalize_total(adComb) sc.pp.log1p(adComb) sc.pp.highly_variable_genes(adComb, n_top_genes=2000, flavor='seurat_v3', layer='counts') sc.tl.pca(adComb, mask_var='highly_variable') sc.pl.pca_variance_ratio(adComb, n_pcs=50) In\u00a0[13]: Copied! <pre>def_npcs = 20\ndef_nneigh = 10 # preference -- allows detection of rare populations\nsc.pp.neighbors(adComb, n_neighbors = def_nneigh,  n_pcs = def_npcs)\nsc.tl.umap(adComb)\nsc.pl.umap(adComb, color=['study', 'celltype'], size=30, alpha=.95,frameon=False)\n</pre> def_npcs = 20 def_nneigh = 10 # preference -- allows detection of rare populations sc.pp.neighbors(adComb, n_neighbors = def_nneigh,  n_pcs = def_npcs) sc.tl.umap(adComb) sc.pl.umap(adComb, color=['study', 'celltype'], size=30, alpha=.95,frameon=False) <p>The embedding above strongly suggests that there will be very little clustering of cells from the same type across data from the two studies.</p> In\u00a0[14]: Copied! <pre>adComb2 = ad.concat([adPijuan, adGross])\nbatch_key = \"study\"\n\nsc.pp.filter_genes(adComb2, min_cells=3)\nadComb2.layers['counts'] = adComb2.X.copy()\n</pre> adComb2 = ad.concat([adPijuan, adGross]) batch_key = \"study\"  sc.pp.filter_genes(adComb2, min_cells=3) adComb2.layers['counts'] = adComb2.X.copy() In\u00a0[15]: Copied! <pre>sc.pp.normalize_total(adComb2)\nsc.pp.log1p(adComb2)\nsc.pp.highly_variable_genes(adComb2, n_top_genes=2000, flavor=\"cell_ranger\", batch_key=batch_key)\n</pre> sc.pp.normalize_total(adComb2) sc.pp.log1p(adComb2) sc.pp.highly_variable_genes(adComb2, n_top_genes=2000, flavor=\"cell_ranger\", batch_key=batch_key) In\u00a0[17]: Copied! <pre>adata_hvg = adComb2[:,adComb2.var[\"highly_variable\"]].copy()\nsc.pp.pca(adata_hvg)\nsc.external.pp.bbknn(adata_hvg, batch_key=batch_key)\n</pre> adata_hvg = adComb2[:,adComb2.var[\"highly_variable\"]].copy() sc.pp.pca(adata_hvg) sc.external.pp.bbknn(adata_hvg, batch_key=batch_key) <pre>WARNING: consider updating your call to make use of `computation`\n</pre> In\u00a0[18]: Copied! <pre>adata_hvg\n</pre> adata_hvg Out[18]: <pre>AnnData object with n_obs \u00d7 n_vars = 2771 \u00d7 2000\n    obs: 'stage', 'celltype', 'study'\n    var: 'n_cells', 'highly_variable', 'means', 'dispersions', 'dispersions_norm', 'highly_variable_nbatches', 'highly_variable_intersection'\n    uns: 'log1p', 'hvg', 'pca', 'neighbors'\n    obsm: 'X_pca'\n    varm: 'PCs'\n    layers: 'counts'\n    obsp: 'distances', 'connectivities'</pre> In\u00a0[19]: Copied! <pre>sc.tl.umap(adata_hvg)\nsc.pl.umap(adata_hvg, color=['study', 'celltype'], size=30, alpha=.95,frameon=False)\n</pre> sc.tl.umap(adata_hvg) sc.pl.umap(adata_hvg, color=['study', 'celltype'], size=30, alpha=.95,frameon=False) <p>The integration by BBKNN in this example looks pretty good! Note that in both this approach and the naive integration, the user would still need to perform some post-integration processing in order to label the query cells. This could easily be done by clustering and then assotating query cells based on the most frequent label of reference cells sharing the same cluster as query cells. Try to think of other approaches to this task.</p> In\u00a0[20]: Copied! <pre>adRef2 = sc.read_h5ad(\"ad_Pijuan_demo.h5ad\")\nadQuery = sc.read_h5ad(\"ad_Grosswendt_demo.h5ad\")\n</pre> adRef2 = sc.read_h5ad(\"ad_Pijuan_demo.h5ad\") adQuery = sc.read_h5ad(\"ad_Grosswendt_demo.h5ad\") In\u00a0[21]: Copied! <pre>cn.ut.limit_anndata_to_common_genes([adRef2, adQuery])\n</pre> cn.ut.limit_anndata_to_common_genes([adRef2, adQuery]) In\u00a0[22]: Copied! <pre>n_cells = 100\ngroupby = 'celltype'\n# explain\nstrata_col = 'stage'\n\ntids, vids = cn.ut.split_adata_indices(adRef2, n_cells, groupby=groupby, cellid=None, strata_col=strata_col)\n</pre> n_cells = 100 groupby = 'celltype' # explain strata_col = 'stage'  tids, vids = cn.ut.split_adata_indices(adRef2, n_cells, groupby=groupby, cellid=None, strata_col=strata_col) In\u00a0[23]: Copied! <pre>adTrain = adRef2[tids].copy()\nadHO = adRef2[vids].copy()\n</pre> adTrain = adRef2[tids].copy() adHO = adRef2[vids].copy() In\u00a0[24]: Copied! <pre>sc.pp.highly_variable_genes(adTrain, n_top_genes=3000, flavor='seurat_v3')\nsc.pp.normalize_total(adTrain)\nsc.pp.log1p(adTrain)\n</pre> sc.pp.highly_variable_genes(adTrain, n_top_genes=3000, flavor='seurat_v3') sc.pp.normalize_total(adTrain) sc.pp.log1p(adTrain) In\u00a0[25]: Copied! <pre>n_rand = n_cells\nnTopGenes = 30\nnTopGenePairs = 40\nn_comps = 30\nn_trees = 1000\nobs_pred = \"SCN_class_argmax\"\n\nclf = cn.cl.train_classifier(adTrain, groupby, nRand = n_rand, nTopGenes = nTopGenes, nTopGenePairs = nTopGenePairs, n_comps = n_comps)\n</pre> n_rand = n_cells nTopGenes = 30 nTopGenePairs = 40 n_comps = 30 n_trees = 1000 obs_pred = \"SCN_class_argmax\"  clf = cn.cl.train_classifier(adTrain, groupby, nRand = n_rand, nTopGenes = nTopGenes, nTopGenePairs = nTopGenePairs, n_comps = n_comps) <pre>Training classifier |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 5/5 [100%] in 1.9s (2.59/s) \n</pre> In\u00a0[26]: Copied! <pre>cn.cl.classify_anndata(adHO, clf)\n</pre> cn.cl.classify_anndata(adHO, clf) In\u00a0[27]: Copied! <pre>adHO\n# cn.pl.heatmap_scores(adHO, groubpy='SCN_class_argmax')\n</pre> adHO # cn.pl.heatmap_scores(adHO, groubpy='SCN_class_argmax') Out[27]: <pre>AnnData object with n_obs \u00d7 n_vars = 1386 \u00d7 21133\n    obs: 'cell', 'stage', 'celltype', 'cellid', 'SCN_class_argmax'\n    var: 'ENSEMBL'\n    uns: 'SCN_class_argmax_colors'\n    obsm: 'SCN_score'</pre> In\u00a0[28]: Copied! <pre>type(adHO.obsm)\n</pre> type(adHO.obsm) Out[28]: <pre>anndata._core.aligned_mapping.AxisArrays</pre> In\u00a0[29]: Copied! <pre>adHO.obsm\n</pre> adHO.obsm Out[29]: <pre>AxisArrays with keys: SCN_score</pre> In\u00a0[30]: Copied! <pre>cn.pl.heatmap_scores(adHO, groupby = 'SCN_class_argmax')\n</pre> cn.pl.heatmap_scores(adHO, groupby = 'SCN_class_argmax') In\u00a0[31]: Copied! <pre>cn.pl.heatmap_scores(adHO, groupby = 'celltype')\n</pre> cn.pl.heatmap_scores(adHO, groupby = 'celltype') In\u00a0[32]: Copied! <pre>c_report = cn.cl.create_classifier_report(adHO, ground_truth=groupby, prediction=obs_pred)\n</pre> c_report = cn.cl.create_classifier_report(adHO, ground_truth=groupby, prediction=obs_pred) In\u00a0[33]: Copied! <pre>cn.pl.heatmap_classifier_report(c_report)\n</pre> cn.pl.heatmap_classifier_report(c_report) In\u00a0[34]: Copied! <pre>cn.cl.classify_anndata(adQuery, clf)\n</pre> cn.cl.classify_anndata(adQuery, clf) In\u00a0[35]: Copied! <pre>cn.pl.heatmap_scores(adQuery, groupby = 'SCN_class_argmax')\n</pre> cn.pl.heatmap_scores(adQuery, groupby = 'SCN_class_argmax') In\u00a0[36]: Copied! <pre>adQuery.obs['SCN_class_argmax'].value_counts()\n</pre> adQuery.obs['SCN_class_argmax'].value_counts() Out[36]: <pre>SCN_class_argmax\nEpiblast        113\nEndo.Gut        105\nEcto.Neural     104\nMeso.Cardio     102\nMeso.Nascent     98\nAnterior.PS      89\nPGC              87\nrand              2\nName: count, dtype: int64</pre> In\u00a0[37]: Copied! <pre>c_report_2 = cn.cl.create_classifier_report(adQuery, ground_truth=groupby, prediction=obs_pred)\n</pre> c_report_2 = cn.cl.create_classifier_report(adQuery, ground_truth=groupby, prediction=obs_pred) In\u00a0[38]: Copied! <pre>cn.pl.heatmap_classifier_report(c_report_2)\n</pre> cn.pl.heatmap_classifier_report(c_report_2) In\u00a0[39]: Copied! <pre>tThrs_val_05_HO = cn.cl.comp_ct_thresh(adHO, 0.05)\n</pre> tThrs_val_05_HO = cn.cl.comp_ct_thresh(adHO, 0.05) In\u00a0[40]: Copied! <pre>tThrs_val_05_HO\n</pre> tThrs_val_05_HO Out[40]: 0 Anterior.PS 0.36695 Ecto.Neural 0.39885 Endo.Gut 0.38820 Epiblast 0.31290 Meso.Cardio 0.56400 Meso.Nascent 0.32700 PGC 0.35690 In\u00a0[41]: Copied! <pre>rela_graph = cn.cl.paga_connectivities_to_igraph(adTrain, threshold = 0.3, n_comps = n_comps, group_key = groupby)\n</pre> rela_graph = cn.cl.paga_connectivities_to_igraph(adTrain, threshold = 0.3, n_comps = n_comps, group_key = groupby) In\u00a0[42]: Copied! <pre>cn.cl.categorize_classification(adQuery, tThrs_val_05_HO, rela_graph)\n</pre> cn.cl.categorize_classification(adQuery, tThrs_val_05_HO, rela_graph) In\u00a0[44]: Copied! <pre>cn.pl.stackedbar_categories(adQuery, class_col_name='celltype', show_pct_total=True)\n</pre> cn.pl.stackedbar_categories(adQuery, class_col_name='celltype', show_pct_total=True) Out[44]: In\u00a0[45]: Copied! <pre>adQuery\n</pre> adQuery Out[45]: <pre>AnnData object with n_obs \u00d7 n_vars = 700 \u00d7 21133\n    obs: 'embryo', 'stage', 'celltype', 'SCN_class_argmax', 'SCN_class_emp', 'SCN_class_type', 'SCN_class_cat'\n    var: 'name'\n    uns: 'SCN_class_argmax_colors'\n    obsm: 'SCN_score'</pre> In\u00a0[46]: Copied! <pre>cn.pl.heatmap_scores(adQuery, groupby = 'SCN_class_cat')\n</pre> cn.pl.heatmap_scores(adQuery, groupby = 'SCN_class_cat') In\u00a0[47]: Copied! <pre>adtest2 = adQuery.copy()\nadtest2.layers['counts'] = adtest2.X.copy()\nsc.pp.normalize_total(adtest2)\nsc.pp.log1p(adtest2)\nsc.pp.highly_variable_genes(adtest2, n_top_genes=3000, flavor='seurat_v3', layer='counts')\nsc.tl.pca(adtest2, mask_var='highly_variable')\nsc.pl.pca_variance_ratio(adtest2, n_pcs=50)\n</pre> adtest2 = adQuery.copy() adtest2.layers['counts'] = adtest2.X.copy() sc.pp.normalize_total(adtest2) sc.pp.log1p(adtest2) sc.pp.highly_variable_genes(adtest2, n_top_genes=3000, flavor='seurat_v3', layer='counts') sc.tl.pca(adtest2, mask_var='highly_variable') sc.pl.pca_variance_ratio(adtest2, n_pcs=50) In\u00a0[48]: Copied! <pre>def_npcs = 30\ndef_nneigh = 10\nsc.pp.neighbors(adtest2, n_neighbors = def_nneigh,  n_pcs = def_npcs)\nsc.tl.umap(adtest2)\nsc.pl.umap(adtest2, color=['SCN_class_argmax', 'SCN_class_type'], size=50, alpha=.95,frameon=False)\n</pre> def_npcs = 30 def_nneigh = 10 sc.pp.neighbors(adtest2, n_neighbors = def_nneigh,  n_pcs = def_npcs) sc.tl.umap(adtest2) sc.pl.umap(adtest2, color=['SCN_class_argmax', 'SCN_class_type'], size=50, alpha=.95,frameon=False) <pre>WARNING: The following color value found in adata.uns['SCN_class_argmax_colors'] is not valid: 'Anterior.PS'. Default colors will be used instead.\n</pre>"},{"location":"notebooks/integration.html#cell-typing-by-data-integration-and-by-classification","title":"Cell typing by data integration and by classification\u00b6","text":"<p>Here, we walk you through three ways to predict the cell types in your query scRNAseq data set by leveraging another, well-anntated reference dataset. The first way is to directly combine the datasets an cluster them together. The second way is called 'Batch Balanced KNN', which works by finding kNN across batches. The third way is to classify the query data with classifier that was trained with the reference data.</p>"},{"location":"notebooks/integration.html#data","title":"Data\u00b6","text":"<p>We will use mouse cells from gastrula-stage embryos from two studies.</p> <p>The reference data comes from Pijuan-Sala et al 2019 which describes a single cell census of gastrulation in mouse (E6.5 to E8.5). You can download the .h5ad file here.</p> <p>The query data comes from another gastula census Grosswendt et al 2020. You can download the .h5ad file here.</p> <p>For the sake of computational efficiency, we have taken only a small subset of the cells from each of these studies. The cell type label is stored in <code>.obs['celltype']</code></p>"},{"location":"notebooks/integration.html#naive-concatenation-of-anndata-objects-then-clustering","title":"Naive concatenation of anndata objects, then clustering\u00b6","text":""},{"location":"notebooks/integration.html#method-2-bbknn","title":"Method 2: BBKNN\u00b6","text":"<p>For details on how the <code>sc.external.pp.bbknn()</code> function works, go to scanpy's documentation.</p> <p>Also see the section on graph based integration in the online best practices book</p>"},{"location":"notebooks/integration.html#method-3-ml-classification","title":"Method 3: ML Classification\u00b6","text":"<p>In the third approach, we will directly annotate query cells by classifying them using a model trained on reference data. Our PySingleCellNet (pySCN) package was designed for this task.</p>"},{"location":"notebooks/scBasics.html","title":"scRNA-seq 1","text":"<p>Here is a more detailed glimpse of what is happening here:</p> CellRanger flow chart 2 from 10X genomics <ul> <li>Trims reads</li> <li>Splicing aware alignment to reference genome</li> <li>deals wth reads mapping to &gt; 1 locus</li> </ul> CellRanger mapping from 10X genomics In\u00a0[1]: Copied! <pre>!pip install scanpy python-igraph scipy umap-learn leidenalg\n</pre> !pip install scanpy python-igraph scipy umap-learn leidenalg <pre>Requirement already satisfied: scanpy in /opt/homebrew/Caskroom/miniforge/base/envs/mkdocs/lib/python3.12/site-packages (1.10.4)\nRequirement already satisfied: python-igraph in /opt/homebrew/Caskroom/miniforge/base/envs/mkdocs/lib/python3.12/site-packages (0.11.8)\nRequirement already satisfied: scipy in /opt/homebrew/Caskroom/miniforge/base/envs/mkdocs/lib/python3.12/site-packages (1.15.1)\nRequirement already satisfied: umap-learn in /opt/homebrew/Caskroom/miniforge/base/envs/mkdocs/lib/python3.12/site-packages (0.5.7)\nRequirement already satisfied: leidenalg in /opt/homebrew/Caskroom/miniforge/base/envs/mkdocs/lib/python3.12/site-packages (0.10.2)\nRequirement already satisfied: anndata&gt;=0.8 in /opt/homebrew/Caskroom/miniforge/base/envs/mkdocs/lib/python3.12/site-packages (from scanpy) (0.11.3)\nRequirement already satisfied: h5py&gt;=3.6 in /opt/homebrew/Caskroom/miniforge/base/envs/mkdocs/lib/python3.12/site-packages (from scanpy) (3.12.1)\nRequirement already satisfied: joblib in /opt/homebrew/Caskroom/miniforge/base/envs/mkdocs/lib/python3.12/site-packages (from scanpy) (1.4.2)\nRequirement already satisfied: legacy-api-wrap&gt;=1.4 in /opt/homebrew/Caskroom/miniforge/base/envs/mkdocs/lib/python3.12/site-packages (from scanpy) (1.4.1)\nRequirement already satisfied: matplotlib&gt;=3.6 in /opt/homebrew/Caskroom/miniforge/base/envs/mkdocs/lib/python3.12/site-packages (from scanpy) (3.10.0)\nRequirement already satisfied: natsort in /opt/homebrew/Caskroom/miniforge/base/envs/mkdocs/lib/python3.12/site-packages (from scanpy) (8.4.0)\nRequirement already satisfied: networkx&gt;=2.7 in /opt/homebrew/Caskroom/miniforge/base/envs/mkdocs/lib/python3.12/site-packages (from scanpy) (3.4.2)\nRequirement already satisfied: numba&gt;=0.56 in /opt/homebrew/Caskroom/miniforge/base/envs/mkdocs/lib/python3.12/site-packages (from scanpy) (0.60.0)\nRequirement already satisfied: numpy&gt;=1.23 in /opt/homebrew/Caskroom/miniforge/base/envs/mkdocs/lib/python3.12/site-packages (from scanpy) (1.26.4)\nRequirement already satisfied: packaging&gt;=21.3 in /opt/homebrew/Caskroom/miniforge/base/envs/mkdocs/lib/python3.12/site-packages (from scanpy) (24.2)\nRequirement already satisfied: pandas&gt;=1.5 in /opt/homebrew/Caskroom/miniforge/base/envs/mkdocs/lib/python3.12/site-packages (from scanpy) (2.2.3)\nRequirement already satisfied: patsy!=1.0.0 in /opt/homebrew/Caskroom/miniforge/base/envs/mkdocs/lib/python3.12/site-packages (from scanpy) (1.0.1)\nRequirement already satisfied: pynndescent&gt;=0.5 in /opt/homebrew/Caskroom/miniforge/base/envs/mkdocs/lib/python3.12/site-packages (from scanpy) (0.5.13)\nRequirement already satisfied: scikit-learn&gt;=1.1 in /opt/homebrew/Caskroom/miniforge/base/envs/mkdocs/lib/python3.12/site-packages (from scanpy) (1.6.1)\nRequirement already satisfied: seaborn&gt;=0.13 in /opt/homebrew/Caskroom/miniforge/base/envs/mkdocs/lib/python3.12/site-packages (from scanpy) (0.13.2)\nRequirement already satisfied: session-info in /opt/homebrew/Caskroom/miniforge/base/envs/mkdocs/lib/python3.12/site-packages (from scanpy) (1.0.0)\nRequirement already satisfied: statsmodels&gt;=0.13 in /opt/homebrew/Caskroom/miniforge/base/envs/mkdocs/lib/python3.12/site-packages (from scanpy) (0.14.4)\nRequirement already satisfied: tqdm in /opt/homebrew/Caskroom/miniforge/base/envs/mkdocs/lib/python3.12/site-packages (from scanpy) (4.67.1)\nRequirement already satisfied: igraph==0.11.8 in /opt/homebrew/Caskroom/miniforge/base/envs/mkdocs/lib/python3.12/site-packages (from python-igraph) (0.11.8)\nRequirement already satisfied: texttable&gt;=1.6.2 in /opt/homebrew/Caskroom/miniforge/base/envs/mkdocs/lib/python3.12/site-packages (from igraph==0.11.8-&gt;python-igraph) (1.7.0)\nRequirement already satisfied: array-api-compat!=1.5,&gt;1.4 in /opt/homebrew/Caskroom/miniforge/base/envs/mkdocs/lib/python3.12/site-packages (from anndata&gt;=0.8-&gt;scanpy) (1.10.0)\nRequirement already satisfied: contourpy&gt;=1.0.1 in /opt/homebrew/Caskroom/miniforge/base/envs/mkdocs/lib/python3.12/site-packages (from matplotlib&gt;=3.6-&gt;scanpy) (1.3.1)\nRequirement already satisfied: cycler&gt;=0.10 in /opt/homebrew/Caskroom/miniforge/base/envs/mkdocs/lib/python3.12/site-packages (from matplotlib&gt;=3.6-&gt;scanpy) (0.12.1)\nRequirement already satisfied: fonttools&gt;=4.22.0 in /opt/homebrew/Caskroom/miniforge/base/envs/mkdocs/lib/python3.12/site-packages (from matplotlib&gt;=3.6-&gt;scanpy) (4.55.3)\nRequirement already satisfied: kiwisolver&gt;=1.3.1 in /opt/homebrew/Caskroom/miniforge/base/envs/mkdocs/lib/python3.12/site-packages (from matplotlib&gt;=3.6-&gt;scanpy) (1.4.7)\nRequirement already satisfied: pillow&gt;=8 in /opt/homebrew/Caskroom/miniforge/base/envs/mkdocs/lib/python3.12/site-packages (from matplotlib&gt;=3.6-&gt;scanpy) (11.1.0)\nRequirement already satisfied: pyparsing&gt;=2.3.1 in /opt/homebrew/Caskroom/miniforge/base/envs/mkdocs/lib/python3.12/site-packages (from matplotlib&gt;=3.6-&gt;scanpy) (3.2.1)\nRequirement already satisfied: python-dateutil&gt;=2.7 in /opt/homebrew/Caskroom/miniforge/base/envs/mkdocs/lib/python3.12/site-packages (from matplotlib&gt;=3.6-&gt;scanpy) (2.9.0.post0)\nRequirement already satisfied: llvmlite&lt;0.44,&gt;=0.43.0dev0 in /opt/homebrew/Caskroom/miniforge/base/envs/mkdocs/lib/python3.12/site-packages (from numba&gt;=0.56-&gt;scanpy) (0.43.0)\nRequirement already satisfied: pytz&gt;=2020.1 in /opt/homebrew/Caskroom/miniforge/base/envs/mkdocs/lib/python3.12/site-packages (from pandas&gt;=1.5-&gt;scanpy) (2024.1)\nRequirement already satisfied: tzdata&gt;=2022.7 in /opt/homebrew/Caskroom/miniforge/base/envs/mkdocs/lib/python3.12/site-packages (from pandas&gt;=1.5-&gt;scanpy) (2024.2)\nRequirement already satisfied: threadpoolctl&gt;=3.1.0 in /opt/homebrew/Caskroom/miniforge/base/envs/mkdocs/lib/python3.12/site-packages (from scikit-learn&gt;=1.1-&gt;scanpy) (3.5.0)\nRequirement already satisfied: stdlib-list in /opt/homebrew/Caskroom/miniforge/base/envs/mkdocs/lib/python3.12/site-packages (from session-info-&gt;scanpy) (0.11.0)\nRequirement already satisfied: six&gt;=1.5 in /opt/homebrew/Caskroom/miniforge/base/envs/mkdocs/lib/python3.12/site-packages (from python-dateutil&gt;=2.7-&gt;matplotlib&gt;=3.6-&gt;scanpy) (1.17.0)\n</pre> In\u00a0[2]: Copied! <pre>!wget https://cf.10xgenomics.com/samples/cell-exp/3.0.0/pbmc_10k_v3/pbmc_10k_v3_filtered_feature_bc_matrix.h5\n</pre> !wget https://cf.10xgenomics.com/samples/cell-exp/3.0.0/pbmc_10k_v3/pbmc_10k_v3_filtered_feature_bc_matrix.h5 <pre>--2026-01-27 10:40:49--  https://cf.10xgenomics.com/samples/cell-exp/3.0.0/pbmc_10k_v3/pbmc_10k_v3_filtered_feature_bc_matrix.h5\nResolving cf.10xgenomics.com (cf.10xgenomics.com)... 104.18.1.173, 104.18.0.173\nConnecting to cf.10xgenomics.com (cf.10xgenomics.com)|104.18.1.173|:443... connected.\nHTTP request sent, awaiting response... 200 OK\nLength: 37491093 (36M) [binary/octet-stream]\nSaving to: \u2018pbmc_10k_v3_filtered_feature_bc_matrix.h5\u2019\n\npbmc_10k_v3_filtere 100%[===================&gt;]  35.75M  36.9MB/s    in 1.0s    \n\n2026-01-27 10:40:51 (36.9 MB/s) - \u2018pbmc_10k_v3_filtered_feature_bc_matrix.h5\u2019 saved [37491093/37491093]\n\n</pre> In\u00a0[3]: Copied! <pre>import scanpy as sc\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport warnings\nwarnings.filterwarnings('ignore')\nplt.rcParams['figure.dpi'] = 300\nsc.logging.print_header()\n</pre> import scanpy as sc import numpy as np import pandas as pd import matplotlib.pyplot as plt import warnings warnings.filterwarnings('ignore') plt.rcParams['figure.dpi'] = 300 sc.logging.print_header() <pre>scanpy==1.10.4 anndata==0.11.3 umap==0.5.7 numpy==1.26.4 scipy==1.15.1 pandas==2.2.3 scikit-learn==1.6.1 statsmodels==0.14.4 igraph==0.11.8 pynndescent==0.5.13\n</pre> In\u00a0[4]: Copied! <pre>ad10f = sc.read_10x_h5(\"pbmc_10k_v3_filtered_feature_bc_matrix.h5\")\n</pre> ad10f = sc.read_10x_h5(\"pbmc_10k_v3_filtered_feature_bc_matrix.h5\") In\u00a0[5]: Copied! <pre>?sc.read_10x_h5\n</pre> ?sc.read_10x_h5 <pre>Signature:\nsc.read_10x_h5(\n    filename: 'Path | str',\n    *,\n    genome: 'str | None' = None,\n    gex_only: 'bool' = True,\n    backup_url: 'str | None' = None,\n) -&gt; 'AnnData'\nDocstring:\nRead 10x-Genomics-formatted hdf5 file.\n\nParameters\n----------\nfilename : 'Path | str'\n    Path to a 10x hdf5 file.\ngenome : 'str | None', optional (default: None)\n    Filter expression to genes within this genome. For legacy 10x h5\n    files, this must be provided if the data contains more than one genome.\ngex_only : 'bool', optional (default: True)\n    Only keep 'Gene Expression' data and ignore other feature types,\n    e.g. 'Antibody Capture', 'CRISPR Guide Capture', or 'Custom'\nbackup_url : 'str | None', optional (default: None)\n    Retrieve the file from an URL if not present on disk.\n\nReturns\n-------\nAnnotated data matrix, where observations/cells are named by their\nbarcode and variables/genes by gene name. Stores the following information:\n\n:attr:`~anndata.AnnData.X`\n    The data matrix is stored\n:attr:`~anndata.AnnData.obs_names`\n    Cell names\n:attr:`~anndata.AnnData.var_names`\n    Gene names for a feature barcode matrix, probe names for a probe bc matrix\n:attr:`~anndata.AnnData.var`\\ `['gene_ids']`\n    Gene IDs\n:attr:`~anndata.AnnData.var`\\ `['feature_types']`\n    Feature types\n:attr:`~anndata.AnnData.obs`\\ `[filtered_barcodes]`\n    filtered barcodes if present in the matrix\n:attr:`~anndata.AnnData.var`\n    Any additional metadata present in /matrix/features is read in.\nFile:      /opt/homebrew/Caskroom/miniforge/base/envs/mkdocs/lib/python3.12/site-packages/scanpy/readwrite.py\nType:      function</pre> In\u00a0[7]: Copied! <pre>ad10f\n</pre> ad10f Out[7]: <pre>AnnData object with n_obs \u00d7 n_vars = 11769 \u00d7 33538\n    var: 'gene_ids', 'feature_types', 'genome'</pre> In\u00a0[8]: Copied! <pre>type(ad10f)\n</pre> type(ad10f) Out[8]: <pre>anndata._core.anndata.AnnData</pre> In\u00a0[9]: Copied! <pre>ad10f.var_names_make_unique()\n</pre> ad10f.var_names_make_unique() In\u00a0[10]: Copied! <pre>print(ad10f)\n</pre> print(ad10f) <pre>AnnData object with n_obs \u00d7 n_vars = 11769 \u00d7 33538\n    var: 'gene_ids', 'feature_types', 'genome'\n</pre> In\u00a0[11]: Copied! <pre>ad10f.shape\n</pre> ad10f.shape Out[11]: <pre>(11769, 33538)</pre> In\u00a0[8]: Copied! <pre>type(ad10f)\n</pre> type(ad10f) Out[8]: <pre>anndata._core.anndata.AnnData</pre> <p>Metadata are stored in:</p> <ul> <li>.obs for cells</li> <li>.var for genes</li> <li>.uns for unstructured metadata</li> </ul> <p>Let's look at .obs first</p> In\u00a0[12]: Copied! <pre>ad10f.obs\n</pre> ad10f.obs Out[12]: AAACCCAAGCGCCCAT-1 AAACCCAAGGTTCCGC-1 AAACCCACAGAGTTGG-1 AAACCCACAGGTATGG-1 AAACCCACATAGTCAC-1 ... TTTGTTGGTGTCATGT-1 TTTGTTGGTTTGAACC-1 TTTGTTGTCCAAGCCG-1 TTTGTTGTCTTACTGT-1 TTTGTTGTCTTCTAAC-1 <p>11769 rows \u00d7 0 columns</p> <p>We have not added any information so all that this slot holds now are cell barcodes. What about .var?</p> <p>ad10f.var</p> In\u00a0[\u00a0]: Copied! <pre>Here we can see that each row has a gene symbol, a gene ID from Ensembl, and some additional information about the gene and genome build.\n.var and .obs are Pandas data frames. To list all gene annotataions in .var:\n</pre> Here we can see that each row has a gene symbol, a gene ID from Ensembl, and some additional information about the gene and genome build. .var and .obs are Pandas data frames. To list all gene annotataions in .var:  In\u00a0[14]: Copied! <pre>ad10f.var.keys()\n</pre> ad10f.var.keys() Out[14]: <pre>Index(['gene_ids', 'feature_types', 'genome'], dtype='object')</pre> <p>You might be wondering where are the gene counts? They are stored in .X:</p> In\u00a0[15]: Copied! <pre>ad10f.X\n</pre> ad10f.X Out[15]: <pre>&lt;Compressed Sparse Row sparse matrix of dtype 'float32'\n\twith 24825783 stored elements and shape (11769, 33538)&gt;</pre> <p>Sparse data structures store only non-zero entries and their index to conserve RAM. Let's look at .X:</p> In\u00a0[18]: Copied! <pre># look at some non-zero values\nprint(ad10f.X.data)\n# what are their indices / positions?\nprint(ad10f.X.indices)\n# compute the fraction of non-zero entries\nprint(ad10f.X.nnz / np.prod(ad10f.X.shape))\n</pre> # look at some non-zero values print(ad10f.X.data) # what are their indices / positions? print(ad10f.X.indices) # compute the fraction of non-zero entries print(ad10f.X.nnz / np.prod(ad10f.X.shape)) <pre>[1. 4. 2. ... 1. 1. 1.]\n[33508 33505 33503 ...   166   154    95]\n0.0628964641931576\n</pre> In\u00a0[20]: Copied! <pre>ad10f.X.nnz\n</pre> ad10f.X.nnz <pre>Type:        property\nString form: &lt;property object at 0x13288bab0&gt;\nDocstring:  \nNumber of stored values, including explicit zeros.\n\nSee also\n--------\ncount_nonzero : Number of non-zero entries</pre> <p>Lots of times it is useful to have different versions or treansformations of the expression data. For example, later on in this tutorial we will normalize the expression data. To avoid overwriting the raw counts data, we can store it a different 'layer':</p> In\u00a0[23]: Copied! <pre>ad10f.layers['counts'] = ad10f.X.copy()\nad10f.layers\n</pre> ad10f.layers['counts'] = ad10f.X.copy() ad10f.layers Out[23]: <pre>Layers with keys: counts</pre> <p>.X is the default slot that scanpy functions will use but most functions have a <code>layer</code> parameter that allow you to specify another one if needed.</p> In\u00a0[26]: Copied! <pre>ad10f.obs_names\n</pre> ad10f.obs_names Out[26]: <pre>Index(['AAACCCAAGCGCCCAT-1', 'AAACCCAAGGTTCCGC-1', 'AAACCCACAGAGTTGG-1',\n       'AAACCCACAGGTATGG-1', 'AAACCCACATAGTCAC-1', 'AAACCCACATCCAATG-1',\n       'AAACCCAGTGGCTACC-1', 'AAACCCATCCCGAGAC-1', 'AAACCCATCTGGCCGA-1',\n       'AAACCCATCTGTTCAT-1',\n       ...\n       'TTTGTTGGTAGCACGA-1', 'TTTGTTGGTATCAGCT-1', 'TTTGTTGGTCGGTGAA-1',\n       'TTTGTTGGTCTGTAAC-1', 'TTTGTTGGTGCGTCGT-1', 'TTTGTTGGTGTCATGT-1',\n       'TTTGTTGGTTTGAACC-1', 'TTTGTTGTCCAAGCCG-1', 'TTTGTTGTCTTACTGT-1',\n       'TTTGTTGTCTTCTAAC-1'],\n      dtype='object', length=11769)</pre> In\u00a0[27]: Copied! <pre>ad10f.var_names\n</pre> ad10f.var_names Out[27]: <pre>Index(['MIR1302-2HG', 'FAM138A', 'OR4F5', 'AL627309.1', 'AL627309.3',\n       'AL627309.2', 'AL627309.4', 'AL732372.1', 'OR4F29', 'AC114498.1',\n       ...\n       'AC007325.2', 'BX072566.1', 'AL354822.1', 'AC023491.2', 'AC004556.1',\n       'AC233755.2', 'AC233755.1', 'AC240274.1', 'AC213203.1', 'FAM231C'],\n      dtype='object', length=33538)</pre> <p>To subset annData, just specfiy the cells and genes:</p> In\u00a0[29]: Copied! <pre>genes_monocyte = [\"CD14\", \"CD68\", \"LYZ\"]\nadSubset = ad10f[:10, genes_monocyte]\nadSubset.shape\n</pre> genes_monocyte = [\"CD14\", \"CD68\", \"LYZ\"] adSubset = ad10f[:10, genes_monocyte] adSubset.shape Out[29]: <pre>(10, 3)</pre> <p>Select cells that express CD14, CD68, and LYZ:</p> In\u00a0[36]: Copied! <pre>gene_mask = ad10f[:,genes_monocyte].X &gt; 0\ngene_mask = gene_mask.toarray()\npassing_cells = np.all(gene_mask, axis=1) # could use np.any to allow a cell expressing any of these genes to pass\nadMono = ad10f[passing_cells]\nadMono.shape\n</pre> gene_mask = ad10f[:,genes_monocyte].X &gt; 0 gene_mask = gene_mask.toarray() passing_cells = np.all(gene_mask, axis=1) # could use np.any to allow a cell expressing any of these genes to pass adMono = ad10f[passing_cells] adMono.shape Out[36]: <pre>(3262, 33538)</pre> <p>Other slots in adata:</p> <ul> <li>.obsm and .varm: multidimensional metadata</li> <li>.obsp and .varp: metadata on paired cells and paired genes</li> </ul> <p>We will revisit these later.</p> Views Views are pointers to memory where original anndata is stored. They are not copies of the variable.   <p>Let's add some cell metadata</p> In\u00a0[37]: Copied! <pre>ad10f.obs['sample_name'] = \"sample_1\"\nprint(ad10f.obs.columns)\n</pre> ad10f.obs['sample_name'] = \"sample_1\" print(ad10f.obs.columns) <pre>Index(['sample_name'], dtype='object')\n</pre> In\u00a0[38]: Copied! <pre>ad10f.var['mt'] = ad10f.var_names.str.startswith('MT-')\nribo_prefix = (\"RPS\",\"RPL\")\nad10f.var['ribo'] = ad10f.var_names.str.startswith(ribo_prefix)\nsc.pp.calculate_qc_metrics(ad10f, qc_vars=['mt','ribo'], percent_top=None, log1p=False, inplace=True)\n</pre> ad10f.var['mt'] = ad10f.var_names.str.startswith('MT-') ribo_prefix = (\"RPS\",\"RPL\") ad10f.var['ribo'] = ad10f.var_names.str.startswith(ribo_prefix) sc.pp.calculate_qc_metrics(ad10f, qc_vars=['mt','ribo'], percent_top=None, log1p=False, inplace=True) In\u00a0[39]: Copied! <pre>adClean = ad10f.copy()\n\nfig, (ax1, ax2, ax3) = plt.subplots(1, 3, figsize=(10,4), gridspec_kw={'wspace':0.25}, constrained_layout=True)\nax1_dict = sc.pl.scatter(adClean, x='total_counts', y='pct_counts_mt', ax=ax1, show=False)\nax2_dict = sc.pl.scatter(adClean, x='total_counts', y='n_genes_by_counts',ax=ax2, show=False)\nax3_dict = sc.pl.scatter(adClean, x='pct_counts_ribo', y='n_genes_by_counts',ax=ax3, show=False)\nplt.show()\n</pre> adClean = ad10f.copy()  fig, (ax1, ax2, ax3) = plt.subplots(1, 3, figsize=(10,4), gridspec_kw={'wspace':0.25}, constrained_layout=True) ax1_dict = sc.pl.scatter(adClean, x='total_counts', y='pct_counts_mt', ax=ax1, show=False) ax2_dict = sc.pl.scatter(adClean, x='total_counts', y='n_genes_by_counts',ax=ax2, show=False) ax3_dict = sc.pl.scatter(adClean, x='pct_counts_ribo', y='n_genes_by_counts',ax=ax3, show=False) plt.show() <p>Now, do the filtering.</p> <p>First, keep cells with fewer than 20% mitochondrially encoded gene total UMIs</p> In\u00a0[40]: Copied! <pre>adClean = adClean[adClean.obs['pct_counts_mt']&lt;20,:].copy()\nadClean.n_obs\n</pre> adClean = adClean[adClean.obs['pct_counts_mt']&lt;20,:].copy() adClean.n_obs Out[40]: <pre>11047</pre> <ul> <li>Second, filter based on total number of genes detected (at least 500).</li> <li>Third, filter based on total number of counts (fewer than than 30,000)</li> <li>Fourth, keep genes that are detected in at least 10 cells.</li> </ul> In\u00a0[43]: Copied! <pre>adClean.var_names_make_unique()\nsc.pp.filter_cells(adClean, min_genes=500)\nprint(adClean.n_obs)\n\nsc.pp.filter_cells(adClean, max_counts=30000)\nprint(adClean.n_obs)\n\nsc.pp.filter_genes(adClean, min_cells=10)\nprint(adClean.shape)\n</pre> adClean.var_names_make_unique() sc.pp.filter_cells(adClean, min_genes=500) print(adClean.n_obs)  sc.pp.filter_cells(adClean, max_counts=30000) print(adClean.n_obs)  sc.pp.filter_genes(adClean, min_cells=10) print(adClean.shape) <pre>10924\n10891\n(10891, 17422)\n</pre> In\u00a0[44]: Copied! <pre>adNorm = adClean.copy()\nsc.pp.normalize_total(adNorm , target_sum=1e4)\nsc.pp.log1p(adNorm)\nadNorm.layers['lognorm'] = adNorm.X.copy()\n</pre> adNorm = adClean.copy() sc.pp.normalize_total(adNorm , target_sum=1e4) sc.pp.log1p(adNorm) adNorm.layers['lognorm'] = adNorm.X.copy() In\u00a0[45]: Copied! <pre>n_hvg = 2000\nsc.pp.highly_variable_genes(adNorm, n_top_genes=n_hvg, flavor='cell_ranger')\n# sc.pp.highly_variable_genes(adNorm , min_mean=0.0125, max_mean=6, min_disp=0.25)\nadNorm.var\n</pre> n_hvg = 2000 sc.pp.highly_variable_genes(adNorm, n_top_genes=n_hvg, flavor='cell_ranger') # sc.pp.highly_variable_genes(adNorm , min_mean=0.0125, max_mean=6, min_disp=0.25) adNorm.var Out[45]: gene_ids feature_types genome mt ribo n_cells_by_counts mean_counts pct_dropout_by_counts total_counts n_cells highly_variable means dispersions dispersions_norm AL627309.1 ENSG00000238009 Gene Expression GRCh38 False False 60 0.005183 99.490186 61.0 60 False 0.004502 0.917161 -0.060098 AL669831.5 ENSG00000237491 Gene Expression GRCh38 False False 679 0.062367 94.230606 734.0 665 False 0.048407 0.856350 -0.258551 FAM87B ENSG00000177757 Gene Expression GRCh38 False False 13 0.001190 99.889540 14.0 13 False 0.000770 0.719899 -1.331091 LINC00115 ENSG00000225880 Gene Expression GRCh38 False False 350 0.031269 97.026085 368.0 337 False 0.024243 0.848471 -0.828740 FAM41C ENSG00000230368 Gene Expression GRCh38 False False 313 0.027190 97.340471 320.0 308 False 0.022719 0.883760 -0.320399 ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... AC011043.1 ENSG00000276256 Gene Expression GRCh38 False False 77 0.006882 99.345739 81.0 74 False 0.005875 0.988261 0.642865 AL592183.1 ENSG00000273748 Gene Expression GRCh38 False False 32 0.002719 99.728099 32.0 30 False 0.002267 0.978485 0.592432 AC007325.4 ENSG00000278817 Gene Expression GRCh38 False False 239 0.020902 97.969241 246.0 233 False 0.015576 0.787513 -1.681796 AL354822.1 ENSG00000278384 Gene Expression GRCh38 False False 319 0.028210 97.289489 332.0 303 False 0.023072 0.906420 0.006022 AC240274.1 ENSG00000271254 Gene Expression GRCh38 False False 101 0.008752 99.141813 103.0 99 False 0.006624 0.794754 -1.529179 <p>17422 rows \u00d7 14 columns</p> In\u00a0[46]: Copied! <pre>sc.pl.highly_variable_genes(adNorm)\n</pre> sc.pl.highly_variable_genes(adNorm) In\u00a0[47]: Copied! <pre>adNorm\n</pre> adNorm Out[47]: <pre>AnnData object with n_obs \u00d7 n_vars = 10891 \u00d7 17422\n    obs: 'sample_name', 'n_genes_by_counts', 'total_counts', 'total_counts_mt', 'pct_counts_mt', 'total_counts_ribo', 'pct_counts_ribo', 'n_genes', 'n_counts'\n    var: 'gene_ids', 'feature_types', 'genome', 'mt', 'ribo', 'n_cells_by_counts', 'mean_counts', 'pct_dropout_by_counts', 'total_counts', 'n_cells', 'highly_variable', 'means', 'dispersions', 'dispersions_norm'\n    uns: 'log1p', 'hvg'\n    layers: 'counts', 'lognorm'</pre> In\u00a0[48]: Copied! <pre>sc.tl.pca(adNorm , mask_var='highly_variable')\nadNorm\n</pre> sc.tl.pca(adNorm , mask_var='highly_variable') adNorm Out[48]: <pre>AnnData object with n_obs \u00d7 n_vars = 10891 \u00d7 17422\n    obs: 'sample_name', 'n_genes_by_counts', 'total_counts', 'total_counts_mt', 'pct_counts_mt', 'total_counts_ribo', 'pct_counts_ribo', 'n_genes', 'n_counts'\n    var: 'gene_ids', 'feature_types', 'genome', 'mt', 'ribo', 'n_cells_by_counts', 'mean_counts', 'pct_dropout_by_counts', 'total_counts', 'n_cells', 'highly_variable', 'means', 'dispersions', 'dispersions_norm'\n    uns: 'log1p', 'hvg', 'pca'\n    obsm: 'X_pca'\n    varm: 'PCs'\n    layers: 'counts', 'lognorm'</pre> In\u00a0[49]: Copied! <pre>sc.pl.pca_loadings(adNorm, components = [1,2,3,4], n_points=6, include_lowest=False)\n</pre> sc.pl.pca_loadings(adNorm, components = [1,2,3,4], n_points=6, include_lowest=False) In\u00a0[50]: Copied! <pre>sc.pl.pca_variance_ratio(adNorm, 50)\n</pre> sc.pl.pca_variance_ratio(adNorm, 50) In\u00a0[51]: Copied! <pre>markerGenes = ['CD14','CLEC4C', 'CD19',  'GNLY', 'CD3D']\nsc.pl.pca(adNorm , color=markerGenes, ncols=2, layer='counts')\n</pre> markerGenes = ['CD14','CLEC4C', 'CD19',  'GNLY', 'CD3D'] sc.pl.pca(adNorm , color=markerGenes, ncols=2, layer='counts') In\u00a0[52]: Copied! <pre>sc.pl.pca(adNorm , color=markerGenes, ncols=2)\n</pre> sc.pl.pca(adNorm , color=markerGenes, ncols=2) In\u00a0[53]: Copied! <pre>sc.pl.pca(adNorm, color=['total_counts', 'pct_counts_mt', 'pct_counts_ribo'], s=25,ncols=3)\n</pre> sc.pl.pca(adNorm, color=['total_counts', 'pct_counts_mt', 'pct_counts_ribo'], s=25,ncols=3) In\u00a0[54]: Copied! <pre>n_neighbors = 20\nn_pcs = 10\nsc.pp.neighbors(adNorm, n_neighbors=n_neighbors, n_pcs=n_pcs)\nadNorm\n</pre> n_neighbors = 20 n_pcs = 10 sc.pp.neighbors(adNorm, n_neighbors=n_neighbors, n_pcs=n_pcs) adNorm Out[54]: <pre>AnnData object with n_obs \u00d7 n_vars = 10891 \u00d7 17422\n    obs: 'sample_name', 'n_genes_by_counts', 'total_counts', 'total_counts_mt', 'pct_counts_mt', 'total_counts_ribo', 'pct_counts_ribo', 'n_genes', 'n_counts'\n    var: 'gene_ids', 'feature_types', 'genome', 'mt', 'ribo', 'n_cells_by_counts', 'mean_counts', 'pct_dropout_by_counts', 'total_counts', 'n_cells', 'highly_variable', 'means', 'dispersions', 'dispersions_norm'\n    uns: 'log1p', 'hvg', 'pca', 'neighbors'\n    obsm: 'X_pca'\n    varm: 'PCs'\n    layers: 'counts', 'lognorm'\n    obsp: 'distances', 'connectivities'</pre> In\u00a0[55]: Copied! <pre>sc.tl.umap(adNorm)\n</pre> sc.tl.umap(adNorm) In\u00a0[56]: Copied! <pre>sc.pl.umap(adNorm, color=markerGenes, alpha=.75, s=15, ncols=2)\n</pre> sc.pl.umap(adNorm, color=markerGenes, alpha=.75, s=15, ncols=2) <p>There are lots of ways to customize our plots. See the Scanpy visualization documentation for details. Here, lets change the colors and remove the boxes and axes labels.</p> In\u00a0[57]: Copied! <pre>sc.pl.umap(adNorm, color= genes_monocyte, alpha=.75, s=12, frameon=False, ncols=2, legend_fontoutline=2,legend_fontsize=14, cmap=\"Reds\")\n</pre> sc.pl.umap(adNorm, color= genes_monocyte, alpha=.75, s=12, frameon=False, ncols=2, legend_fontoutline=2,legend_fontsize=14, cmap=\"Reds\") In\u00a0[66]: Copied! <pre>clustering_name = \"leiden_cluster\"\nsc.tl.leiden(adNorm, 0.1, flavor=\"igraph\", n_iterations=2,key_added=clustering_name)\n</pre> clustering_name = \"leiden_cluster\" sc.tl.leiden(adNorm, 0.1, flavor=\"igraph\", n_iterations=2,key_added=clustering_name) In\u00a0[67]: Copied! <pre>sc.pl.umap(adNorm, color=[clustering_name], alpha=.75, s=9, legend_loc='on data', frameon=False, ncols=1, legend_fontoutline=2,legend_fontsize=11, cmap=\"Reds\", use_raw=False)\n</pre> sc.pl.umap(adNorm, color=[clustering_name], alpha=.75, s=9, legend_loc='on data', frameon=False, ncols=1, legend_fontoutline=2,legend_fontsize=11, cmap=\"Reds\", use_raw=False) <p>Make a figure that shows the embedding and expression of marker genes side-by-side. Note that I am adding markers for T cell, B cell, and Monocyte sub-types</p> In\u00a0[71]: Copied! <pre>marker_genes_broad_dict = {\n    'B cell': ['CD79A', 'PAX5'],\n    'Dendritic': ['CLEC4C', 'FCER1A'],\n    'Monocyte': ['CSF1R', 'FCGR3A'],\n    'NK cell': ['NKG7', 'GNLY'],\n    'T cell': ['TRAC', 'CD3E'],\n}\nsc.tl.dendrogram(adNorm, groupby=clustering_name)\n\n\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10,4), gridspec_kw={'wspace':0.25})\nax1_dict = sc.pl.umap(adNorm,color=[clustering_name], alpha=.75, s=10, legend_loc='on data', ax=ax1, show=False)\nax2_dict = sc.pl.dotplot(adNorm, marker_genes_broad_dict, groupby=clustering_name, dendrogram=True,ax=ax2, show=False)\nplt.show()\n</pre> marker_genes_broad_dict = {     'B cell': ['CD79A', 'PAX5'],     'Dendritic': ['CLEC4C', 'FCER1A'],     'Monocyte': ['CSF1R', 'FCGR3A'],     'NK cell': ['NKG7', 'GNLY'],     'T cell': ['TRAC', 'CD3E'], } sc.tl.dendrogram(adNorm, groupby=clustering_name)   fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10,4), gridspec_kw={'wspace':0.25}) ax1_dict = sc.pl.umap(adNorm,color=[clustering_name], alpha=.75, s=10, legend_loc='on data', ax=ax1, show=False) ax2_dict = sc.pl.dotplot(adNorm, marker_genes_broad_dict, groupby=clustering_name, dendrogram=True,ax=ax2, show=False) plt.show() <pre>WARNING: Groups are not reordered because the `groupby` categories and the `var_group_labels` are different.\ncategories: 0, 1, 2, etc.\nvar_group_labels: B cell, Dendritic, Monocyte, etc.\n</pre> In\u00a0[48]: Copied! <pre>sc.tl.leiden(adNorm,.1, restrict_to=[\"leiden\",[\"5\"]])\nsc.tl.dendrogram(adNorm, \"leiden_R\")\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10,4), gridspec_kw={'wspace':0.25})\nax1_dict = sc.pl.umap(adNorm,color=['leiden_R'], alpha=.75, s=10, legend_loc='on data', ax=ax1, show=False)\nax2_dict = sc.pl.dotplot(adNorm, marker_genes_broad_dict, 'leiden_R', dendrogram=True,ax=ax2, show=False)\nplt.show()\n</pre> sc.tl.leiden(adNorm,.1, restrict_to=[\"leiden\",[\"5\"]]) sc.tl.dendrogram(adNorm, \"leiden_R\") fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10,4), gridspec_kw={'wspace':0.25}) ax1_dict = sc.pl.umap(adNorm,color=['leiden_R'], alpha=.75, s=10, legend_loc='on data', ax=ax1, show=False) ax2_dict = sc.pl.dotplot(adNorm, marker_genes_broad_dict, 'leiden_R', dendrogram=True,ax=ax2, show=False) plt.show() <pre>WARNING: Groups are not reordered because the `groupby` categories and the `var_group_labels` are different.\ncategories: 0, 1, 2, etc.\nvar_group_labels: B cell, Dendritic, Monocyte, etc.\n</pre> <p>Cluster 5 is split into 2 clusters now. Both of these sub-clusters express the Monocyte marker CD14, but are distinguished by their expression of dendritic marker FCER1A and the B cell genes CD79A and PAX5. Let's look at the QC metrics to see if that can give us additional hints as to whether these are real cells or are doublets.</p> In\u00a0[49]: Copied! <pre>sc.pl.violin(adNorm, ['total_counts'], groupby='leiden_R' )\n</pre> sc.pl.violin(adNorm, ['total_counts'], groupby='leiden_R' ) <p>Cluster 5 (and each sub-cluster) has a high number of Total counts. So let's annotate these as 'doublet'.</p> <p>What about the other questionable clusters 4 and 2? Can we refine those?</p> In\u00a0[50]: Copied! <pre># cluster 2 first\nsc.tl.leiden(adNorm,.05, restrict_to=[\"leiden\",[\"2\"]])\nsc.tl.dendrogram(adNorm, \"leiden_R\")\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10,4), gridspec_kw={'wspace':0.25})\nax1_dict = sc.pl.umap(adNorm,color=['leiden_R'], alpha=.75, s=10, legend_loc='on data', ax=ax1, show=False)\nax2_dict = sc.pl.dotplot(adNorm, marker_genes_broad_dict, 'leiden_R', dendrogram=True,ax=ax2, show=False)\nplt.show()\n</pre> # cluster 2 first sc.tl.leiden(adNorm,.05, restrict_to=[\"leiden\",[\"2\"]]) sc.tl.dendrogram(adNorm, \"leiden_R\") fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10,4), gridspec_kw={'wspace':0.25}) ax1_dict = sc.pl.umap(adNorm,color=['leiden_R'], alpha=.75, s=10, legend_loc='on data', ax=ax1, show=False) ax2_dict = sc.pl.dotplot(adNorm, marker_genes_broad_dict, 'leiden_R', dendrogram=True,ax=ax2, show=False) plt.show() <pre>WARNING: Groups are not reordered because the `groupby` categories and the `var_group_labels` are different.\ncategories: 0, 1, 2,0, etc.\nvar_group_labels: B cell, Dendritic, Monocyte, etc.\n</pre> <p>It looks like 2,0 is T cell, and 2,1 is Natural Killer cell. Note that 2,0 still has a distinct profile as compared to 0.</p> <p>What about cluster 4? And this time, when we do the sub-clustering, let's keep the way that we split up cluster 2.</p> In\u00a0[51]: Copied! <pre>sc.tl.leiden(adNorm,.1, restrict_to=[\"leiden_R\",[\"4\"]])\nsc.tl.dendrogram(adNorm, \"leiden_R\")\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10,4), gridspec_kw={'wspace':0.25})\nax1_dict = sc.pl.umap(adNorm,color=['leiden_R'], alpha=.75, s=10, legend_loc='on data', ax=ax1, show=False)\nax2_dict = sc.pl.dotplot(adNorm, marker_genes_broad_dict, 'leiden_R', dendrogram=True,ax=ax2, show=False)\nplt.show()\n</pre> sc.tl.leiden(adNorm,.1, restrict_to=[\"leiden_R\",[\"4\"]]) sc.tl.dendrogram(adNorm, \"leiden_R\") fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10,4), gridspec_kw={'wspace':0.25}) ax1_dict = sc.pl.umap(adNorm,color=['leiden_R'], alpha=.75, s=10, legend_loc='on data', ax=ax1, show=False) ax2_dict = sc.pl.dotplot(adNorm, marker_genes_broad_dict, 'leiden_R', dendrogram=True,ax=ax2, show=False) plt.show() <pre>WARNING: Groups are not reordered because the `groupby` categories and the `var_group_labels` are different.\ncategories: 0, 1, 2,0, etc.\nvar_group_labels: B cell, Dendritic, Monocyte, etc.\n</pre> <p>Is 4,1 multiplet?</p> In\u00a0[52]: Copied! <pre>sc.pl.violin(adNorm, ['total_counts', 'n_genes_by_counts'], groupby='leiden_R' )\n</pre> sc.pl.violin(adNorm, ['total_counts', 'n_genes_by_counts'], groupby='leiden_R' ) <p>Yes, it looks like 4,1 is similar in these QC profiles to cluster 5.</p> <p>So our updated annotation table is now:</p> cluster markers  of cell type 5 B, Dendritic, Mono doublet 1 Monocyte Monocyte 4,0 Monocyte Monocyte 3 B B-cell 6 Dendritic (B/Mono?) Dendritic cell 7 none Mystery cell 0 T cell T cell 2,0 T cell T cell 2,1 NK cell NK cell <p>Why do we have two Monocyte clusters and two T cells clusters?</p> In\u00a0[53]: Copied! <pre>marker_genes_sub_dict = {\n    'B cell': ['CD79A'],\n    'Dendritic': ['CLEC4C'],\n    'CD14 monocyte': ['CD14'],\n    'CD16 monocyte': ['FCGR3A'],\n    'NK cell': ['GNLY'],\n    'CD4 T cell': ['CD4', 'GATA3'],\n    'CD8 T cell': ['CD8A', 'EOMES']\n}\n\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10,4), gridspec_kw={'wspace':0.25})\nax1_dict = sc.pl.umap(adNorm,color=['leiden_R'], alpha=.75, s=10, legend_loc='on data', ax=ax1, show=False)\nax2_dict = sc.pl.dotplot(adNorm, marker_genes_sub_dict, 'leiden_R', dendrogram=True,ax=ax2, show=False)\nplt.show()\n</pre> marker_genes_sub_dict = {     'B cell': ['CD79A'],     'Dendritic': ['CLEC4C'],     'CD14 monocyte': ['CD14'],     'CD16 monocyte': ['FCGR3A'],     'NK cell': ['GNLY'],     'CD4 T cell': ['CD4', 'GATA3'],     'CD8 T cell': ['CD8A', 'EOMES'] }  fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10,4), gridspec_kw={'wspace':0.25}) ax1_dict = sc.pl.umap(adNorm,color=['leiden_R'], alpha=.75, s=10, legend_loc='on data', ax=ax1, show=False) ax2_dict = sc.pl.dotplot(adNorm, marker_genes_sub_dict, 'leiden_R', dendrogram=True,ax=ax2, show=False) plt.show() <pre>WARNING: Groups are not reordered because the `groupby` categories and the `var_group_labels` are different.\ncategories: 0, 1, 2,0, etc.\nvar_group_labels: B cell, Dendritic, CD14 monocyte, etc.\n</pre> <p>We are close to a final annotation now:</p> cluster markers  of cell type 5 B, Dendritic, Mono doublet 1 Monocyte CD14 Monocyte 4,0 Monocyte CD16 Monocyte 3 B B-cell 6 Dendritic (B/Mono?) Dendritic cell 7 none Mystery cell 0 T cell CD4 T cell 2,0 T cell CD8 T cell 2,1 NK cell NK cell <p>But what is cluster 7? It has low counts. If it is just ambient 'soup', then we would not expect it to have high levels of cell type specific genes. Let's do differential gene expression analysis to see what is upregulated in this cluster.</p> In\u00a0[54]: Copied! <pre>sc.tl.rank_genes_groups(adNorm, use_raw=False, groupby=\"leiden_R\")\n</pre> sc.tl.rank_genes_groups(adNorm, use_raw=False, groupby=\"leiden_R\") In\u00a0[55]: Copied! <pre>sc.pl.rank_genes_groups_dotplot(adNorm, n_genes=5, groupby=\"leiden_R\", dendrogram=True, key='rank_genes_groups')\n</pre> sc.pl.rank_genes_groups_dotplot(adNorm, n_genes=5, groupby=\"leiden_R\", dendrogram=True, key='rank_genes_groups') In\u00a0[56]: Copied! <pre>sc.pl.rank_genes_groups_dotplot(adNorm, n_genes=20, groupby=\"leiden_R\", dendrogram=True, key='rank_genes_groups', groups=['7'])\n</pre> sc.pl.rank_genes_groups_dotplot(adNorm, n_genes=20, groupby=\"leiden_R\", dendrogram=True, key='rank_genes_groups', groups=['7']) <pre>WARNING: Groups are not reordered because the `groupby` categories and the `var_group_labels` are different.\ncategories: 0, 1, 2,0, etc.\nvar_group_labels: 7\n</pre> <p>Although this result could be refined and explored a lot, it is sufficient for us to address our question about the identity of cluster 7 as follows:</p> Help from ChatGPT to annotate cells <p>Now, let's add the annotation to the anndata.obs and discard the other cells</p> cluster markers  of cell type 1 Monocyte CD14 Monocyte 4,0 Monocyte CD16 Monocyte 3 B B-cell 6 Dendritic (B/Mono?) Dendritic cell 7 none Platelet 0 T cell CD4 T cell 2,0 T cell CD8 T cell 2,1 NK cell NK cell In\u00a0[57]: Copied! <pre>tokeep = [\"1\", \"4,0\", \"3\", \"6\", \"7\", \"0\", \"2,0\", \"2,1\"]\nadNorm2 = adNorm.copy()\nadNorm2 = adNorm2[adNorm2.obs['leiden_R'].isin(tokeep)].copy()\nadNorm2.shape\nadNorm2.obs['leiden_R'].value_counts()\n</pre> tokeep = [\"1\", \"4,0\", \"3\", \"6\", \"7\", \"0\", \"2,0\", \"2,1\"] adNorm2 = adNorm.copy() adNorm2 = adNorm2[adNorm2.obs['leiden_R'].isin(tokeep)].copy() adNorm2.shape adNorm2.obs['leiden_R'].value_counts() Out[57]: <pre>leiden_R\n0      3563\n1      3115\n3      1604\n2,0    1031\n2,1     611\n4,0     368\n6        81\n7        60\nName: count, dtype: int64</pre> In\u00a0[58]: Copied! <pre>cell_dict = {'Dendritic': ['6'],\n             'CD14 Monocyte': ['1'],\n             'CD16 Monocyte': [\"4,0\"],\n             'B cell': ['3'],\n             'Platelet': ['7'],\n             'CD4 T cell': ['0'],\n             'CD8 T cell': [\"2,0\"],\n             'NK cell': [\"2,1\"]\n}\n\nmarker_genes_dict = {\n    'B cell': ['CD79A'],\n    'Dendritic': ['CLEC4C'],\n    'CD14 monocyte': ['CD14'],\n    'CD16 monocyte': ['FCGR3A'],\n    'NK cell': ['GNLY'],\n    'CD4 T cell': ['CD4', 'GATA3'],\n    'CD8 T cell': ['CD8A', 'EOMES'],\n    'Platelet': ['PF4', 'CAVIN2']\n}\n\n\nnew_obs_name = 'cell_type'\nadNorm2.obs[new_obs_name] = np.nan\n\nfor i in cell_dict.keys():\n    ind = pd.Series(adNorm2.obs.leiden_R).isin(cell_dict[i])\n    adNorm2.obs.loc[ind,new_obs_name] = i\n\nadNorm2.obs['cell_type'] = adNorm2.obs['cell_type'].astype(\"category\")\n</pre> cell_dict = {'Dendritic': ['6'],              'CD14 Monocyte': ['1'],              'CD16 Monocyte': [\"4,0\"],              'B cell': ['3'],              'Platelet': ['7'],              'CD4 T cell': ['0'],              'CD8 T cell': [\"2,0\"],              'NK cell': [\"2,1\"] }  marker_genes_dict = {     'B cell': ['CD79A'],     'Dendritic': ['CLEC4C'],     'CD14 monocyte': ['CD14'],     'CD16 monocyte': ['FCGR3A'],     'NK cell': ['GNLY'],     'CD4 T cell': ['CD4', 'GATA3'],     'CD8 T cell': ['CD8A', 'EOMES'],     'Platelet': ['PF4', 'CAVIN2'] }   new_obs_name = 'cell_type' adNorm2.obs[new_obs_name] = np.nan  for i in cell_dict.keys():     ind = pd.Series(adNorm2.obs.leiden_R).isin(cell_dict[i])     adNorm2.obs.loc[ind,new_obs_name] = i  adNorm2.obs['cell_type'] = adNorm2.obs['cell_type'].astype(\"category\")   <pre>/var/folders/1_/v5grqr5n7kj42276bb6ryxj00000gn/T/ipykernel_66578/4042500018.py:28: FutureWarning: Setting an item of incompatible dtype is deprecated and will raise an error in a future version of pandas. Value 'Dendritic' has dtype incompatible with float64, please explicitly cast to a compatible dtype first.\n  adNorm2.obs.loc[ind,new_obs_name] = i\n</pre> In\u00a0[59]: Copied! <pre>sc.tl.dendrogram(adNorm2, \"cell_type\")\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12,5), gridspec_kw={'wspace':0.4})\nax1_dict = sc.pl.umap(adNorm2,color=['cell_type'], alpha=.75, s=10, legend_loc='on data', ax=ax1, show=False)\nax2_dict = sc.pl.dotplot(adNorm2, marker_genes_dict, 'cell_type', dendrogram=True,ax=ax2, show=False)\nplt.show()\n</pre> sc.tl.dendrogram(adNorm2, \"cell_type\") fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12,5), gridspec_kw={'wspace':0.4}) ax1_dict = sc.pl.umap(adNorm2,color=['cell_type'], alpha=.75, s=10, legend_loc='on data', ax=ax1, show=False) ax2_dict = sc.pl.dotplot(adNorm2, marker_genes_dict, 'cell_type', dendrogram=True,ax=ax2, show=False) plt.show()  <pre>WARNING: Groups are not reordered because the `groupby` categories and the `var_group_labels` are different.\ncategories: B cell, CD14 Monocyte, CD16 Monocyte, etc.\nvar_group_labels: B cell, Dendritic, CD14 monocyte, etc.\n</pre> In\u00a0[60]: Copied! <pre>sc.pl.pca(adNorm2, color=['cell_type', 'GNLY'], alpha=.75, s=15, projection='3d')\n</pre> sc.pl.pca(adNorm2, color=['cell_type', 'GNLY'], alpha=.75, s=15, projection='3d') In\u00a0[61]: Copied! <pre>sc.tl.rank_genes_groups(adNorm2, use_raw=False, groupby=\"cell_type\")\n</pre> sc.tl.rank_genes_groups(adNorm2, use_raw=False, groupby=\"cell_type\") In\u00a0[62]: Copied! <pre>sc.tl.filter_rank_genes_groups(adNorm2, min_fold_change=.7, min_in_group_fraction=.5, max_out_group_fraction=.15)\nsc.pl.rank_genes_groups_dotplot(adNorm2, n_genes=6, groupby=\"cell_type\", dendrogram=True, key='rank_genes_groups_filtered')\n</pre> sc.tl.filter_rank_genes_groups(adNorm2, min_fold_change=.7, min_in_group_fraction=.5, max_out_group_fraction=.15) sc.pl.rank_genes_groups_dotplot(adNorm2, n_genes=6, groupby=\"cell_type\", dendrogram=True, key='rank_genes_groups_filtered')"},{"location":"notebooks/scBasics.html#overview","title":"Overview\u00b6","text":"<ol> <li>Google</li> <li>Hematopoiesis</li> <li>CellRanger</li> <li>Scanpy and AnnData</li> <li>Quality control, Normalization</li> <li>Dimensionality reduction with PCA</li> <li>Cell-cell distances</li> <li>Unsupervised clustering with Leiden</li> </ol>"},{"location":"notebooks/scBasics.html#google-colab","title":"Google Colab\u00b6","text":"<ul> <li>For a simple intro see https://compscbio.github.io/cscb2026/notebooks/colab.html</li> <li>Cloud compute resource</li> <li>To sign up for free educational user account: https://colab.research.google.com/signup</li> <li>To start using Colab directly: https://colab.research.google.com/#</li> <li>You can launch a copy of the notebook that you are feasting your eyes upon now in Colab by selecting File -&gt; Open Notebook -&gt; GitHub, then copy and paste this URL into the search field: https://github.com/compscbio/cscb2026/blob/gh-pages/notebooks/scBasics.ipynb</li> </ul>"},{"location":"notebooks/scBasics.html#background-on-the-data","title":"Background on the data\u00b6","text":"<p>Let's start with some background + motivation for the data set that we are going to analyze: hematopoietic cells from peripheral blood.</p>"},{"location":"notebooks/scBasics.html#hematopoiesis","title":"Hematopoiesis\u00b6","text":"Traditional model of hematopoiesis. Image from Slack 2017 <p>These cells are produced in the bone marrow and then move into the vascular so that they can move about the body and perform their functions (transport oxygen, clot, do adaptive and innate immune things).</p>"},{"location":"notebooks/scBasics.html#peripheral-blood-mononuclear-cells-pbmcs","title":"Peripheral blood mononuclear cells (PBMCs)\u00b6","text":"<p>It is possible to enrich for what are called PBMCs that have been taken from from a donor's vein, and then performing density gradient centrifugation. This process enriches for cells that have a single, round nucleus, and it excludes other stuff. PBMCs typically contain:</p> <p>... several classes of immune cells, including T cells (~70%), B cells (~15%), monocytes (~5%), dendritic cells (~1%) and natural killer (NK) cells (~10%)     --  Sen et al 2019</p> <p>and</p> <p>... The CD3+ lymphocytes are composed of CD4+ and CD8+ T cells, roughly in a 2:1 ratio.     -- Kleiveland, 2015</p>"},{"location":"notebooks/scBasics.html#some-questions-we-can-explore","title":"Some questions we can explore\u00b6","text":"<ul> <li>What does scRNAseq estimate as the relative cell type proportions?</li> <li>Are there other genes that are better at distinguishing between these populations than marker genes listed below?</li> <li>How many cells do you need to reliably detect a sub-population?</li> </ul>"},{"location":"notebooks/scBasics.html#data","title":"Data\u00b6","text":"<ul> <li>10X Genomics scRNA-seq on human PBMCs from a healthy donor</li> <li>About 10,000 cells</li> <li>http://cf.10xgenomics.com/samples/cell-exp/1.1.0/pbmc3k/pbmc3k_filtered_gene_bc_matrices.tar.gz</li> </ul>"},{"location":"notebooks/scBasics.html#cellranger","title":"CellRanger\u00b6","text":"<p>CellRanger is the program that converts sequencing reads into gene expression counts.</p> CellRanger flow chart from 10X genomics"},{"location":"notebooks/scBasics.html#umi-counting","title":"UMI counting\u00b6","text":"<ul> <li>group reads with same cell bc, umi, gene</li> <li>correct umis (one base off)</li> <li>cell bc, umi, diff gene -&gt; only keep gene with most support</li> <li>discard both if tied</li> <li>all reads with same cell bc, umi, gene are counted as one UMI</li> <li>number of reads contributing to that UMI are stored in molecule info file (useful later)</li> </ul>"},{"location":"notebooks/scBasics.html#setting-up-our-colab-environment","title":"Setting up our Colab environment\u00b6","text":"<p>Note that lines starting with <code>!</code> send the remaining line to the shell</p>"},{"location":"notebooks/scBasics.html#fetch-the-data","title":"Fetch the data\u00b6","text":""},{"location":"notebooks/scBasics.html#set-up-our-python-session","title":"Set up our Python session\u00b6","text":""},{"location":"notebooks/scBasics.html#load-sample-1","title":"Load Sample 1\u00b6","text":""},{"location":"notebooks/scBasics.html#getting-information-about-functions","title":"Getting information about functions\u00b6","text":"<p>You can get info about functions using</p> <p>help(functionName)</p> <p>or</p> <p>?functionName</p>"},{"location":"notebooks/scBasics.html#package-documentation","title":"Package documentation\u00b6","text":"<p>Often, the best source of help is the package's documentation.</p> <p>Scanpy's documentation</p>"},{"location":"notebooks/scBasics.html#anndata","title":"AnnData\u00b6","text":""},{"location":"notebooks/scBasics.html#anndata","title":"AnnData\u00b6","text":"<p>AnnData is a Python package that defines a data structure designed to efficiently store large data sets like scRNA-seq.</p> AnnData schema. AnnData documentation. See Resouces below for more"},{"location":"notebooks/scBasics.html#selecting-genes-and-cells","title":"Selecting genes and cells\u00b6","text":"<p>obs_names and var_names are indicies into .obs and .var and .X.</p>"},{"location":"notebooks/scBasics.html#quality-control-qc","title":"Quality Control (QC)\u00b6","text":"<p>Broadly speaking there are two things that we apply quality control to:</p> <ol> <li>Cells: We want to find putative doublets and low quality cell barcodes and ehold them out of downstream analysis (or at least tag them).</li> <li>Genes: We also can remove genes that are not detected in the vast majority of cell</li> </ol> <p>The function <code>sc.pp.calculate_qc_metrics()</code> will calculate a set of metrics on adata and places the results in .obs and .var. The results can then be used to filter the adata. <code>pp.calculate_qc_metrics()</code> can also take inputs to specify other, custom metrics to compute. Below, we use it to compute the fraction of all UMIs in each cell that are mitochondrially encoded or that encode for ribosomal genes.</p>"},{"location":"notebooks/scBasics.html#visualize","title":"Visualize\u00b6","text":"<p>Take a look some typical QC values across these data</p>"},{"location":"notebooks/scBasics.html#normalization","title":"Normalization\u00b6","text":"<p>Simple library size scaling, then log transform. There are many other ways to correct for cell-to-cell technical variation, for example different cell lysis efficiencies, but this method is good enough for this data set and our goals.</p>"},{"location":"notebooks/scBasics.html#highly-variable-genes-hvg","title":"Highly variable genes (HVG)\u00b6","text":"<p>It is common practice to limit some parts of analysis to those variables/genes that exhibit some degree of variation in their values across the data. We call these highly variable genes, or HVG for short. To find these, calculate some gene statistics, which when combined with thresholds below, determine which genes are considered HVG. The relevant metrics are:</p> <ol> <li>mean expression</li> <li>dispersion, which is the variance / mean.</li> </ol> <p>Variance is defined as the expected squared deviation of gene expression. The normalized dispersion is calculated by scaling based on a bin of mean expression.</p>"},{"location":"notebooks/scBasics.html#dimensionality-reduction-with-principal-components-analysis-pca","title":"Dimensionality reduction with Principal components analysis (PCA)\u00b6","text":"<p>Why performan dimentaionality reduction?</p> <ol> <li>Genes are expressed in coordinated fashion, meaning that many have correlated expression patterns and so PCA reduces the computational complexity of downstream analysis</li> <li>scRNA-seq data is noisy on a per gene basis.</li> </ol> <p>PCA allows us to reduce a high dimensional data set into a lower dimension in which much of the total variation is maintained. To understand PCA, you need to know linear algebra. In essence, it identifies sets of linear combinations of genes in such a way that a PC is uncorrelated with other PCs and that explains most variation in the data. The function call <code>sc.tl.pca</code> does the following:</p> <ol> <li>computes the covariance matrix (correlation between each pair of genes)</li> <li>finds eigenvectors (directions of axes that maximize that variance), orthogonal to each other</li> </ol> <p>Later, we select a threshold (n_pcs) as the number of PCs that contribute most to the total variation on our data. We use these n_pcs PCs to compute cell-to-cell distances for embedding (2D visualization via UMAP) and for clustering of cells.</p>"},{"location":"notebooks/scBasics.html#marker-genes","title":"Marker genes\u00b6","text":"<p>Here PBMC cell types and some genes that have been used to identify them: Monocytes: CD14, CD68, LYZ Dendritic: CLEC4C, FLT3 NK cells: GNLY, NCAM1 B cells: CD19, CD79A, CD79B T cells: CD3D, CD3E, TRAC, TRBC</p>"},{"location":"notebooks/scBasics.html#knn-cell-cell-distances","title":"kNN cell-cell distances\u00b6","text":"<p>The k-nearest neighbor graph generates an adjacency matrix by finding, for each cell, the k cells that are closest to it. This helps to reduce noise in computing cell-cell distances or similarities and is important for embedding the cells in a 2D space, and for community detection algorithms. Two arguments are n_neighbors, or k, and the number of PCs to use when computing cell-cell distances.</p>"},{"location":"notebooks/scBasics.html#visualization-of-cell-cell-similarities","title":"Visualization of cell-cell similarities\u00b6","text":""},{"location":"notebooks/scBasics.html#umap-embedding","title":"UMAP embedding\u00b6","text":"<p>This an elaboration on the t-SNE embedding approach. Both of these methods try to project cells into a reduced (typically 2) dimensional coordinate system while maintaining both the global and local structure of the high dimensional space of the data (i.e. cells that are distant from each other high dimensions should still be distant in the reduced embedding; same is true for cells that are near each other). The distances come from the kNN graph.</p>"},{"location":"notebooks/scBasics.html#unsupervised-clustering","title":"Unsupervised clustering\u00b6","text":"<p>Let's try to assign cells to distinct groups or clusters based on the cell-to-cell distances. Leiden and Louvain are examples of community detection methods that perform this task by searching for the group assignment that maximize within group similarity (which is equivalent to within group edges of a knn graph) and to minimize between group similarity.</p>"},{"location":"notebooks/scBasics.html#stop-here-for-now","title":"STOP HERE FOR NOW\u00b6","text":""},{"location":"notebooks/scBasics.html#cluster-annotation","title":"Cluster annotation\u00b6","text":"<p>We can walk down the rows of the dotplot and guess at the cell types of some of these clusters based on the specificty of marker expression:</p> cluster markers  of cell type 5 B, Dendritic, Mono ??? 1 Monocyte Monocyte 4 Monocyte, T ??? 3 B B-cell 6 Dendritic (B/Mono?) Dendritic cell 7 none Mystery cell 0 T cell T cell 2 NK/T ??? <p>Some clusters are ambiguous because they express markers of more than one cell type. This could be due to the cluster containing &gt; 1 cell type, or because the cell barcodes are doublets. If the former, then we should be able to sub cluster them. Let's try this.</p> <p>Clusters to refine are 5, 4, and 2.</p>"},{"location":"notebooks/scBasics.html#differential-gene-expression","title":"Differential gene expression\u00b6","text":""},{"location":"notebooks/scBasics.html#differential-expression-analysis","title":"Differential expression analysis\u00b6","text":"<p>Let's identify genes that are preferenntially expressed in each cluster versus all the others as a final step to annotate these clusters and to remove ones that are likely to be doublets.</p>"},{"location":"notebooks/scBasics.html#dot-plot-of-differentially-expressed-genes","title":"Dot plot of differentially expressed genes\u00b6","text":"<p>First, we will apply a filter so that we only display genes that meet additional criteria beyond statistical: fold change, % expressed in cluster, % expressed in other cells</p>"},{"location":"notebooks/scBasics.html#resources","title":"Resources\u00b6","text":""},{"location":"notebooks/scBasics.html#tools","title":"Tools\u00b6","text":"<ul> <li>Colab<ul> <li>https://colab.research.google.com/</li> </ul> </li> <li>Jupyter<ul> <li>https://jupyter.org/</li> </ul> </li> <li>CellRanger<ul> <li>https://www.10xgenomics.com/support/software/cell-ranger/latest/advanced/cr-barcode-rank-plot</li> <li>https://www.10xgenomics.com/support/software/cell-ranger/latest/algorithms-overview/cr-gex-algorithm</li> </ul> </li> </ul>"},{"location":"notebooks/scBasics.html#literature","title":"Literature\u00b6","text":"<ul> <li>Best practices<ul> <li>best practices in sc analysis online book</li> <li>paper associated with the above online book</li> </ul> </li> <li>Scanpy<ul> <li>https://scanpy.readthedocs.io/en/stable/</li> <li>https://scanpy.readthedocs.io/en/stable/tutorials.html</li> <li>https://scanpy-tutorials.readthedocs.io/en/latest/pbmc3k.html</li> <li>https://scanpy-tutorials.readthedocs.io/en/latest/plotting/advanced.html</li> <li>https://scanpy-tutorials.readthedocs.io/en/latest/plotting/core.html</li> </ul> </li> <li>AnnData<ul> <li>https://anndata.readthedocs.io/en/latest/tutorials/notebooks/getting-started.html</li> <li>https://anndata.readthedocs.io/en/latest/index.html</li> </ul> </li> <li>QC<ul> <li>https://genomebiology.biomedcentral.com/articles/10.1186/s13059-020-02136-7</li> </ul> </li> </ul>"},{"location":"notebooks/scBasics_2.html","title":"scRNA-seq 2","text":"In\u00a0[1]: Copied! <pre>import scanpy as sc\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport warnings\nwarnings.filterwarnings('ignore')\n</pre> import scanpy as sc import numpy as np import pandas as pd import matplotlib.pyplot as plt import warnings warnings.filterwarnings('ignore') <pre>/opt/homebrew/Caskroom/miniforge/base/envs/autocluster/lib/python3.12/site-packages/anndata/utils.py:429: FutureWarning: Importing read_csv from `anndata` is deprecated. Import anndata.io.read_csv instead.\n  warnings.warn(msg, FutureWarning)\n/opt/homebrew/Caskroom/miniforge/base/envs/autocluster/lib/python3.12/site-packages/anndata/utils.py:429: FutureWarning: Importing read_excel from `anndata` is deprecated. Import anndata.io.read_excel instead.\n  warnings.warn(msg, FutureWarning)\n/opt/homebrew/Caskroom/miniforge/base/envs/autocluster/lib/python3.12/site-packages/anndata/utils.py:429: FutureWarning: Importing read_hdf from `anndata` is deprecated. Import anndata.io.read_hdf instead.\n  warnings.warn(msg, FutureWarning)\n/opt/homebrew/Caskroom/miniforge/base/envs/autocluster/lib/python3.12/site-packages/anndata/utils.py:429: FutureWarning: Importing read_loom from `anndata` is deprecated. Import anndata.io.read_loom instead.\n  warnings.warn(msg, FutureWarning)\n/opt/homebrew/Caskroom/miniforge/base/envs/autocluster/lib/python3.12/site-packages/anndata/utils.py:429: FutureWarning: Importing read_mtx from `anndata` is deprecated. Import anndata.io.read_mtx instead.\n  warnings.warn(msg, FutureWarning)\n/opt/homebrew/Caskroom/miniforge/base/envs/autocluster/lib/python3.12/site-packages/anndata/utils.py:429: FutureWarning: Importing read_text from `anndata` is deprecated. Import anndata.io.read_text instead.\n  warnings.warn(msg, FutureWarning)\n/opt/homebrew/Caskroom/miniforge/base/envs/autocluster/lib/python3.12/site-packages/anndata/utils.py:429: FutureWarning: Importing read_umi_tools from `anndata` is deprecated. Import anndata.io.read_umi_tools instead.\n  warnings.warn(msg, FutureWarning)\n</pre> In\u00a0[2]: Copied! <pre># change this to the path that works for you\nad10f = sc.read_10x_h5(\"../../../data/pbmc_10k_v3_filtered_feature_bc_matrix.h5\")\n</pre> # change this to the path that works for you ad10f = sc.read_10x_h5(\"../../../data/pbmc_10k_v3_filtered_feature_bc_matrix.h5\") In\u00a0[3]: Copied! <pre>ad10f.var_names_make_unique()\n</pre> ad10f.var_names_make_unique() In\u00a0[4]: Copied! <pre>ad10f.layers['counts'] = ad10f.X.copy()\nad10f.layers\n</pre> ad10f.layers['counts'] = ad10f.X.copy() ad10f.layers Out[4]: <pre>Layers with keys: counts</pre> In\u00a0[\u00a0]: Copied! <pre>ad10f.obs_names\n</pre> ad10f.obs_names Out[\u00a0]: <pre>Index(['AAACCCAAGCGCCCAT-1', 'AAACCCAAGGTTCCGC-1', 'AAACCCACAGAGTTGG-1',\n       'AAACCCACAGGTATGG-1', 'AAACCCACATAGTCAC-1', 'AAACCCACATCCAATG-1',\n       'AAACCCAGTGGCTACC-1', 'AAACCCATCCCGAGAC-1', 'AAACCCATCTGGCCGA-1',\n       'AAACCCATCTGTTCAT-1',\n       ...\n       'TTTGTTGGTAGCACGA-1', 'TTTGTTGGTATCAGCT-1', 'TTTGTTGGTCGGTGAA-1',\n       'TTTGTTGGTCTGTAAC-1', 'TTTGTTGGTGCGTCGT-1', 'TTTGTTGGTGTCATGT-1',\n       'TTTGTTGGTTTGAACC-1', 'TTTGTTGTCCAAGCCG-1', 'TTTGTTGTCTTACTGT-1',\n       'TTTGTTGTCTTCTAAC-1'],\n      dtype='object', length=11769)</pre> In\u00a0[\u00a0]: Copied! <pre>ad10f.var_names\n</pre> ad10f.var_names Out[\u00a0]: <pre>Index(['MIR1302-2HG', 'FAM138A', 'OR4F5', 'AL627309.1', 'AL627309.3',\n       'AL627309.2', 'AL627309.4', 'AL732372.1', 'OR4F29', 'AC114498.1',\n       ...\n       'AC007325.2', 'BX072566.1', 'AL354822.1', 'AC023491.2', 'AC004556.1',\n       'AC233755.2', 'AC233755.1', 'AC240274.1', 'AC213203.1', 'FAM231C'],\n      dtype='object', length=33538)</pre> <p>To subset annData, just specfiy the cells and genes:</p> In\u00a0[8]: Copied! <pre>genes_monocyte = [\"CD14\", \"CD68\", \"LYZ\"]\nadSubset = ad10f[:10, genes_monocyte]\nadSubset.shape\n</pre> genes_monocyte = [\"CD14\", \"CD68\", \"LYZ\"] adSubset = ad10f[:10, genes_monocyte] adSubset.shape Out[8]: <pre>(10, 3)</pre> <p>Select cells that express CD14, CD68, and LYZ:</p> In\u00a0[\u00a0]: Copied! <pre>gene_mask = ad10f[:,genes_monocyte].X &gt; 0\ngene_mask = gene_mask.toarray()\npassing_cells = np.all(gene_mask, axis=1) # could use np.any to allow a cell expressing any of these genes to pass\nadMono = ad10f[passing_cells]\nadMono.shape\n</pre> gene_mask = ad10f[:,genes_monocyte].X &gt; 0 gene_mask = gene_mask.toarray() passing_cells = np.all(gene_mask, axis=1) # could use np.any to allow a cell expressing any of these genes to pass adMono = ad10f[passing_cells] adMono.shape Out[\u00a0]: <pre>(3262, 33538)</pre> <p>Other slots in adata:</p> <ul> <li>.obsm and .varm: multidimensional metadata</li> <li>.obsp and .varp: metadata on paired cells and paired genes</li> </ul> <p>We will revisit these later.</p> Views Views are pointers to memory where original anndata is stored. They are not copies of the variable.  <p>Let's add some cell metadata</p> In\u00a0[9]: Copied! <pre>ad10f.obs['sample_name'] = \"sample_1\"\nprint(ad10f.obs.columns)\n</pre> ad10f.obs['sample_name'] = \"sample_1\" print(ad10f.obs.columns) <pre>Index(['sample_name'], dtype='object')\n</pre> In\u00a0[5]: Copied! <pre>ad10f.var['mt'] = ad10f.var_names.str.startswith('MT-')\nribo_prefix = (\"RPS\",\"RPL\")\nad10f.var['ribo'] = ad10f.var_names.str.startswith(ribo_prefix)\nsc.pp.calculate_qc_metrics(ad10f, qc_vars=['mt','ribo'], percent_top=None, log1p=False, inplace=True)\n</pre> ad10f.var['mt'] = ad10f.var_names.str.startswith('MT-') ribo_prefix = (\"RPS\",\"RPL\") ad10f.var['ribo'] = ad10f.var_names.str.startswith(ribo_prefix) sc.pp.calculate_qc_metrics(ad10f, qc_vars=['mt','ribo'], percent_top=None, log1p=False, inplace=True) In\u00a0[6]: Copied! <pre>adClean = ad10f.copy()\n\nfig, (ax1, ax2, ax3) = plt.subplots(1, 3, figsize=(10,4), gridspec_kw={'wspace':0.25}, constrained_layout=True)\nax1_dict = sc.pl.scatter(adClean, x='total_counts', y='pct_counts_mt', ax=ax1, show=False)\nax2_dict = sc.pl.scatter(adClean, x='total_counts', y='n_genes_by_counts',ax=ax2, show=False)\nax3_dict = sc.pl.scatter(adClean, x='pct_counts_ribo', y='n_genes_by_counts',ax=ax3, show=False)\nplt.show()\n</pre> adClean = ad10f.copy()  fig, (ax1, ax2, ax3) = plt.subplots(1, 3, figsize=(10,4), gridspec_kw={'wspace':0.25}, constrained_layout=True) ax1_dict = sc.pl.scatter(adClean, x='total_counts', y='pct_counts_mt', ax=ax1, show=False) ax2_dict = sc.pl.scatter(adClean, x='total_counts', y='n_genes_by_counts',ax=ax2, show=False) ax3_dict = sc.pl.scatter(adClean, x='pct_counts_ribo', y='n_genes_by_counts',ax=ax3, show=False) plt.show() <p>Now, do the filtering.</p> <p>First, keep cells with fewer than 20% mitochondrially encoded gene total UMIs</p> In\u00a0[7]: Copied! <pre>adClean = adClean[adClean.obs['pct_counts_mt']&lt;20,:]\nadClean.n_obs\n</pre> adClean = adClean[adClean.obs['pct_counts_mt']&lt;20,:] adClean.n_obs Out[7]: <pre>11047</pre> <ul> <li>Second, filter based on total number of genes detected (at least 500).</li> <li>Third, filter based on total number of counts (fewer than than 30,000)</li> <li>Fourth, keep genes that are detected in at least 10 cells.</li> </ul> In\u00a0[8]: Copied! <pre>adClean.var_names_make_unique()\nsc.pp.filter_cells(adClean, min_genes=500)\nprint(adClean.n_obs)\n\nsc.pp.filter_cells(adClean, max_counts=30000)\nprint(adClean.n_obs)\n\nsc.pp.filter_genes(adClean, min_cells=10)\nprint(adClean.shape)\n</pre> adClean.var_names_make_unique() sc.pp.filter_cells(adClean, min_genes=500) print(adClean.n_obs)  sc.pp.filter_cells(adClean, max_counts=30000) print(adClean.n_obs)  sc.pp.filter_genes(adClean, min_cells=10) print(adClean.shape) <pre>10924\n10891\n(10891, 17422)\n</pre> In\u00a0[9]: Copied! <pre>?sc.pp.filter_genes\n</pre> ?sc.pp.filter_genes <pre>Signature:\nsc.pp.filter_genes(\n    data: 'AnnData | spmatrix | np.ndarray | DaskArray',\n    *,\n    min_counts: 'int | None' = None,\n    min_cells: 'int | None' = None,\n    max_counts: 'int | None' = None,\n    max_cells: 'int | None' = None,\n    inplace: 'bool' = True,\n    copy: 'bool' = False,\n) -&gt; 'AnnData | tuple[np.ndarray, np.ndarray] | None'\nDocstring:\nFilter genes based on number of cells or counts.\n\nKeep genes that have at least `min_counts` counts or are expressed in at\nleast `min_cells` cells or have at most `max_counts` counts or are expressed\nin at most `max_cells` cells.\n\nOnly provide one of the optional parameters `min_counts`, `min_cells`,\n`max_counts`, `max_cells` per call.\n\nParameters\n----------\ndata : 'AnnData | spmatrix | np.ndarray | DaskArray'\n    An annotated data matrix of shape `n_obs` \u00d7 `n_vars`. Rows correspond\n    to cells and columns to genes.\nmin_counts : 'int | None', optional (default: None)\n    Minimum number of counts required for a gene to pass filtering.\nmin_cells : 'int | None', optional (default: None)\n    Minimum number of cells expressed required for a gene to pass filtering.\nmax_counts : 'int | None', optional (default: None)\n    Maximum number of counts required for a gene to pass filtering.\nmax_cells : 'int | None', optional (default: None)\n    Maximum number of cells expressed required for a gene to pass filtering.\ninplace : 'bool', optional (default: True)\n    Perform computation inplace or return result.\n\nReturns\n-------\nDepending on `inplace`, returns the following arrays or directly subsets\nand annotates the data matrix\n\ngene_subset\n    Boolean index mask that does filtering. `True` means that the\n    gene is kept. `False` means the gene is removed.\nnumber_per_gene\n    Depending on what was thresholded (`counts` or `cells`), the array stores\n    `n_counts` or `n_cells` per gene.\nFile:      /opt/homebrew/Caskroom/miniforge/base/envs/autocluster/lib/python3.12/site-packages/scanpy/preprocessing/_simple.py\nType:      function</pre> In\u00a0[10]: Copied! <pre>adNorm = adClean.copy()\nsc.pp.normalize_total(adNorm , target_sum=1e4)\nsc.pp.log1p(adNorm)\n</pre> adNorm = adClean.copy() sc.pp.normalize_total(adNorm , target_sum=1e4) sc.pp.log1p(adNorm) In\u00a0[19]: Copied! <pre>adNorm.obs['sample_name'] = 'sample_1'\n</pre> adNorm.obs['sample_name'] = 'sample_1' In\u00a0[11]: Copied! <pre>n_hvg = 2000\nsc.pp.highly_variable_genes(adNorm, n_top_genes=n_hvg, flavor='cell_ranger')\n# sc.pp.highly_variable_genes(adNorm , min_mean=0.0125, max_mean=6, min_disp=0.25)\nadNorm.var\n</pre> n_hvg = 2000 sc.pp.highly_variable_genes(adNorm, n_top_genes=n_hvg, flavor='cell_ranger') # sc.pp.highly_variable_genes(adNorm , min_mean=0.0125, max_mean=6, min_disp=0.25) adNorm.var Out[11]: gene_ids feature_types genome mt ribo n_cells_by_counts mean_counts pct_dropout_by_counts total_counts n_cells highly_variable means dispersions dispersions_norm AL627309.1 ENSG00000238009 Gene Expression GRCh38 False False 60 0.005183 99.490186 61.0 60 False 0.004502 0.917161 -0.060098 AL669831.5 ENSG00000237491 Gene Expression GRCh38 False False 679 0.062367 94.230606 734.0 665 False 0.048407 0.856350 -0.258551 FAM87B ENSG00000177757 Gene Expression GRCh38 False False 13 0.001190 99.889540 14.0 13 False 0.000770 0.719899 -1.331091 LINC00115 ENSG00000225880 Gene Expression GRCh38 False False 350 0.031269 97.026085 368.0 337 False 0.024243 0.848471 -0.828740 FAM41C ENSG00000230368 Gene Expression GRCh38 False False 313 0.027190 97.340471 320.0 308 False 0.022719 0.883760 -0.320399 ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... AC011043.1 ENSG00000276256 Gene Expression GRCh38 False False 77 0.006882 99.345739 81.0 74 False 0.005875 0.988261 0.642865 AL592183.1 ENSG00000273748 Gene Expression GRCh38 False False 32 0.002719 99.728099 32.0 30 False 0.002267 0.978485 0.592432 AC007325.4 ENSG00000278817 Gene Expression GRCh38 False False 239 0.020902 97.969241 246.0 233 False 0.015576 0.787513 -1.681796 AL354822.1 ENSG00000278384 Gene Expression GRCh38 False False 319 0.028210 97.289489 332.0 303 False 0.023072 0.906420 0.006022 AC240274.1 ENSG00000271254 Gene Expression GRCh38 False False 101 0.008752 99.141813 103.0 99 False 0.006624 0.794754 -1.529179 <p>17422 rows \u00d7 14 columns</p> In\u00a0[12]: Copied! <pre>sc.pl.highly_variable_genes(adNorm)\n</pre> sc.pl.highly_variable_genes(adNorm) In\u00a0[13]: Copied! <pre>adNorm\n</pre> adNorm Out[13]: <pre>AnnData object with n_obs \u00d7 n_vars = 10891 \u00d7 17422\n    obs: 'n_genes_by_counts', 'total_counts', 'total_counts_mt', 'pct_counts_mt', 'total_counts_ribo', 'pct_counts_ribo', 'n_genes', 'n_counts'\n    var: 'gene_ids', 'feature_types', 'genome', 'mt', 'ribo', 'n_cells_by_counts', 'mean_counts', 'pct_dropout_by_counts', 'total_counts', 'n_cells', 'highly_variable', 'means', 'dispersions', 'dispersions_norm'\n    uns: 'log1p', 'hvg'\n    layers: 'counts'</pre> In\u00a0[14]: Copied! <pre>sc.tl.pca(adNorm , mask_var='highly_variable')\nadNorm\n</pre> sc.tl.pca(adNorm , mask_var='highly_variable') adNorm Out[14]: <pre>AnnData object with n_obs \u00d7 n_vars = 10891 \u00d7 17422\n    obs: 'n_genes_by_counts', 'total_counts', 'total_counts_mt', 'pct_counts_mt', 'total_counts_ribo', 'pct_counts_ribo', 'n_genes', 'n_counts'\n    var: 'gene_ids', 'feature_types', 'genome', 'mt', 'ribo', 'n_cells_by_counts', 'mean_counts', 'pct_dropout_by_counts', 'total_counts', 'n_cells', 'highly_variable', 'means', 'dispersions', 'dispersions_norm'\n    uns: 'log1p', 'hvg', 'pca'\n    obsm: 'X_pca'\n    varm: 'PCs'\n    layers: 'counts'</pre> In\u00a0[15]: Copied! <pre>type(adNorm.uns['pca'])\nadNorm.uns['pca'].keys()\n</pre> type(adNorm.uns['pca']) adNorm.uns['pca'].keys() Out[15]: <pre>dict_keys(['params', 'variance', 'variance_ratio'])</pre> In\u00a0[16]: Copied! <pre>sc.pl.pca_variance_ratio(adNorm, 50) # variation per PC\n</pre> sc.pl.pca_variance_ratio(adNorm, 50) # variation per PC In\u00a0[17]: Copied! <pre># Loadings -- the gene 'weights' for PC1 and PC2\nsc.pl.pca_loadings(adNorm, components = [1,2], n_points=10, include_lowest=False)\n</pre> # Loadings -- the gene 'weights' for PC1 and PC2 sc.pl.pca_loadings(adNorm, components = [1,2], n_points=10, include_lowest=False) In\u00a0[20]: Copied! <pre>sc.pl.pca(adNorm , color=['sample_name'], ncols=1)\n</pre> sc.pl.pca(adNorm , color=['sample_name'], ncols=1) In\u00a0[21]: Copied! <pre>markerGenes = ['ACTB', 'PTPRC', 'LYZ','CD79A', 'CLEC4C', 'CD19', 'CD3D']\nsc.pl.pca(adNorm , color=markerGenes, ncols=2, layer='counts')\n</pre> markerGenes = ['ACTB', 'PTPRC', 'LYZ','CD79A', 'CLEC4C', 'CD19', 'CD3D'] sc.pl.pca(adNorm , color=markerGenes, ncols=2, layer='counts') In\u00a0[22]: Copied! <pre>sc.pl.pca(adNorm , color=markerGenes, ncols=3)\n</pre> sc.pl.pca(adNorm , color=markerGenes, ncols=3) In\u00a0[23]: Copied! <pre>sc.pl.pca(adNorm, color=['total_counts', 'pct_counts_mt', 'pct_counts_ribo'], s=25,ncols=3)\n</pre> sc.pl.pca(adNorm, color=['total_counts', 'pct_counts_mt', 'pct_counts_ribo'], s=25,ncols=3) In\u00a0[24]: Copied! <pre>n_neighbors = 20 # tunable\nn_pcs = 10 # this too\nsc.pp.neighbors(adNorm, n_neighbors=n_neighbors, n_pcs=n_pcs)\nadNorm\n</pre> n_neighbors = 20 # tunable n_pcs = 10 # this too sc.pp.neighbors(adNorm, n_neighbors=n_neighbors, n_pcs=n_pcs) adNorm Out[24]: <pre>AnnData object with n_obs \u00d7 n_vars = 10891 \u00d7 17422\n    obs: 'n_genes_by_counts', 'total_counts', 'total_counts_mt', 'pct_counts_mt', 'total_counts_ribo', 'pct_counts_ribo', 'n_genes', 'n_counts', 'sample_name'\n    var: 'gene_ids', 'feature_types', 'genome', 'mt', 'ribo', 'n_cells_by_counts', 'mean_counts', 'pct_dropout_by_counts', 'total_counts', 'n_cells', 'highly_variable', 'means', 'dispersions', 'dispersions_norm'\n    uns: 'log1p', 'hvg', 'pca', 'sample_name_colors', 'neighbors'\n    obsm: 'X_pca'\n    varm: 'PCs'\n    layers: 'counts'\n    obsp: 'distances', 'connectivities'</pre> In\u00a0[25]: Copied! <pre>sc.tl.umap(adNorm)\n</pre> sc.tl.umap(adNorm) In\u00a0[26]: Copied! <pre>sc.pl.umap(adNorm, color=['total_counts', 'pct_counts_mt', 'pct_counts_ribo'], alpha=.75, s=15, cmap='Reds')\n</pre> sc.pl.umap(adNorm, color=['total_counts', 'pct_counts_mt', 'pct_counts_ribo'], alpha=.75, s=15, cmap='Reds') In\u00a0[27]: Copied! <pre>sc.pl.umap(adNorm, color=markerGenes, alpha=.75, s=15, ncols=2)\n</pre> sc.pl.umap(adNorm, color=markerGenes, alpha=.75, s=15, ncols=2) <p>There are lots of ways to customize our plots. See the Scanpy visualization documentation for details. Here, lets change the colors and remove the boxes and axes labels.</p> In\u00a0[30]: Copied! <pre>sc.pl.umap(adNorm, color=['LYZ', 'CD79A'], alpha=.75, s=12, frameon=False, ncols=2, legend_fontoutline=2,legend_fontsize=14, cmap=\"Reds\")\n</pre> sc.pl.umap(adNorm, color=['LYZ', 'CD79A'], alpha=.75, s=12, frameon=False, ncols=2, legend_fontoutline=2,legend_fontsize=14, cmap=\"Reds\") In\u00a0[31]: Copied! <pre>clustering_name = \"leiden_cluster\"\nsc.tl.leiden(adNorm, 0.1, flavor=\"igraph\", n_iterations=2,key_added=clustering_name)\n</pre> clustering_name = \"leiden_cluster\" sc.tl.leiden(adNorm, 0.1, flavor=\"igraph\", n_iterations=2,key_added=clustering_name) In\u00a0[32]: Copied! <pre>sc.pl.umap(adNorm, color=[clustering_name], alpha=.75, s=6,\n           legend_loc='on data', frameon=False, ncols=1,legend_fontoutline=1,legend_fontsize=6,\n           cmap=\"Reds\", use_raw=False, title='')\n</pre> sc.pl.umap(adNorm, color=[clustering_name], alpha=.75, s=6,            legend_loc='on data', frameon=False, ncols=1,legend_fontoutline=1,legend_fontsize=6,            cmap=\"Reds\", use_raw=False, title='') <p>Make a figure that shows the embedding and expression of marker genes side-by-side. Note that I am adding markers for T cell, B cell, and Monocyte sub-types</p> In\u00a0[33]: Copied! <pre>marker_genes_broad_dict = {\n    'B cell': ['CD79A', 'PAX5'],\n    'Dendritic': ['CLEC4C', 'FCER1A'],\n    'Monocyte': ['CSF1R'],\n    'NK cell': ['NKG7', 'GNLY'],\n    'T cell': ['TRAC', 'CD3E'],\n}\nsc.tl.dendrogram(adNorm, groupby=clustering_name)\n\n\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(8,4), gridspec_kw={'wspace':0.25})\nax1_dict = sc.pl.umap(adNorm,color=[clustering_name], alpha=.75, s=10, legend_loc='on data', ax=ax1, show=False, legend_fontoutline=1)\nax2_dict = sc.pl.dotplot(adNorm, marker_genes_broad_dict, groupby=clustering_name, dendrogram=True,ax=ax2, show=False)\nplt.show()\n</pre> marker_genes_broad_dict = {     'B cell': ['CD79A', 'PAX5'],     'Dendritic': ['CLEC4C', 'FCER1A'],     'Monocyte': ['CSF1R'],     'NK cell': ['NKG7', 'GNLY'],     'T cell': ['TRAC', 'CD3E'], } sc.tl.dendrogram(adNorm, groupby=clustering_name)   fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(8,4), gridspec_kw={'wspace':0.25}) ax1_dict = sc.pl.umap(adNorm,color=[clustering_name], alpha=.75, s=10, legend_loc='on data', ax=ax1, show=False, legend_fontoutline=1) ax2_dict = sc.pl.dotplot(adNorm, marker_genes_broad_dict, groupby=clustering_name, dendrogram=True,ax=ax2, show=False) plt.show() <pre>WARNING: Groups are not reordered because the `groupby` categories and the `var_group_labels` are different.\ncategories: 0, 1, 2, etc.\nvar_group_labels: B cell, Dendritic, Monocyte, etc.\n</pre> In\u00a0[36]: Copied! <pre>to_sub = \"3\"\nnname = \"sub_\" + to_sub\nsc.tl.leiden(adNorm,.1, restrict_to=[clustering_name,[to_sub]], key_added = nname)\n</pre> to_sub = \"3\" nname = \"sub_\" + to_sub sc.tl.leiden(adNorm,.1, restrict_to=[clustering_name,[to_sub]], key_added = nname) In\u00a0[37]: Copied! <pre>sc.tl.dendrogram(adNorm, groupby=nname)\nfig, (ax1, ax2) = plt.subplots(1, 2, gridspec_kw={'wspace':0.25})\nax1_dict = sc.pl.umap(adNorm,color=nname, alpha=.75, s=7, legend_loc='on data', ax=ax1, show=False)\nax2_dict = sc.pl.dotplot(adNorm, marker_genes_broad_dict, groupby=nname, dendrogram=True,ax=ax2, show=False)\nplt.show()\n</pre> sc.tl.dendrogram(adNorm, groupby=nname) fig, (ax1, ax2) = plt.subplots(1, 2, gridspec_kw={'wspace':0.25}) ax1_dict = sc.pl.umap(adNorm,color=nname, alpha=.75, s=7, legend_loc='on data', ax=ax1, show=False) ax2_dict = sc.pl.dotplot(adNorm, marker_genes_broad_dict, groupby=nname, dendrogram=True,ax=ax2, show=False) plt.show() <pre>WARNING: Groups are not reordered because the `groupby` categories and the `var_group_labels` are different.\ncategories: 0, 1, 2, etc.\nvar_group_labels: B cell, Dendritic, Monocyte, etc.\n</pre> <p>Cluster 3 is split into 2 clusters now. Both of these sub-clusters express the Monocyte marker CSf1R, but are distinguished by their expression of dendritic marker FCER1A and the B cell genes CD79A and PAX5. Let's look at the QC metrics to see if that can give us additional hints as to whether these are real cells or are doublets.</p> In\u00a0[38]: Copied! <pre>sc.pl.violin(adNorm, ['total_counts'], groupby=nname )\n</pre> sc.pl.violin(adNorm, ['total_counts'], groupby=nname ) <p>Cluster 3 (and each sub-cluster) has a high number of Total counts. So let's annotate these as 'doublet'.</p> <p>What about the other questionable clusters 7, 2, and 1? Can we refine those?</p> In\u00a0[39]: Copied! <pre># cluster 7\ncname = nname\nto_sub = \"7\"\nnname = \"sub_\" + to_sub\n\nsc.tl.leiden(adNorm,.05, restrict_to=[cname,[to_sub]], key_added = nname)\nsc.tl.dendrogram(adNorm, nname)\nfig, (ax1, ax2) = plt.subplots(1, 2,  gridspec_kw={'wspace':0.25})\nax1_dict = sc.pl.umap(adNorm,color=nname, alpha=.75, s=10, legend_loc='on data', ax=ax1, show=False)\nax2_dict = sc.pl.dotplot(adNorm, marker_genes_broad_dict, nname, dendrogram=True,ax=ax2, show=False)\nplt.show()\n</pre> # cluster 7 cname = nname to_sub = \"7\" nname = \"sub_\" + to_sub  sc.tl.leiden(adNorm,.05, restrict_to=[cname,[to_sub]], key_added = nname) sc.tl.dendrogram(adNorm, nname) fig, (ax1, ax2) = plt.subplots(1, 2,  gridspec_kw={'wspace':0.25}) ax1_dict = sc.pl.umap(adNorm,color=nname, alpha=.75, s=10, legend_loc='on data', ax=ax1, show=False) ax2_dict = sc.pl.dotplot(adNorm, marker_genes_broad_dict, nname, dendrogram=True,ax=ax2, show=False) plt.show() <pre>WARNING: Groups are not reordered because the `groupby` categories and the `var_group_labels` are different.\ncategories: 0, 1, 2, etc.\nvar_group_labels: B cell, Dendritic, Monocyte, etc.\n</pre> <p>It looks like 7,1 is a multiplet, and 7,0 is monocyte. What about cluster 2?</p> In\u00a0[40]: Copied! <pre>cname = nname\nto_sub = \"2\"\nnname = \"sub_\" + to_sub\n\nsc.tl.leiden(adNorm,.15, restrict_to=[cname,[to_sub]], key_added = nname)\nsc.tl.dendrogram(adNorm, nname)\nfig, (ax1, ax2) = plt.subplots(1, 2,  gridspec_kw={'wspace':0.25})\nax1_dict = sc.pl.umap(adNorm,color=nname, alpha=.75, s=10, legend_loc='on data', ax=ax1, show=False)\nax2_dict = sc.pl.dotplot(adNorm, marker_genes_broad_dict, nname, dendrogram=True,ax=ax2, show=False)\nplt.show()\n</pre>  cname = nname to_sub = \"2\" nname = \"sub_\" + to_sub  sc.tl.leiden(adNorm,.15, restrict_to=[cname,[to_sub]], key_added = nname) sc.tl.dendrogram(adNorm, nname) fig, (ax1, ax2) = plt.subplots(1, 2,  gridspec_kw={'wspace':0.25}) ax1_dict = sc.pl.umap(adNorm,color=nname, alpha=.75, s=10, legend_loc='on data', ax=ax1, show=False) ax2_dict = sc.pl.dotplot(adNorm, marker_genes_broad_dict, nname, dendrogram=True,ax=ax2, show=False) plt.show() <pre>WARNING: Groups are not reordered because the `groupby` categories and the `var_group_labels` are different.\ncategories: 0, 1, 2,0, etc.\nvar_group_labels: B cell, Dendritic, Monocyte, etc.\n</pre> In\u00a0[41]: Copied! <pre>sc.pl.violin(adNorm, ['total_counts', 'n_genes_by_counts'], groupby=nname )\n</pre> sc.pl.violin(adNorm, ['total_counts', 'n_genes_by_counts'], groupby=nname ) <p>cluster 2 does not seem to be a composite. I think 2 is just NK.</p> In\u00a0[45]: Copied! <pre>cname = \"sub_7\"\nto_sub = \"1\"\nnname = \"sub_\" + to_sub\n\nsc.tl.leiden(adNorm,.1, restrict_to=[cname,[to_sub]], key_added = nname)\nsc.tl.dendrogram(adNorm, nname)\nfig, (ax1, ax2) = plt.subplots(1, 2,  gridspec_kw={'wspace':0.25})\nax1_dict = sc.pl.umap(adNorm,color=nname, alpha=.75, s=10, legend_loc='on data', ax=ax1, show=False)\nax2_dict = sc.pl.dotplot(adNorm, marker_genes_broad_dict, nname, dendrogram=True,ax=ax2, show=False)\nplt.show()\n</pre> cname = \"sub_7\" to_sub = \"1\" nname = \"sub_\" + to_sub  sc.tl.leiden(adNorm,.1, restrict_to=[cname,[to_sub]], key_added = nname) sc.tl.dendrogram(adNorm, nname) fig, (ax1, ax2) = plt.subplots(1, 2,  gridspec_kw={'wspace':0.25}) ax1_dict = sc.pl.umap(adNorm,color=nname, alpha=.75, s=10, legend_loc='on data', ax=ax1, show=False) ax2_dict = sc.pl.dotplot(adNorm, marker_genes_broad_dict, nname, dendrogram=True,ax=ax2, show=False) plt.show() <pre>WARNING: Groups are not reordered because the `groupby` categories and the `var_group_labels` are different.\ncategories: 0, 1,0, 1,1, etc.\nvar_group_labels: B cell, Dendritic, Monocyte, etc.\n</pre> <p>Unsure about 1,0 and 1,1: they have low-ish counts, but appear to be NK/T composites. Let's compile everything else so far:</p> cluster markers  of cell type 3,0 Dendritic, Mono Doublet 3,1 B, Mono Doublet 4 Monocyte Monocyte 7,1 Monocyte, T, NK Multiplet 7,0 Monocyte, Monocyte 6 Dendritic Dendritic 5 B B 8 none mystery 2 NK NK 0 T cell T cell 1,0 NK, T ??? 1,1 NK, T ??? <p>Look at sub-type markers.</p> In\u00a0[46]: Copied! <pre>marker_genes_sub_dict = {\n    'B cell': ['CD79A'],\n    'Dendritic': ['CLEC4C'],\n    'CD14 monocyte': ['CD14'],\n    'CD16 monocyte': ['FCGR3A'],\n    'NK cell': ['GNLY'],\n    'CD4 T cell': ['CD4', 'GATA3'],\n    'CD8 T cell': ['CD8A', 'EOMES']\n}\n\nsc.tl.dendrogram(adNorm, nname)\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10,4), gridspec_kw={'wspace':0.25})\nax1_dict = sc.pl.umap(adNorm,color=nname, alpha=.75, s=10, legend_loc='on data', ax=ax1, show=False)\nax2_dict = sc.pl.dotplot(adNorm, marker_genes_sub_dict, nname, dendrogram=True,ax=ax2, show=False)\nplt.show()\n</pre> marker_genes_sub_dict = {     'B cell': ['CD79A'],     'Dendritic': ['CLEC4C'],     'CD14 monocyte': ['CD14'],     'CD16 monocyte': ['FCGR3A'],     'NK cell': ['GNLY'],     'CD4 T cell': ['CD4', 'GATA3'],     'CD8 T cell': ['CD8A', 'EOMES'] }  sc.tl.dendrogram(adNorm, nname) fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10,4), gridspec_kw={'wspace':0.25}) ax1_dict = sc.pl.umap(adNorm,color=nname, alpha=.75, s=10, legend_loc='on data', ax=ax1, show=False) ax2_dict = sc.pl.dotplot(adNorm, marker_genes_sub_dict, nname, dendrogram=True,ax=ax2, show=False) plt.show() <pre>WARNING: Groups are not reordered because the `groupby` categories and the `var_group_labels` are different.\ncategories: 0, 1,0, 1,1, etc.\nvar_group_labels: B cell, Dendritic, CD14 monocyte, etc.\n</pre> <p>We are close to a final annotation now:</p> cluster markers  of cell type 3,0 Dendritic, Mono Doublet 3,1 B, Mono Doublet 4 CD14 Monocyte Monocyte CD14 7,1 Monocyte, T, NK Multiplet 7,0 Monocyte CD16 Monocyte CD16 6 Dendritic Dendritic 5 B B 8 none mystery 2 NK NK 0 T cell T cell CD4 1,0 NK, T T cell CD8 1,1 NK, T T cell CD8 <p>But what is cluster 8? It has low counts. If it is just ambient 'soup', then we would not expect it to have high levels of cell type specific genes. Let's do differential gene expression analysis to see what is upregulated in this cluster.</p> In\u00a0[53]: Copied! <pre>nname\n</pre> nname Out[53]: <pre>'sub_1'</pre> In\u00a0[47]: Copied! <pre>sc.tl.rank_genes_groups(adNorm, use_raw=False, groupby=nname)\n</pre> sc.tl.rank_genes_groups(adNorm, use_raw=False, groupby=nname) In\u00a0[62]: Copied! <pre># sc.pl.rank_genes_groups_dotplot(adNorm, n_genes=5, groupby=nname, dendrogram=True, key='rank_genes_groups')\n</pre> # sc.pl.rank_genes_groups_dotplot(adNorm, n_genes=5, groupby=nname, dendrogram=True, key='rank_genes_groups') In\u00a0[49]: Copied! <pre>sc.pl.rank_genes_groups_dotplot(adNorm, n_genes=20, groupby=nname, dendrogram=True, key='rank_genes_groups', groups=['8'])\n</pre> sc.pl.rank_genes_groups_dotplot(adNorm, n_genes=20, groupby=nname, dendrogram=True, key='rank_genes_groups', groups=['8']) <pre>WARNING: Groups are not reordered because the `groupby` categories and the `var_group_labels` are different.\ncategories: 0, 1,0, 1,1, etc.\nvar_group_labels: 8\n</pre> <p>Although this result could be refined and explored a lot, it is sufficient for us to address our question about the identity of cluster 7 as follows:</p> Help from ChatGPT to annotate cells <p>Now, let's add the annotation to the anndata.obs and discard the other cells</p> cluster markers  of cell type 3,0 Dendritic, Mono Doublet 3,1 B, Mono Doublet 4 CD14 Monocyte Monocyte CD14 7,1 Monocyte, T, NK Multiplet 7,0 Monocyte CD16 Monocyte CD16 6 Dendritic Dendritic 5 B B 8 Plat Platelet 2 NK NK 0 T cell T cell CD4 1,0 NK, T T cell CD8 1,1 NK, T T cell CD8 In\u00a0[54]: Copied! <pre>tokeep = [\"4\", \"7,0\", \"6\", \"5\", \"8\", \"2\", \"0\", \"1,0\", \"1,1\"]\nadNorm2 = adNorm.copy()\nadNorm2 = adNorm2[adNorm2.obs[nname].isin(tokeep)].copy()\nadNorm2.shape\nadNorm2.obs[nname].value_counts()\n</pre> tokeep = [\"4\", \"7,0\", \"6\", \"5\", \"8\", \"2\", \"0\", \"1,0\", \"1,1\"] adNorm2 = adNorm.copy() adNorm2 = adNorm2[adNorm2.obs[nname].isin(tokeep)].copy() adNorm2.shape adNorm2.obs[nname].value_counts() Out[54]: <pre>sub_1\n0      3553\n4      3123\n5      1602\n2       623\n1,0     622\n1,1     406\n7,0     354\n6        81\n8        61\nName: count, dtype: int64</pre> In\u00a0[55]: Copied! <pre>cell_dict = {'Dendritic': ['6'],\n             'CD14 Monocyte': ['4'],\n             'CD16 Monocyte': [\"7,0\"],\n             'B cell': ['5'],\n             'Platelet': ['8'],\n             'CD4 T cell': ['0'],\n             'CD8 T cell': [\"1,0\", \"1,1\"],\n             'NK cell': [\"2\"]\n}\n\nmarker_genes_dict = {\n    'B cell': ['CD79A'],\n    'Dendritic': ['CLEC4C'],\n    'CD14 monocyte': ['CD14'],\n    'CD16 monocyte': ['FCGR3A'],\n    'NK cell': ['GNLY'],\n    'CD4 T cell': ['CD4', 'GATA3'],\n    'CD8 T cell': ['CD8A', 'EOMES'],\n    'Platelet': ['PF4', 'CAVIN2']\n}\n\n\nnew_obs_name = 'cell_type'\nadNorm2.obs[new_obs_name] = np.nan\n\nfor i in cell_dict.keys():\n    ind = pd.Series(adNorm2.obs[nname]).isin(cell_dict[i])\n    adNorm2.obs.loc[ind,new_obs_name] = i\n\nadNorm2.obs['cell_type'] = adNorm2.obs['cell_type'].astype(\"category\")\n</pre> cell_dict = {'Dendritic': ['6'],              'CD14 Monocyte': ['4'],              'CD16 Monocyte': [\"7,0\"],              'B cell': ['5'],              'Platelet': ['8'],              'CD4 T cell': ['0'],              'CD8 T cell': [\"1,0\", \"1,1\"],              'NK cell': [\"2\"] }  marker_genes_dict = {     'B cell': ['CD79A'],     'Dendritic': ['CLEC4C'],     'CD14 monocyte': ['CD14'],     'CD16 monocyte': ['FCGR3A'],     'NK cell': ['GNLY'],     'CD4 T cell': ['CD4', 'GATA3'],     'CD8 T cell': ['CD8A', 'EOMES'],     'Platelet': ['PF4', 'CAVIN2'] }   new_obs_name = 'cell_type' adNorm2.obs[new_obs_name] = np.nan  for i in cell_dict.keys():     ind = pd.Series(adNorm2.obs[nname]).isin(cell_dict[i])     adNorm2.obs.loc[ind,new_obs_name] = i  adNorm2.obs['cell_type'] = adNorm2.obs['cell_type'].astype(\"category\")  In\u00a0[56]: Copied! <pre>sc.tl.dendrogram(adNorm2, \"cell_type\")\nfig, (ax1, ax2) = plt.subplots(1, 2, gridspec_kw={'wspace':0.4})\nax1_dict = sc.pl.umap(adNorm2,color=['cell_type'], alpha=.75, s=10, legend_loc='on data', ax=ax1, show=False)\nax2_dict = sc.pl.dotplot(adNorm2, marker_genes_dict, 'cell_type', dendrogram=True,ax=ax2, show=False)\nplt.show()\n</pre> sc.tl.dendrogram(adNorm2, \"cell_type\") fig, (ax1, ax2) = plt.subplots(1, 2, gridspec_kw={'wspace':0.4}) ax1_dict = sc.pl.umap(adNorm2,color=['cell_type'], alpha=.75, s=10, legend_loc='on data', ax=ax1, show=False) ax2_dict = sc.pl.dotplot(adNorm2, marker_genes_dict, 'cell_type', dendrogram=True,ax=ax2, show=False) plt.show()  <pre>WARNING: Groups are not reordered because the `groupby` categories and the `var_group_labels` are different.\ncategories: B cell, CD14 Monocyte, CD16 Monocyte, etc.\nvar_group_labels: B cell, Dendritic, CD14 monocyte, etc.\n</pre> In\u00a0[68]: Copied! <pre>sc.pl.pca(adNorm2, color=['cell_type', 'GNLY'], alpha=.75, s=15, projection='3d')\n</pre> sc.pl.pca(adNorm2, color=['cell_type', 'GNLY'], alpha=.75, s=15, projection='3d') In\u00a0[57]: Copied! <pre>sc.tl.rank_genes_groups(adNorm2, use_raw=False, groupby=\"cell_type\")\n</pre> sc.tl.rank_genes_groups(adNorm2, use_raw=False, groupby=\"cell_type\") In\u00a0[58]: Copied! <pre>sc.tl.filter_rank_genes_groups(adNorm2, min_fold_change=.7, min_in_group_fraction=.5, max_out_group_fraction=.15)\nsc.pl.rank_genes_groups_dotplot(adNorm2, n_genes=6, groupby=\"cell_type\", dendrogram=True, key='rank_genes_groups_filtered', swap_axes=True)\n</pre> sc.tl.filter_rank_genes_groups(adNorm2, min_fold_change=.7, min_in_group_fraction=.5, max_out_group_fraction=.15) sc.pl.rank_genes_groups_dotplot(adNorm2, n_genes=6, groupby=\"cell_type\", dendrogram=True, key='rank_genes_groups_filtered', swap_axes=True)"},{"location":"notebooks/scBasics_2.html#overview","title":"Overview\u00b6","text":"<p>Continue from where we left off on Tues:</p> <ol> <li>Quality control, Normalization</li> <li>Dimensionality reduction with PCA</li> <li>Cell-cell distances</li> <li>Unsupervised clustering with Leiden</li> </ol>"},{"location":"notebooks/scBasics_2.html#speed-run-through-tuesdays-analysis-steps","title":"Speed run through Tuesday's analysis steps\u00b6","text":"<p>Remember to install packages, fetch data, etc first -- see last notebook as needed.</p>"},{"location":"notebooks/scBasics_2.html#start-lecture-4-here-quality-control-qc","title":"START Lecture 4 here -&gt;&gt; Quality Control (QC)\u00b6","text":"<p>Broadly speaking there are two things that we apply quality control to:</p> <ol> <li>Cells: We want to find putative doublets and low quality cell barcodes and ehold them out of downstream analysis (or at least tag them).</li> <li>Genes: We also can remove genes that are not detected in the vast majority of cell</li> </ol> <p>The function <code>sc.pp.calculate_qc_metrics()</code> will calculate a set of metrics on adata and places the results in .obs and .var. The results can then be used to filter the adata. <code>pp.calculate_qc_metrics()</code> can also take inputs to specify other, custom metrics to compute. Below, we use it to compute the fraction of all UMIs in each cell that are mitochondrially encoded or that encode for ribosomal genes.</p>"},{"location":"notebooks/scBasics_2.html#visualize","title":"Visualize\u00b6","text":"<p>Take a look some typical QC values across these data</p>"},{"location":"notebooks/scBasics_2.html#normalization","title":"Normalization\u00b6","text":"<p>Simple library size scaling, then log transform. There are many other ways to correct for cell-to-cell technical variation, for example different cell lysis efficiencies, but this method is good enough for this data set and our goals.</p>"},{"location":"notebooks/scBasics_2.html#highly-variable-genes-hvg","title":"Highly variable genes (HVG)\u00b6","text":"<p>It is common practice to limit some parts of analysis to those variables or genes that exhibit some degree of variation in their values across the data. We call these highly variable genes, or HVG for short. The rationale is that these genes are differentially regulated between populations within the sample. There are different ways to identify such genes. In one approach, a normalized dispersion is calculated for each gene and the top_n genes (e.g. top_n = 2,000) with the highest normalized dispersions are considered highly variable. This approach recognizes that expression variation scales with mean expression, and so it first groups genes into bins based on their mean expression. Then it computes the mean and standard deviation of dispersion for each bin. Finally it computes the normalized dispersion for each gene as dispersion - mean_dispersion / std_dispersion.</p> <p>BTW: dispersion = variance / mean (and Variance is just expected squared deviation of gene expression)</p>"},{"location":"notebooks/scBasics_2.html#dimensionality-reduction-with-principal-components-analysis-pca","title":"Dimensionality reduction with Principal components analysis (PCA)\u00b6","text":"<p>Why performan dimentaionality reduction?</p> <ol> <li>Genes are expressed in coordinated fashion, meaning that many have correlated expression patterns and so PCA reduces the computational complexity of downstream analysis</li> <li>scRNA-seq data is noisy on a per gene basis.</li> </ol> <p>PCA allows us to reduce a high dimensional data set into a lower dimension in which much of the total variation is maintained. To understand PCA, you need to know linear algebra. In essence, it identifies sets of linear combinations of genes (PCs) in such a way that each PC uncorrelated with others, and such that PC1 has the maiximum variation, then PC2, and so on. The function call <code>sc.tl.pca</code> does the following:</p> <ol> <li>computes the covariance matrix (correlation between each pair of genes)</li> <li>finds eigenvectors (directions of axes that maximize that variance), orthogonal to each other</li> <li>stores results in <code>.uns['pca']</code>, <code>.obsm['X_pca']</code>, <code>.varm['PCs']</code></li> </ol> <p>Later, we select a threshold (n_pcs) as the number of PCs that contribute most to the total variation on our data. We use these n_pcs PCs to compute cell-to-cell distances for embedding (2D visualization via UMAP) and for clustering of cells.</p>"},{"location":"notebooks/scBasics_2.html#marker-genes","title":"Marker genes\u00b6","text":"<p>Here PBMC cell types and some genes that have been used to identify them:</p> <p>Monocytes: CD14, CD68, LYZ Dendritic: CLEC4C, FLT3 NK cells: GNLY, NCAM1 B cells: CD19, CD79A, CD79B T cells: CD3D, CD3E, TRAC, TRBC</p>"},{"location":"notebooks/scBasics_2.html#knn-cell-cell-distances","title":"kNN cell-cell distances\u00b6","text":"<p>The k-nearest neighbor graph generates an adjacency matrix by finding, for each cell, the k cells that are closest to it. This helps to reduce noise in computing cell-cell distances or similarities and is important for embedding the cells in a 2D space, and for community detection algorithms. Two arguments are n_neighbors, or k, and the number of PCs to use when computing cell-cell distances.</p>"},{"location":"notebooks/scBasics_2.html#visualization-of-cell-cell-similarities","title":"Visualization of cell-cell similarities\u00b6","text":""},{"location":"notebooks/scBasics_2.html#umap-embedding","title":"UMAP embedding\u00b6","text":"<p>This an elaboration on the t-SNE embedding approach. Both of these methods try to project cells into a reduced (typically 2) dimensional coordinate system while maintaining both the global and local structure of the high dimensional space of the data (i.e. cells that are distant from each other high dimensions should still be distant in the reduced embedding; same is true for cells that are near each other). The distances come from the kNN graph.</p>"},{"location":"notebooks/scBasics_2.html#unsupervised-clustering","title":"Unsupervised clustering\u00b6","text":"<p>Let's try to assign cells to distinct groups or clusters based on the cell-to-cell distances. Leiden and Louvain are examples of community detection methods that perform this task by searching for the group assignment that maximize within group similarity (which is equivalent to within group edges of a knn graph) and to minimize between group similarity.</p>"},{"location":"notebooks/scBasics_2.html#cluster-annotation","title":"Cluster annotation\u00b6","text":"<p>We can walk down the rows of the dotplot and guess at the cell types of some of these clusters based on the specificty of marker expression: NB: The cluster labels are likely to be different when you run this. In fact, when I re-run this notebook on my laptop instead of from Colab, they are different, which is really annoying!</p> cluster markers  of cell type 3 B, Dendritic, Mono ??? 4 Monocyte Monocyte 7 Monocyte, T, NK ??? 6 Dendritic Dendritic 5 B B 8 none mystery 2 NK, T ??? 0 T cell T cell 1 NK, T ??? <p>Some clusters are ambiguous because they express markers of more than one cell type. This could be due to the cluster containing &gt; 1 cell type, or because the cell barcodes are doublets. If the former, then we should be able to sub cluster them. Let's try this.</p> <p>Clusters to refine are 3, 7, 2, and 1.</p>"},{"location":"notebooks/scBasics_2.html#differential-gene-expression","title":"Differential gene expression\u00b6","text":""},{"location":"notebooks/scBasics_2.html#differential-expression-analysis","title":"Differential expression analysis\u00b6","text":"<p>Let's identify genes that are preferenntially expressed in each cluster versus all the others as a final step to annotate these clusters and to remove ones that are likely to be doublets.</p>"},{"location":"notebooks/scBasics_2.html#dot-plot-of-differentially-expressed-genes","title":"Dot plot of differentially expressed genes\u00b6","text":"<p>First, we will apply a filter so that we only display genes that meet additional criteria beyond statistical: fold change, % expressed in cluster, % expressed in other cells</p>"},{"location":"notebooks/scBasics_2.html#resources","title":"Resources\u00b6","text":""},{"location":"notebooks/scBasics_2.html#tools","title":"Tools\u00b6","text":"<ul> <li>Colab<ul> <li>https://colab.research.google.com/</li> </ul> </li> <li>Jupyter<ul> <li>https://jupyter.org/</li> </ul> </li> <li>CellRanger<ul> <li>https://www.10xgenomics.com/support/software/cell-ranger/latest/advanced/cr-barcode-rank-plot</li> <li>https://www.10xgenomics.com/support/software/cell-ranger/latest/algorithms-overview/cr-gex-algorithm</li> </ul> </li> </ul>"},{"location":"notebooks/scBasics_2.html#literature","title":"Literature\u00b6","text":"<ul> <li>Best practices<ul> <li>best practices in sc analysis online book</li> <li>paper associated with the above online book</li> </ul> </li> <li>Scanpy<ul> <li>https://scanpy.readthedocs.io/en/stable/</li> <li>https://scanpy.readthedocs.io/en/stable/tutorials.html</li> <li>https://scanpy-tutorials.readthedocs.io/en/latest/pbmc3k.html</li> <li>https://scanpy-tutorials.readthedocs.io/en/latest/plotting/advanced.html</li> <li>https://scanpy-tutorials.readthedocs.io/en/latest/plotting/core.html</li> </ul> </li> <li>AnnData<ul> <li>https://anndata.readthedocs.io/en/latest/tutorials/notebooks/getting-started.html</li> <li>https://anndata.readthedocs.io/en/latest/index.html</li> </ul> </li> <li>QC<ul> <li>https://genomebiology.biomedcentral.com/articles/10.1186/s13059-020-02136-7</li> </ul> </li> </ul>"},{"location":"notebooks/scFates.html","title":"scFates","text":"<p>For more details on scFates, please see the documentation</p> <p>Point interpreter to R, import packages, fetch data.</p> In\u00a0[97]: Copied! <pre>import os, sys\nos.environ['R_HOME'] = sys.exec_prefix+\"/lib/R/\"\n</pre> import os, sys os.environ['R_HOME'] = sys.exec_prefix+\"/lib/R/\" In\u00a0[2]: Copied! <pre>print(os.environ['R_HOME'])\n</pre> print(os.environ['R_HOME']) <pre>/opt/homebrew/Caskroom/miniforge/base/envs/scFates/lib/R/\n</pre> In\u00a0[3]: Copied! <pre>import scanpy as sc\nimport scFates as scf\nimport numpy as np\nimport pandas as pd\n</pre> import scanpy as sc import scFates as scf import numpy as np import pandas as pd In\u00a0[4]: Copied! <pre>!wget https://compstemcellbio.s3.amazonaws.com/2024/TI/adata_Stam_250_022224.h5ad\n</pre> !wget https://compstemcellbio.s3.amazonaws.com/2024/TI/adata_Stam_250_022224.h5ad <pre>--2025-03-05 17:14:33--  https://compstemcellbio.s3.amazonaws.com/2024/TI/adata_Stam_250_022224.h5ad\nResolving compstemcellbio.s3.amazonaws.com (compstemcellbio.s3.amazonaws.com)... 52.217.84.52, 3.5.28.109, 3.5.20.136, ...\nconnected. to compstemcellbio.s3.amazonaws.com (compstemcellbio.s3.amazonaws.com)|52.217.84.52|:443... \nHTTP request sent, awaiting response... 200 OK\nLength: 30948532 (30M) [binary/octet-stream]\nSaving to: \u2018adata_Stam_250_022224.h5ad.1\u2019\n\nadata_Stam_250_0222 100%[===================&gt;]  29.51M  19.1MB/s    in 1.5s    \n\n2025-03-05 17:14:35 (19.1 MB/s) - \u2018adata_Stam_250_022224.h5ad.1\u2019 saved [30948532/30948532]\n\n</pre> In\u00a0[5]: Copied! <pre>adata = sc.read_h5ad(\"adata_Stam_250_022224.h5ad\")\n</pre> adata = sc.read_h5ad(\"adata_Stam_250_022224.h5ad\") In\u00a0[6]: Copied! <pre>adata\n</pre> adata Out[6]: <pre>AnnData object with n_obs \u00d7 n_vars = 2750 \u00d7 36601\n    obs: 'day', 'sample', 'experiment', 'n_counts', 'n_genes_by_counts', 'total_counts', 'total_counts_mt', 'pct_counts_mt'\n    var: 'Accession', 'Chromosome', 'End', 'Start', 'Strand'</pre> In\u00a0[7]: Copied! <pre>adata.obs['sample'].value_counts()\n</pre> adata.obs['sample'].value_counts() Out[7]: <pre>sample\ncd34.day0    250\nery.day2     250\nery.day4     250\nery.day6     250\nery.day8     250\nery.day11    250\nmk.day2      250\nmk.day4      250\nmk.day6      250\nmk.day8      250\nmk.day11     250\nName: count, dtype: int64</pre> <p>Note that this partcular dataset is already normalized (your HW data will not be). Now find HVG</p> In\u00a0[8]: Copied! <pre>sc.pp.highly_variable_genes(adata , min_mean=0.0125, max_mean=6, min_disp=0.25)\n</pre> sc.pp.highly_variable_genes(adata , min_mean=0.0125, max_mean=6, min_disp=0.25) <p>Perform PCA, plot embedding, and color with marker genes for CD34 HSPCs, Erythrocytes, and Megakaryocytes (Human)</p> In\u00a0[9]: Copied! <pre>sc.tl.pca(adata, mask_var='highly_variable')\nsc.pl.pca(adata, color=[\"CD34\", \"HBA1\", \"PF4\"], s=20)\n</pre> sc.tl.pca(adata, mask_var='highly_variable') sc.pl.pca(adata, color=[\"CD34\", \"HBA1\", \"PF4\"], s=20) In\u00a0[10]: Copied! <pre>sc.pl.pca(adata, color='sample')\n</pre> sc.pl.pca(adata, color='sample') <p><code>cf.tl.tree()</code> fits a principal tree to this embedding.</p> <p>See documentation for parameters</p> In\u00a0[11]: Copied! <pre>adata\n</pre> adata Out[11]: <pre>AnnData object with n_obs \u00d7 n_vars = 2750 \u00d7 36601\n    obs: 'day', 'sample', 'experiment', 'n_counts', 'n_genes_by_counts', 'total_counts', 'total_counts_mt', 'pct_counts_mt'\n    var: 'Accession', 'Chromosome', 'End', 'Start', 'Strand', 'highly_variable', 'means', 'dispersions', 'dispersions_norm'\n    uns: 'hvg', 'pca', 'sample_colors'\n    obsm: 'X_pca'\n    varm: 'PCs'</pre> In\u00a0[12]: Copied! <pre>adata.obsm['X_pca'].shape\n</pre> adata.obsm['X_pca'].shape Out[12]: <pre>(2750, 50)</pre> In\u00a0[13]: Copied! <pre>scf.tl.tree(adata,method=\"ppt\",Nodes=10,use_rep=\"X_pca\")\n</pre> scf.tl.tree(adata,method=\"ppt\",Nodes=10,use_rep=\"X_pca\") <pre>inferring a principal tree --&gt; parameters used \n    10 principal points, sigma = 0.1, lambda = 1, metric = euclidean\n    fitting:   2%|\u258c                              | 1/50 [00:00&lt;00:24,  2.03it/s]\n    converged\n    finished (0:00:00) --&gt; added \n    .uns['ppt'], dictionnary containing inferred tree.\n    .obsm['X_R'] soft assignment of cells to principal points.\n    .uns['graph']['B'] adjacency matrix of the principal points.\n    .uns['graph']['F'] coordinates of principal points in representation space.\n</pre> <p>Plot the tree on top of the pca embedding with scf.pl.graph()</p> In\u00a0[14]: Copied! <pre>scf.pl.graph(adata, basis='pca')\n</pre> scf.pl.graph(adata, basis='pca') <p>Why does the trajectory bend back (top left)?</p> In\u00a0[15]: Copied! <pre>sc.pl.pca(adata, color=[\"sample\"],projection=\"3d\", components = ['1,2,3', '1,3,2'], s=20)\n</pre> sc.pl.pca(adata, color=[\"sample\"],projection=\"3d\", components = ['1,2,3', '1,3,2'], s=20) <p>We should restrict tree finding to 1st 3 PCs</p> In\u00a0[16]: Copied! <pre>scf.tl.tree(adata, method=\"ppt\", Nodes=10, use_rep=\"X_pca\", ndims_rep = 3)\n</pre> scf.tl.tree(adata, method=\"ppt\", Nodes=10, use_rep=\"X_pca\", ndims_rep = 3) <pre>inferring a principal tree --&gt; parameters used \n    10 principal points, sigma = 0.1, lambda = 1, metric = euclidean\n    fitting:   0%|                                       | 0/50 [00:00&lt;?, ?it/s]\n    converged\n    finished (0:00:00) --&gt; added \n    .uns['ppt'], dictionnary containing inferred tree.\n    .obsm['X_R'] soft assignment of cells to principal points.\n    .uns['graph']['B'] adjacency matrix of the principal points.\n    .uns['graph']['F'] coordinates of principal points in representation space.\n</pre> In\u00a0[17]: Copied! <pre>scf.pl.graph(adata, basis='pca')\n</pre> scf.pl.graph(adata, basis='pca') <p>Explore other parameters:</p> <ul> <li><code>nodes</code></li> <li><code>ppt_lambda</code></li> <li><code>ppt_sigma</code></li> </ul> In\u00a0[18]: Copied! <pre>scf.tl.tree(adata,method=\"ppt\",Nodes=50,use_rep=\"X_pca\", ndims_rep = 3)\nscf.pl.graph(adata, basis='pca')\n</pre> scf.tl.tree(adata,method=\"ppt\",Nodes=50,use_rep=\"X_pca\", ndims_rep = 3) scf.pl.graph(adata, basis='pca') <pre>inferring a principal tree --&gt; parameters used \n    50 principal points, sigma = 0.1, lambda = 1, metric = euclidean\n    fitting:  42%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258f                | 21/50 [00:00&lt;00:00, 121.76it/s]\n    converged\n    finished (0:00:00) --&gt; added \n    .uns['ppt'], dictionnary containing inferred tree.\n    .obsm['X_R'] soft assignment of cells to principal points.\n    .uns['graph']['B'] adjacency matrix of the principal points.\n    .uns['graph']['F'] coordinates of principal points in representation space.\n</pre> In\u00a0[19]: Copied! <pre>scf.tl.tree(adata,method=\"ppt\",Nodes=100,use_rep=\"X_pca\", ppt_lambda=100,ppt_sigma=0.75,ppt_nsteps=100, ndims_rep = 3)\nscf.pl.graph(adata, basis='pca')\n</pre> scf.tl.tree(adata,method=\"ppt\",Nodes=100,use_rep=\"X_pca\", ppt_lambda=100,ppt_sigma=0.75,ppt_nsteps=100, ndims_rep = 3) scf.pl.graph(adata, basis='pca') <pre>inferring a principal tree --&gt; parameters used \n    100 principal points, sigma = 0.75, lambda = 100, metric = euclidean\n    fitting:  30%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d                   | 30/100 [00:00&lt;00:00, 116.04it/s]\n    converged\n    finished (0:00:00) --&gt; added \n    .uns['ppt'], dictionnary containing inferred tree.\n    .obsm['X_R'] soft assignment of cells to principal points.\n    .uns['graph']['B'] adjacency matrix of the principal points.\n    .uns['graph']['F'] coordinates of principal points in representation space.\n</pre> <p>Set a root node with scf.tl.root()</p> <p>Then compute Pseudotime with scf.tl.pseudotime()</p> In\u00a0[20]: Copied! <pre>scf.tl.root(adata, 96)\n</pre> scf.tl.root(adata, 96) <pre>node 96 selected as a root --&gt; added\n    .uns['graph']['root'] selected root.\n    .uns['graph']['pp_info'] for each PP, its distance vs root and segment assignment.\n    .uns['graph']['pp_seg'] segments network information.\n</pre> <p>tl.pseudotime also assigns cells to:</p> <p>obs. \"seg\", \"milestones\"</p> <p>plot PCA colored by ^^</p> In\u00a0[21]: Copied! <pre>scf.tl.pseudotime(adata,seed=42)\n</pre> scf.tl.pseudotime(adata,seed=42)  <pre>projecting cells onto the principal graph\n    finished (0:00:00) --&gt; added\n    .obs['edge'] assigned edge.\n    .obs['t'] pseudotime value.\n    .obs['seg'] segment of the tree assigned.\n    .obs['milestones'] milestone assigned.\n    .uns['pseudotime_list'] list of cell projection from all mappings.\n</pre> In\u00a0[22]: Copied! <pre>sc.pl.pca(adata, color=[\"seg\", \"milestones\"])\n</pre> sc.pl.pca(adata, color=[\"seg\", \"milestones\"]) In\u00a0[23]: Copied! <pre>sc.pl.pca(adata, color=[\"seg\", \"milestones\"],projection=\"3d\", components = ['1,2,3', '1,3,2'], s=20)\n</pre> sc.pl.pca(adata, color=[\"seg\", \"milestones\"],projection=\"3d\", components = ['1,2,3', '1,3,2'], s=20) <p>You can overlay trajectory, PT, on the embedding with scf.pl.trajectory()</p> In\u00a0[24]: Copied! <pre>scf.pl.trajectory(adata, basis='pca')\n</pre> scf.pl.trajectory(adata, basis='pca') <p>And you can use scany plotting to show pseudotime for each cell</p> In\u00a0[25]: Copied! <pre>sc.pl.pca(adata, color='t')\nsc.pl.pca(adata, color=[\"t\"],projection=\"3d\", components = ['1,2,3', '1,3,2'], s=20)\n</pre> sc.pl.pca(adata, color='t') sc.pl.pca(adata, color=[\"t\"],projection=\"3d\", components = ['1,2,3', '1,3,2'], s=20) <p>cluster cells into a real tree with scf.tl.dendrogram() and plot with scf.pl.dendrogram()</p> In\u00a0[26]: Copied! <pre>scf.tl.dendrogram(adata)\n</pre> scf.tl.dendrogram(adata) <pre>Generating dendrogram of tree\n    segment : 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3/3 [00:00&lt;00:00,  3.29it/s]\n    finished (0:00:00) --&gt; added \n    .obsm['X_dendro'], new embedding generated.\n    .uns['dendro_segments'] tree segments used for plotting.\n</pre> In\u00a0[28]: Copied! <pre>scf.pl.dendrogram(adata, color=['HBA1'])\n</pre> scf.pl.dendrogram(adata, color=['HBA1']) <p>Test for genes whose expresion is associated with PT and branching</p> <p>First, subset the data so that this is quick</p> In\u00a0[39]: Copied! <pre>ad2 = adata.copy()\nad2 = ad2[:,ad2.var['highly_variable']]\n# to speed up execution of test_association, sub-sample the data as below\n# ad2 = ad2[:,np.random.choice(ad2.n_vars, 500, replace=False)]\n\n# you can also specify the number of jobs to run in parallel if you system supports this with the n_jobs parameter\n</pre> ad2 = adata.copy() ad2 = ad2[:,ad2.var['highly_variable']] # to speed up execution of test_association, sub-sample the data as below # ad2 = ad2[:,np.random.choice(ad2.n_vars, 500, replace=False)]  # you can also specify the number of jobs to run in parallel if you system supports this with the n_jobs parameter <p>Now perform the test</p> In\u00a0[75]: Copied! <pre>scf.tl.test_association(ad2, fdr_cut=0.25, A_cut=.4, n_jobs = 20)\n</pre> scf.tl.test_association(ad2, fdr_cut=0.25, A_cut=.4, n_jobs = 20) <pre>test features for association with the trajectory\n    single mapping : 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 4639/4639 [00:49&lt;00:00, 93.67it/s]\n    found 699 significant features (0:00:49) --&gt; added\n    .var['p_val'] values from statistical test.\n    .var['fdr'] corrected values from multiple testing.\n    .var['st'] proportion of mapping in which feature is significant.\n    .var['A'] amplitue of change of tested feature.\n    .var['signi'] feature is significantly changing along pseudotime.\n    .uns['stat_assoc_list'] list of fitted features on the graph for all mappings.\n</pre> <pre>/opt/homebrew/Caskroom/miniforge/base/envs/scFates/lib/python3.12/site-packages/scFates/tools/test_association.py:413: ImplicitModificationWarning: Trying to modify attribute `.var` of view, initializing view as actual.\n  adata.var[c] = stat_assoc[c]\n</pre> In\u00a0[76]: Copied! <pre># ad2.var['signi'].value_counts()\n</pre> # ad2.var['signi'].value_counts()  In\u00a0[77]: Copied! <pre>ad3 = ad2.copy()\nscf.tl.fit(ad3, n_jobs=20) # fits genes to trajectory\nad3.var\n</pre> ad3 = ad2.copy() scf.tl.fit(ad3, n_jobs=20) # fits genes to trajectory ad3.var <pre>fit features associated with the trajectory\n    single mapping :  71%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258f     | 497/699 [00:10&lt;00:04, 48.73it/s]</pre> <pre>/opt/homebrew/Caskroom/miniforge/base/envs/scFates/lib/python3.12/site-packages/joblib/externals/loky/process_executor.py:752: UserWarning: A worker stopped while some jobs were given to the executor. This can be caused by a too short worker timeout or by a memory leak.\n  warnings.warn(\n</pre> <pre>    single mapping :  73%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c     | 510/699 [00:11&lt;00:04, 46.21it/s]</pre> <pre>Numba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\n</pre> <pre>    single mapping : 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 699/699 [00:17&lt;00:00, 39.97it/s]\n    finished (adata subsetted to keep only fitted features!) (0:00:17) --&gt; added\n    .layers['fitted'], fitted features on the trajectory for all mappings.\n    .raw, unfiltered data.\n</pre> Out[77]: Accession Chromosome End Start Strand highly_variable means dispersions dispersions_norm p_val A fdr st signi HP1BP3 ENSG00000127483 1 20787323 20742679 - True 0.769912 1.865717 0.448787 1.181477e-16 0.499296 5.480873e-13 1 True EIF4G3 ENSG00000075151 1 21176888 20806292 - True 0.450619 1.914048 0.730141 1.092165e-93 0.827920 5.066555e-90 1 True HNRNPR ENSG00000125944 1 23344336 23303771 - True 0.582793 1.787895 0.273731 3.026882e-40 0.529806 1.404171e-36 1 True ID3 ENSG00000117318 1 23559501 23557926 - True 0.331609 2.872770 4.198693 4.870580e-212 1.142615 2.259462e-208 1 True RHCE ENSG00000188672 1 25430192 25362249 - True 0.428462 1.796913 0.306358 0.000000e+00 1.337406 0.000000e+00 1 True ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... PGRMC1 ENSG00000101856 X 119244466 119236245 + True 0.555356 1.794529 0.297733 1.834102e-19 0.440285 8.508400e-16 1 True RAB33A ENSG00000134594 X 130184870 130171962 + True 0.470637 1.811213 0.358095 1.758523e-75 0.713661 8.157787e-72 1 True PHF6 ENSG00000156531 X 134428791 134373253 + True 0.425871 1.936639 0.811870 8.659728e-20 0.405178 4.017248e-16 1 True FHL1 ENSG00000022267 X 136211359 136146702 + True 0.591447 2.977816 4.578740 2.898772e-143 1.173347 1.344740e-139 1 True ATP6AP1 ENSG00000071553 X 154436516 154428645 + True 0.499192 1.795571 0.301502 1.386872e-26 0.513673 6.433700e-23 1 True <p>699 rows \u00d7 14 columns</p> In\u00a0[78]: Copied! <pre>ad3.var['st'].value_counts()\n</pre> ad3.var['st'].value_counts() Out[78]: <pre>st\n1    699\nName: count, dtype: int64</pre> In\u00a0[79]: Copied! <pre>scf.pl.single_trend(ad3,\"HBA1\",basis=\"pca\")\n</pre> scf.pl.single_trend(ad3,\"HBA1\",basis=\"pca\") In\u00a0[80]: Copied! <pre>scf.pl.single_trend(ad3,\"ID3\",basis=\"pca\")\n</pre> scf.pl.single_trend(ad3,\"ID3\",basis=\"pca\") In\u00a0[81]: Copied! <pre>scf.pl.single_trend(ad3,\"PF4\",basis=\"pca\")\n</pre> scf.pl.single_trend(ad3,\"PF4\",basis=\"pca\") In\u00a0[82]: Copied! <pre>scf.pl.single_trend(ad3,\"PF4\",basis=\"dendro\")\n</pre> scf.pl.single_trend(ad3,\"PF4\",basis=\"dendro\") In\u00a0[84]: Copied! <pre>scf.pl.single_trend(ad3,\"PF4\",basis=\"dendro\")\nscf.pl.single_trend(ad3,\"HBA1\",basis=\"dendro\")\n</pre> scf.pl.single_trend(ad3,\"PF4\",basis=\"dendro\") scf.pl.single_trend(ad3,\"HBA1\",basis=\"dendro\") In\u00a0[85]: Copied! <pre>scf.tl.test_fork(ad3,root_milestone=\"96\",milestones=[\"66\",\"92\"],n_jobs=20,rescale=True)\n</pre> scf.tl.test_fork(ad3,root_milestone=\"96\",milestones=[\"66\",\"92\"],n_jobs=20,rescale=True) <pre>testing fork\n    single mapping\n    Differential expression:   2%|\u258e            | 15/699 [00:00&lt;00:21, 32.44it/s]</pre> <pre>/opt/homebrew/Caskroom/miniforge/base/envs/scFates/lib/python3.12/site-packages/joblib/externals/loky/process_executor.py:752: UserWarning: A worker stopped while some jobs were given to the executor. This can be caused by a too short worker timeout or by a memory leak.\n  warnings.warn(\n</pre> <pre>    Differential expression:   2%|\u258e            | 16/699 [00:01&lt;01:07, 10.17it/s]</pre> <pre>Numba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\n/opt/homebrew/Caskroom/miniforge/base/envs/scFates/lib/python3.12/site-packages/joblib/externals/loky/process_executor.py:752: UserWarning: A worker stopped while some jobs were given to the executor. This can be caused by a too short worker timeout or by a memory leak.\n  warnings.warn(\n</pre> <pre>    Differential expression:   3%|\u258e            | 18/699 [00:02&lt;01:24,  8.07it/s]</pre> <pre>Numba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\n/opt/homebrew/Caskroom/miniforge/base/envs/scFates/lib/python3.12/site-packages/joblib/externals/loky/process_executor.py:752: UserWarning: A worker stopped while some jobs were given to the executor. This can be caused by a too short worker timeout or by a memory leak.\n  warnings.warn(\n</pre> <pre>    Differential expression:   3%|\u258e            | 20/699 [00:02&lt;01:37,  6.96it/s]</pre> <pre>Numba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\n/opt/homebrew/Caskroom/miniforge/base/envs/scFates/lib/python3.12/site-packages/joblib/externals/loky/process_executor.py:752: UserWarning: A worker stopped while some jobs were given to the executor. This can be caused by a too short worker timeout or by a memory leak.\n  warnings.warn(\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\n</pre> <pre>    Differential expression:   8%|\u2588            | 54/699 [00:05&lt;01:06,  9.66it/s]</pre> <pre>Numba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\n</pre> <pre>    Differential expression:   8%|\u2588            | 58/699 [00:05&lt;01:02, 10.34it/s]</pre> <pre>/opt/homebrew/Caskroom/miniforge/base/envs/scFates/lib/python3.12/site-packages/joblib/externals/loky/process_executor.py:752: UserWarning: A worker stopped while some jobs were given to the executor. This can be caused by a too short worker timeout or by a memory leak.\n  warnings.warn(\n</pre> <pre>    Differential expression:   9%|\u2588            | 60/699 [00:06&lt;01:13,  8.70it/s]</pre> <pre>Numba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\n/opt/homebrew/Caskroom/miniforge/base/envs/scFates/lib/python3.12/site-packages/joblib/externals/loky/process_executor.py:752: UserWarning: A worker stopped while some jobs were given to the executor. This can be caused by a too short worker timeout or by a memory leak.\n  warnings.warn(\n</pre> <pre>    Differential expression:  10%|\u2588\u258e           | 71/699 [00:07&lt;01:09,  9.05it/s]</pre> <pre>Numba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\n/opt/homebrew/Caskroom/miniforge/base/envs/scFates/lib/python3.12/site-packages/joblib/externals/loky/process_executor.py:752: UserWarning: A worker stopped while some jobs were given to the executor. This can be caused by a too short worker timeout or by a memory leak.\n  warnings.warn(\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\n</pre> <pre>    Differential expression:  12%|\u2588\u258c           | 82/699 [00:09&lt;01:14,  8.28it/s]</pre> <pre>Numba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\n</pre> <pre>    Differential expression:  15%|\u2588\u258a          | 102/699 [00:10&lt;00:58, 10.14it/s]</pre> <pre>/opt/homebrew/Caskroom/miniforge/base/envs/scFates/lib/python3.12/site-packages/joblib/externals/loky/process_executor.py:752: UserWarning: A worker stopped while some jobs were given to the executor. This can be caused by a too short worker timeout or by a memory leak.\n  warnings.warn(\n</pre> <pre>    Differential expression:  18%|\u2588\u2588\u258f         | 126/699 [00:11&lt;00:53, 10.78it/s]</pre> <pre>Numba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\n</pre> <pre>    Differential expression:  32%|\u2588\u2588\u2588\u258a        | 225/699 [00:14&lt;00:30, 15.52it/s]</pre> <pre>/opt/homebrew/Caskroom/miniforge/base/envs/scFates/lib/python3.12/site-packages/joblib/externals/loky/process_executor.py:752: UserWarning: A worker stopped while some jobs were given to the executor. This can be caused by a too short worker timeout or by a memory leak.\n  warnings.warn(\n</pre> <pre>    Differential expression:  36%|\u2588\u2588\u2588\u2588\u258e       | 251/699 [00:15&lt;00:28, 15.84it/s]</pre> <pre>Numba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\n</pre> <pre>    Differential expression:  39%|\u2588\u2588\u2588\u2588\u258b       | 273/699 [00:16&lt;00:25, 16.93it/s]</pre> <pre>/opt/homebrew/Caskroom/miniforge/base/envs/scFates/lib/python3.12/site-packages/joblib/externals/loky/process_executor.py:752: UserWarning: A worker stopped while some jobs were given to the executor. This can be caused by a too short worker timeout or by a memory leak.\n  warnings.warn(\n</pre> <pre>    Differential expression:  41%|\u2588\u2588\u2588\u2588\u2589       | 289/699 [00:17&lt;00:25, 16.40it/s]</pre> <pre>Numba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\n</pre> <pre>    Differential expression:  45%|\u2588\u2588\u2588\u2588\u2588\u258d      | 315/699 [00:17&lt;00:21, 17.63it/s]</pre> <pre>/opt/homebrew/Caskroom/miniforge/base/envs/scFates/lib/python3.12/site-packages/joblib/externals/loky/process_executor.py:752: UserWarning: A worker stopped while some jobs were given to the executor. This can be caused by a too short worker timeout or by a memory leak.\n  warnings.warn(\n</pre> <pre>    Differential expression:  48%|\u2588\u2588\u2588\u2588\u2588\u258b      | 333/699 [00:19&lt;00:21, 17.26it/s]</pre> <pre>Numba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\n</pre> <pre>    Differential expression:  95%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d| 666/699 [00:26&lt;00:01, 25.47it/s]</pre> <pre>/opt/homebrew/Caskroom/miniforge/base/envs/scFates/lib/python3.12/site-packages/joblib/externals/loky/process_executor.py:752: UserWarning: A worker stopped while some jobs were given to the executor. This can be caused by a too short worker timeout or by a memory leak.\n  warnings.warn(\n</pre> <pre>    Differential expression: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2589| 697/699 [00:27&lt;00:00, 25.71it/s]</pre> <pre>Numba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\n</pre> <pre>    Differential expression: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 699/699 [00:28&lt;00:00, 24.71it/s]\n    test for upregulation for each leave vs root\n    upreg 66: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 141/141 [00:00&lt;00:00, 1108.33it/s]\n    upreg 92: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 558/558 [00:03&lt;00:00, 143.33it/s]\n    finished (0:00:32) --&gt; added \n    .uns['96-&gt;66&lt;&gt;92']['fork'], DataFrame with fork test results.\n</pre> In\u00a0[86]: Copied! <pre>scf.tl.branch_specific(ad3,root_milestone=\"96\",milestones=[\"66\",\"92\"],effect=0.25)\n</pre> scf.tl.branch_specific(ad3,root_milestone=\"96\",milestones=[\"66\",\"92\"],effect=0.25) <pre>    branch specific features: 92: 276, 66: 48\n    finished --&gt; updated \n    .uns['96-&gt;66&lt;&gt;92']['fork'], DataFrame updated with additionnal 'branch' column.\n</pre> In\u00a0[88]: Copied! <pre>g1=scf.pl.trends(ad3,\n                 root_milestone=\"96\",\n                 milestones=[\"66\", \"92\"],\n                 branch=\"66\",\n                 plot_emb=False,ordering=\"max\",return_genes=True, n_features=12)\n</pre> g1=scf.pl.trends(ad3,                  root_milestone=\"96\",                  milestones=[\"66\", \"92\"],                  branch=\"66\",                  plot_emb=False,ordering=\"max\",return_genes=True, n_features=12)  In\u00a0[89]: Copied! <pre>g2=scf.pl.trends(ad3,\n                 root_milestone=\"96\",\n                 milestones=[\"66\", \"92\"],\n                 branch=\"92\",\n                 plot_emb=False,ordering=\"max\",return_genes=True, n_features=12)\n</pre> g2=scf.pl.trends(ad3,                  root_milestone=\"96\",                  milestones=[\"66\", \"92\"],                  branch=\"92\",                  plot_emb=False,ordering=\"max\",return_genes=True, n_features=12) In\u00a0[90]: Copied! <pre>gg=g1.tolist()+g2.tolist()\n</pre> gg=g1.tolist()+g2.tolist() In\u00a0[91]: Copied! <pre>scf.pl.trends(ad3,gg,figsize=(4,4),annot=\"milestones\",n_features=12,\n        plot_emb=False,ordering=None,return_genes=True)\n</pre> scf.pl.trends(ad3,gg,figsize=(4,4),annot=\"milestones\",n_features=12,         plot_emb=False,ordering=None,return_genes=True)  Out[91]: <pre>Index(['APOE', 'GSTM3', 'EZR', 'HMGB2', 'APOC1', 'NMU', 'MT1X', 'S100A6',\n       'FAM178B', 'MT1G',\n       ...\n       'SPARC', 'TNFAIP8', 'MTSS1', 'FRMD4B', 'GLA', 'NT5C3A', 'TUBB1',\n       'ENDOD1', 'SQSTM1', 'ITM2B'],\n      dtype='object', length=324)</pre> In\u00a0[93]: Copied! <pre>scf.pl.matrix(ad3,gg,norm=\"minmax\",cmap=\"RdBu_r\",colorbar=False)\n</pre> scf.pl.matrix(ad3,gg,norm=\"minmax\",cmap=\"RdBu_r\",colorbar=False) In\u00a0[94]: Copied! <pre>scf.tl.cluster(ad3,n_neighbors=10,metric=\"correlation\")\n</pre> scf.tl.cluster(ad3,n_neighbors=10,metric=\"correlation\") <pre>Clustering features using fitted layer\n    finished (0:00:00) --&gt; added \n    .var['clusters'] identified modules.\n</pre> In\u00a0[95]: Copied! <pre>ad3.var.clusters.unique()\n</pre> ad3.var.clusters.unique() Out[95]: <pre>['5', '1', '4', '8', '0', '3', '6', '7', '9', '2']\nCategories (10, object): ['0', '1', '2', '3', ..., '6', '7', '8', '9']</pre> In\u00a0[96]: Copied! <pre>for c in ad3.var[\"clusters\"].unique():\n    scf.pl.trends(ad3,features=ad3.var_names[ad3.var.clusters==c],basis=\"pca\")\n</pre> for c in ad3.var[\"clusters\"].unique():     scf.pl.trends(ad3,features=ad3.var_names[ad3.var.clusters==c],basis=\"pca\") In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"notebooks/stemness.html","title":"Stemness","text":"In\u00a0[1]: Copied! <pre>import scanpy as sc\nimport numpy as np\nimport pandas as pd\nimport cellrank as cr\nimport scvelo as scv\nimport warnings\nwarnings.simplefilter(\"ignore\", category=UserWarning)\n</pre> import scanpy as sc import numpy as np import pandas as pd import cellrank as cr import scvelo as scv import warnings warnings.simplefilter(\"ignore\", category=UserWarning) In\u00a0[2]: Copied! <pre>adata = sc.read_h5ad(\"data/adRusso22_clusters_abc_sub_031925.h5ad\")\nadata\n</pre> adata = sc.read_h5ad(\"data/adRusso22_clusters_abc_sub_031925.h5ad\") adata Out[2]: <pre>AnnData object with n_obs \u00d7 n_vars = 597 \u00d7 26328\n    obs: 'n_genes_by_counts', 'total_counts', 'total_counts_ribo', 'pct_counts_ribo', 'total_counts_mt', 'pct_counts_mt', 'n_genes', 'n_counts', 'cluster', 'timepoint', 'sorting', 'cellid'\n    var: 'mt', 'ribo', 'n_cells_by_counts', 'mean_counts', 'pct_dropout_by_counts', 'total_counts'</pre> <p>Filter out undetected genes</p> In\u00a0[3]: Copied! <pre>adstart = adata.copy()\nmin_cell_percent = 0.005\nmin_cells = min_cell_percent * adstart.shape[0]\nmin_cells\n</pre> adstart = adata.copy() min_cell_percent = 0.005 min_cells = min_cell_percent * adstart.shape[0] min_cells Out[3]: <pre>2.985</pre> In\u00a0[4]: Copied! <pre>sc.pp.filter_genes(adstart, min_cells = min_cells)\nadstart.shape\n</pre> sc.pp.filter_genes(adstart, min_cells = min_cells) adstart.shape Out[4]: <pre>(597, 17500)</pre> <p>Normalize and define HVG, then PCA</p> In\u00a0[5]: Copied! <pre>n_hvg = 2000\nadstart.layers['counts'] = adstart.X.copy()\nsc.pp.normalize_total(adstart)\nsc.pp.log1p(adstart)\nsc.pp.highly_variable_genes(adstart, n_top_genes=n_hvg, flavor='seurat_v3', layer='counts')\n</pre> n_hvg = 2000 adstart.layers['counts'] = adstart.X.copy() sc.pp.normalize_total(adstart) sc.pp.log1p(adstart) sc.pp.highly_variable_genes(adstart, n_top_genes=n_hvg, flavor='seurat_v3', layer='counts') In\u00a0[6]: Copied! <pre>sc.tl.pca(adstart, mask_var='highly_variable')\nsc.pl.pca_variance_ratio(adstart, 50)\n</pre> sc.tl.pca(adstart, mask_var='highly_variable') sc.pl.pca_variance_ratio(adstart, 50) <p>kNN and UMAP</p> In\u00a0[7]: Copied! <pre>def_npcs = 30\ndef_nneigh = 5\nsc.pp.neighbors(adstart, n_neighbors = def_nneigh,  n_pcs = def_npcs)\nsc.tl.umap(adstart)\n</pre> def_npcs = 30 def_nneigh = 5 sc.pp.neighbors(adstart, n_neighbors = def_nneigh,  n_pcs = def_npcs) sc.tl.umap(adstart) In\u00a0[8]: Copied! <pre>sc.pl.umap(adstart, color=['timepoint', 'Nanog', 'T','Mesp1', 'Tbx6','Sox1', 'Tubb3', 'cluster'], size=80, alpha=.75,frameon=False, ncols=2)\n</pre> sc.pl.umap(adstart, color=['timepoint', 'Nanog', 'T','Mesp1', 'Tbx6','Sox1', 'Tubb3', 'cluster'], size=80, alpha=.75,frameon=False, ncols=2) <p>We will comute two different kernels. First, the ConnectivityKernel that computes cell-cell transitions based purely on transcriptional similarity.</p> In\u00a0[9]: Copied! <pre>from cellrank.kernels import ConnectivityKernel\nck = ConnectivityKernel(adstart, conn_key='connectivities')\nck.compute_transition_matrix()\n</pre> from cellrank.kernels import ConnectivityKernel ck = ConnectivityKernel(adstart, conn_key='connectivities') ck.compute_transition_matrix() Out[9]: <pre>ConnectivityKernel[n=597, dnorm=True, key='connectivities']</pre> <p>Once a transition matrix has been computed, we can use it to take random walks. These simulate the sequence of cell states that a given starting cell state will proceed through over time. In the resulting plot, black and yellow circles are initial and end states, respectively.</p> In\u00a0[10]: Copied! <pre>ck.plot_random_walks(seed=0,n_sims=100,start_ixs={\"cluster\": \"A\"},basis=\"umap\")\n</pre> ck.plot_random_walks(seed=0,n_sims=100,start_ixs={\"cluster\": \"A\"},basis=\"umap\") <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 100/100 [00:00&lt;00:00, 185.51sim/s]\n</pre> <p>You might find it interesting to see how vaying the kNN parameters impact this result.</p> <p>Now, let's run CytoTrace. There is a bit of a word-around that we need to perform in oder to get this to work:</p> In\u00a0[11]: Copied! <pre>adstart.layers[\"spliced\"] = adstart.layers['counts']\nadstart.layers[\"unspliced\"] = adstart.layers['counts']\nscv.pp.moments(adstart, n_pcs=def_npcs, n_neighbors=def_nneigh)\n</pre> adstart.layers[\"spliced\"] = adstart.layers['counts'] adstart.layers[\"unspliced\"] = adstart.layers['counts'] scv.pp.moments(adstart, n_pcs=def_npcs, n_neighbors=def_nneigh) <pre>computing moments based on connectivities\n    finished (0:00:00) --&gt; added \n    'Ms' and 'Mu', moments of un/spliced abundances (adata.layers)\n</pre> In\u00a0[12]: Copied! <pre>from cellrank.kernels import CytoTRACEKernel\nctk = CytoTRACEKernel(adstart).compute_cytotrace()\n</pre> from cellrank.kernels import CytoTRACEKernel ctk = CytoTRACEKernel(adstart).compute_cytotrace() In\u00a0[13]: Copied! <pre>sc.pl.embedding(adstart, color=[\"ct_pseudotime\", \"timepoint\"],basis=\"umap\")\n</pre> sc.pl.embedding(adstart, color=[\"ct_pseudotime\", \"timepoint\"],basis=\"umap\") In\u00a0[14]: Copied! <pre>sc.pl.pca(adstart, color=[\"ct_pseudotime\", \"timepoint\"], projection='3d', ncols=1)\n</pre> sc.pl.pca(adstart, color=[\"ct_pseudotime\", \"timepoint\"], projection='3d', ncols=1) In\u00a0[15]: Copied! <pre>ctk.compute_transition_matrix(threshold_scheme=\"soft\", nu=0.5)\n</pre> ctk.compute_transition_matrix(threshold_scheme=\"soft\", nu=0.5) <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 597/597 [00:00&lt;00:00, 6364.41cell/s]\n</pre> Out[15]: <pre>CytoTRACEKernel[n=597, dnorm=False, scheme='soft', b=10.0, nu=0.5]</pre> <p>We can visualize the transition matrix as a vector field as popularized by RNA velocity.</p> In\u00a0[16]: Copied! <pre>ctk.plot_projection(basis=\"pca\", color=\"cluster\", legend_loc=\"right\", size=75)\n</pre> ctk.plot_projection(basis=\"pca\", color=\"cluster\", legend_loc=\"right\", size=75) In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"notebooks/stemness.html#introduction","title":"Introduction\u00b6","text":"<p>This notebook will show you how to run CytoTrace to infer degree of differentiation as implemented in the the CellRank package. Recall from the CytoTrace paper that this inference is based on the total number of genes expressed.</p> <p>CellRank performs several other useful tasks:</p> <ul> <li>Estimate differentiation direction based a variety of biological priors, including pseudotime, developmental potential, RNA velocity, experimental time points, and more</li> <li>Compute initial, terminal, and intermediate 'macrostates'</li> <li>Infer fate probabilities and identify driver genes</li> <li>Cluster and visualize gene expression trends</li> </ul> <p>In CellRank parlance, kernels are methods that compute cell-cell transition probabilities. Go here to learn more about the different kernels available in CellRank.</p>"},{"location":"notebooks/stemness.html#data","title":"Data\u00b6","text":"<p>adRusso22_clusters_abc_sub_031925.h5ad: Directed differentiation of mouse embryonic stem cells and sampled at day 2, 3, 4, and 5. See Russo et al 2022. We have subset the cells to make it quicker to run this notebook.</p> <p>You can fetch the data from Canvas</p>"},{"location":"notebooks/stemness.html#other-resources","title":"Other resources\u00b6","text":"<ul> <li>CellRank CytoTrace tutorial</li> <li>How to install CellRank</li> <li>CytoTrace2</li> </ul>"},{"location":"notebooks/stemness.html#setup","title":"Setup\u00b6","text":"<p>First, we will import necessary packages and load the data</p>"}]}