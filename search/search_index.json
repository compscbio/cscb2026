{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Computational Stem Cell Biology","text":"<p>This is a companion website for the class</p> <p>EN 580.447/647    Computational Stem Cell Biology Spring, 2026 (3 credits, EQ) Please monitor your email and the Canvas page for notifications and announcements.</p>"},{"location":"index.html#education-team","title":"Education Team","text":"<ul> <li> <p>Patrick Cahan, Ph.D. Course Instructor </p> <p>Associate Professor of Biomedical Engineering</p> <p>patrick [dot] cahan [at] jhmi [dot] edu</p> <p>Office hours: Right after class. Or email me so we can schedule a time.</p> <p> Cahan Lab</p> </li> <li> <p>Communication </p> <p>Email: compscbio@gmail.com </p> </li> <li> <p>Catherine Rutledge Teaching Assistant </p> <p>Ph.D student in Biomedical Engineering</p> <p>crutled3 [at] jh [dot] edu</p> <p>Office hours: TBA</p> </li> </ul>"},{"location":"index.html#class-meetings","title":"Class Meetings","text":"<ul> <li>12noon to 1:15 PM on Tuesdays and Thursdays</li> <li>Maryland Room 110</li> <li>Attendence is encouraged</li> <li>Zoom:<ul> <li>https://wse.zoom.us/j/98485708835</li> <li>Requires authentication via Hopkins SSO to join</li> </ul> </li> </ul>"},{"location":"index.html#course-information","title":"Course Information","text":"<p>This course teaches students about high-throughput, genome-wide single cell measurements, and approaches to appropriately analyze such data. Real world examples from stem cell biology and developmental biology provide the biological context and motivation, but the computational expertise gained will be broadly applicable. Please see the lecture schedule below for specific topics. By the end of this course, the student should</p> <ul> <li> <p>Become conversant in the language of sc-omics technologies</p> </li> <li> <p>Become a confident practitioner in state-of-the art computational methods needed to analyze sc-omic data</p> </li> <li> <p>Learn the fundamentals of stem cell biology</p> </li> <li> <p>Gain experience leveraging sc-omics to address perennial questions in the field</p> </li> </ul>"},{"location":"index.html#recommended-background","title":"Recommended Background","text":"<ul> <li>EN.580.151 \u2013 Structural Biology of Cells , or equivalent</li> <li>Prior hands on experience coding in Python </li> </ul>"},{"location":"index.html#course-goals","title":"Course Goals","text":"<p>This course will address the following 'Criterion 3' Student Outcomes:</p> <ul> <li>An ability to apply knowledge of mathematics, science and engineering to solve problems related to stem cell engineering</li> <li>An ability to analyze and interpret data using statistical, computational or mathematical methods</li> <li>An ability to function on multidisciplinary teams (Criteria 3(d))</li> <li>An understanding of professional and ethical responsibility (Criteria 3(f))</li> <li>An ability to communicate effectively (writing) (Criteria 3(g))</li> <li>An ability to communicate effectively (oral presentation) (Criteria 3(g))</li> </ul>"},{"location":"index.html#course-topics","title":"Course Topics","text":"<ul> <li>Stem cell biology</li> <li>Single cell omics technologies</li> <li>Computational tools for the analysis of single cell omics data</li> </ul>"},{"location":"index.html#ethics","title":"Ethics","text":"<p>The strength of the university depends on academic and personal integrity. In this course, you must be honest and truthful. Ethical violations include plagiarism, reuse of assignments, improper use of the Internet and electronic devices, unauthorized collaboration, alteration of graded assignments, forgery and falsification, lying, facilitating academic dishonesty, and unfair competition. In addition, the specific ethics guidelines for this course are:</p> <ol> <li>Homeworks are to be completed by each student alone. Do not share your projects with other students or use material from prior years.</li> <li>The use of Large language models (LLMs) such as ChatGPT are allowed for the homeworks and final project, when doing so is consistent with the stated Course goals and Course expected outcomes (see above). As a guideline, please use LLMs to augment your understanding of the material in the course, to help you to explore algorithmic ideas that might otherwise be challenging to implement, and more generally, to help you to become a more creative problem-solver.</li> </ol> <p>Report any ethics violations you witness to the teaching team. JHU has more information about university misconduct policies for undergraduate students and graduate students.</p>"},{"location":"index.html#grades","title":"Grades","text":"<ul> <li>Homeworks: 10% per homework. 50% total<ul> <li>Detailed expectations will be described for each HW</li> <li>Individual work; assistance from LLMs is allowed per guidelines in the Ethics section above</li> <li>Assignments submitted up to 24 hours late receive a 20 pt penalty per 24 hours late</li> <li>Assignments will not be accepted after next class has begun (during which the assignment answers will be discussed).</li> </ul> </li> <li>Tests: 12.5% per test. 50% total<ul> <li>1 per module; 4 total</li> <li>No devices allowed; Multiple choice, short and longer answer format</li> </ul> </li> </ul>"},{"location":"glossary.html","title":"Glossary of terms","text":""},{"location":"lecture_schedule.html","title":"Lecture schedule","text":"<ol> <li>Course introduction and overview</li> <li>Stem cell fundamentals, cell identity, and gene expression </li> <li>How does scRNA-seq work?</li> <li>Fundamentals of scRNA-seq analysis (live analysis) <ol> <li>HW1 assigned</li> </ol> </li> <li>Data integration and cell typing</li> <li>Data integration and cell typing (live analysis) HW2 assigned</li> <li>Bio break: basics of development</li> <li>Pseudotime or trajectory inference</li> <li>Pseudotime analysis in practice (live analysis) HW3 assigned</li> <li>Biobreak: Mechanisms that maintain fate potency</li> <li>Cell potency calculators and lineage tracing</li> <li>Cell potency and lineage tracing analysis (live analysis) HW4 assigned</li> <li>Gene regulatory network inference from gene expression data</li> <li>ATAC-seq</li> <li>Regulatory network analysis (live analysis)</li> <li>Simulation engines and expression forecasting  HW5 assigned</li> <li>Simulation engines and expression forecasting (live analysis) Final project distributed</li> <li>Cell-cell interactions inference</li> <li>Cell-cell interaction (live analysis) HW6 assigned</li> <li>Spatial transcriptomics</li> <li>Spatial transcriptomics (live analysis) </li> <li>RNA velocity</li> <li>RNA velocity (live analysis)</li> <li>Controversies and ethical considerations</li> <li>Final group presentations</li> <li>Final group presentations</li> </ol>"},{"location":"readings.html","title":"Readings","text":"<p>In cases where the Pubmed of the paper does not have links to OpenAccess versions of the paper, we will provide a pdf (requires being logged in to Hopkins SSO).</p>"},{"location":"readings.html#week-1-jan-2022-intro-to-course-and-single-cell-omics","title":"Week 1 (Jan 20/22): Intro to course and single cell omics","text":"<ol> <li> <p>NYtimes: A potential cure for type one diabetes</p> </li> <li> <p>Macosko EZ, Basu A, Satija R, et al. Highly Parallel Genome-wide Expression Profiling of Individual Cells Using Nanoliter Droplets. Cell. 2015;161(5):1202-1214. doi:10.1016/j.cell.2015.05.002</p> </li> </ol>"},{"location":"refs.html","title":"References","text":""},{"location":"schedule.html","title":"Schedule","text":"<p>There are four chapters, or broad themes, that we will cover in this course:</p> <ol> <li>single cell genomics</li> <li>cell typing and data integration</li> <li>trajectory inference and differentiation potential</li> <li>gene regulatory networks</li> </ol> <p>Access to lecture videos is available to current students</p> <p>The lecture videos below can only be viewed after authenticating via Hopkin's SSO</p> What Date Chapter Topic video slides other Lecture 1 01-20-26 1 Course introduction intro to course slides Lecture 2 01-22-26 1 scRNAseq data generation dropseq slides Lecture 3 01-27-26 1 Hematopoiesis; scRNAseq analysis I scanpy slides Lecture 4 01-29-26 1 scRNAseq analysis II scanpy2 slides HW 1 due 01-30-26 1 HW1: scRNAseq analysis I hw1 Lecture 5 02-03-26 1 scRNAseq analysis III; cell cycle slides Lecture 6 02-05-26 1 Early applications of sc omics to stem cells slides HW 2 due 02-06-26 1 HW2: more scRNAseq analysis hw2 Test 1 02-10-26 1 sc omics HW 3 due 02-25-26 2 HW3: cell identity hw3 Test 2 03-05-26 2 cell identity HW 4 due 03-27-26 3 HW4: trajectories and fate potential hw4 Test 3 04-02-26 3 trajectories and fate potential HW 5 due 04-17-26 4 HW5: regulatory networks hw5 Test 4 04-23-26 4 regulatory networks"},{"location":"videos.html","title":"Videos","text":"<p>Acces to lecture videos is available to current students</p> <p>The lecture videos below can only be viewed after authenticating via Hopkin's SSO</p> <ol> <li>Course introduction and overview</li> <li>Stem cell fundamentals, cell identity, and gene expression </li> <li>How does scRNA-seq work?</li> <li>Fundamentals of scRNA-seq analysis</li> <li>Data integration and cell typing</li> <li>Data integration and cell typing (live analysis) HW2 assigned</li> <li>Bio break: basics of development</li> <li>Pseudotime or trajectory inference</li> <li>Pseudotime analysis in practice (live analysis) HW3 assigned</li> <li>Biobreak: Mechanisms that maintain fate potency</li> <li>Cell potency calculators and lineage tracing</li> <li>Cell potency and lineage tracing analysis (live analysis) HW4 assigned</li> <li>Gene regulatory network inference from gene expression data</li> <li>ATAC-seq</li> <li>Regulatory network analysis (live analysis)</li> <li>Simulation engines and expression forecasting  HW5 assigned</li> <li>Simulation engines and expression forecasting (live analysis) Final project distributed</li> <li>Cell-cell interactions inference</li> <li>Cell-cell interaction (live analysis) HW6 assigned</li> <li>Spatial transcriptomics</li> <li>Spatial transcriptomics (live analysis) </li> <li>RNA velocity</li> <li>RNA velocity (live analysis)</li> <li>Controversies and ethical considerations</li> <li>Final group presentations</li> <li>Final group presentations</li> </ol>"},{"location":"hws/index.html","title":"Guidelines","text":"<p>Each homework entails applying what you have learned in class to analyze real (or realistic) single cell data. In some cases, you will be asked to devise new approaches to analze the data, or to adapt existing ones. In all cases, you will be asked to interpret your results in the context of the literature to which you have been exposed. Each Homework will have a Deliverables section that explicitly states what you must provide to receive full credit. </p> <p>Check you submissions</p> <p>All submissions must include all code necessary to replicate your results. And the must adhere to the posted guidelines for code documentation, cogent written reports, and meaningful figures (see below).</p>"},{"location":"hws/index.html#style-guide-checklist","title":"Style guide checklist","text":"<p>Before turning in your assignments, please consult this checklist. This will make your work easier for us to understand, so that we can grade efficiently and fairly and provide more useful feedback. Check out the style guide example (below) to see what this looks like in practice. </p> <ul> <li>Organization:<ul> <li> The code and answers are in the same order as the questions in the assignment, OR </li> <li> There are reasonable deviations from the prescribed order, but the first chunk provides a table of contents or clear explanation. </li> </ul> </li> <li>Communication:<ul> <li> Statements about data/results are in Markdown chunks, not code comments.</li> <li> Code comments usually answer \"why?\" not \"what?\"[^1]    </li> </ul> </li> </ul> <p>[^1] Our comments will often violate \"why not what\" because we need to convey what the code does to everyone in the class, even if they are new to Python and/or genomics. By contrast, you are writing for an audience with some experience (us), so you should follow \"why not what\" even if you see us breaking this rule.</p>"},{"location":"hws/final_project.html","title":"Final Project","text":"<p>'I heard the jury is still out on science' --GOB from Arrested Development</p> <p>Now is your chance to flex your single cell analysis muscles. You are a beast. Show us what you can do!  In the final project, you will develop a new analysis method, benchmark it, and then you will use it to address an open question in stem cell biology. </p> <p>Deadline: Wednesday May 7th 11:59pm</p> <p>Absolutely NO Extensions</p> <p>Really, no extensions.</p>"},{"location":"hws/final_project.html#introduction","title":"Introduction","text":"<p>DNA copy number alterations (CNA) have been detected in embryonic stem cells (ESC) and induced pluripotent stem cells (iPSC -- we will refer to pluripotent stem cells of any variety as PSCs). The origins of CNAs in PSCs is varied. Some likely arise as an adaptation to life in culture.<sup>1</sup> Some may arise from somatic mosaicism in iPSC founder cell population<sup>2</sup>. And some may arise during the programming process itself.<sup>3</sup>,<sup>4</sup> </p> <p>CNAs in PSCs can be problematic. The lesions may be tumorigenic, they may hinder differentiation generally or derivation of specific lineages<sup>5</sup>, and they may obscure disease-specific phenotypes when the PSC is used for disease modeling. (Please check out this review<sup>6</sup> and references therein for a comprehensive discussion). Therefore, methods to detect CNAs in PSCs would be highly useful. There are lots of experimental ways to detect CNAs, including karyotyping, FISH, array comparative genomic hybridization, single nucleotide polymorphism (SNP) arrays<sup>3</sup>, and genome sequencing. In 2010, a method called e-karyotyping was published that attempted to infer CNAs based on expression of genes co-located in the genome<sup>7</sup>. This is cool because it leverages data that already exists. In effect, this method is a 'twofer': where you get two things for the price of one. However, it makes the assumption that DNA copy number is reflected by expression levels of genes that are co-located in the genome.</p> <p>The pressing question for your team is to define the distribution of CNAs in human PSCs using available scRNA-seq data. To achieve this, you will have to develop a tool that identifies CNAs from scRNA-seq, evaluate its performance, apply it to PSCs, and synthesize your findings with those previously reported in the literature. More details can be found below as well as specifications that distinguish what is required for 447 and 647 teams.</p> <p>Terminology</p> <p>Sometimes I might refer to CNAs as CNVs. I use these terms interchangably but some might argure that they are different things. Regardless, if you see a mention of 'CNV' here, just mentally substitute in 'CNA'</p>"},{"location":"hws/final_project.html#your-mission","title":"Your mission","text":""},{"location":"hws/final_project.html#task-1-create-a-method-that-infers-cnas-from-scrna-seq-data","title":"Task 1: Create a method that infers CNAs from scRNA-seq data","text":"<p>Write a Python package that allows users to define the genotype and genomic region of CNAs from scRNA-seq data. genotype in this case can be either 'gain' or 'loss'. The minimal input is an annData object that contains raw expression counts of genes that are named in the .var slot across the cells listed in the .obs slot. The output should be:</p> <ol> <li>a list of CNAs where each CNA is defined by genomic region (chromosome, start, stop,) and some indication of the type of CNA (e.g. 'gain' | loss')</li> <li>an assignment of CNAs to cells, or to groups of cells.</li> </ol> <p>This output should be structured to facilitate CNA visualization as we show below. It is OK for your function to add this output to the input adata.</p> <p>Other requirements:</p> <ul> <li>The method must be written in Python</li> <li>The code must be housed at GitHub</li> <li>The code must be organized following Python package conventions. See this tutorial as a guide. Note that you do not have to upload it to PyPI. </li> <li>Your repo must contain documentation that describes how to install your package and how to use it. The easiest place to put this information is in a README.md file.</li> </ul> <p>Here are some more things to consider:</p> <ul> <li>Most of the time, annData objects do not contain genomic regions for their genes, so you need to do something about this. </li> <li>Other attempts to solve this problem include gene-specific normalization based on comparison of each cell or sample to a diploid control. How these control samples use for comparison is selected is important.</li> <li>We recommend that you test your ideas on minimally sufficient slices of the test data that we provide.</li> <li>Check out the following papers and resources for ideas:<ul> <li>Benchmarking CNA prediction methods paper<sup>8</sup></li> <li>Python port of the InferCNV method</li> </ul> </li> </ul>"},{"location":"hws/final_project.html#task-2-assessment","title":"Task 2: Assessment","text":""},{"location":"hws/final_project.html#task-2a-assess-the-performance-of-your-method","title":"Task 2A: Assess the performance of your method","text":"<p>Apply your method to the test data that we provided. Analze your method's performance in terms of standard metrics such as accuracy, or area under precision recall curves. If your method scores CNAs to reflect confidence in their prediction, then also evaluate this aspect. If your method has tunable parameters, then evaluate its performance across a well-justified range of parameter value combinations.</p> <p>Other requirements:</p> <ul> <li>Explore the impact of read depth on your method's performance. Scanpy has functions for down-sampling</li> <li>Notebooks that document this task's analysis must be included in your GitHub repo</li> </ul>"},{"location":"hws/final_project.html#task-2b-augment-assessment-with-better-gold-standard-data","title":"Task 2B: Augment assessment with better gold standard data","text":"<p>647 only!</p> <p>This task is required for only for 647 teams. 447 teams are allowed to complete it for extra credit.</p> <p>The validatation data is very limited. There are only 3 CNAs, and they do not vary much in size or frequency. To assess your method more robustly, generate or acquire gold standard data that has CNAs that:</p> <ul> <li>have wider range of sizes</li> <li>have wider ranges of frequencies</li> </ul> <p>Use this extended gold standard data to evaluate your methods ability to resolve CNAs from small to large, and to detect CNAs across frequencies. </p> <p>If you choose to simulate a gold standard data as we have done, then you must include your simulation functionality in your method's package. If you acquire gold standard data, then you must report the precise source, how the CNA's were defined, and include in your repo any pre-processing of the data required to make it amenable to your analysis.</p> <p>Other requirements: * Notebooks that document this task's analysis must be included in your GitHub repo</p>"},{"location":"hws/final_project.html#task-3-measure-cna-in-pscs","title":"Task 3: Measure CNA in PSCs","text":"<p>Now that you have developed and assessed your method, it is time to use it! Take a look at the list of PSC scRNA-seq data below. Find an optimal subset of these datasets to see if you can infer previously reported PSC CNAs and to discover new ones.</p> <p>Things to consider:</p> <ul> <li>You do not have to analyze all of these data sets</li> <li>You may analyze other data sets that you find as long as they are either human PSCs or their derivatives</li> <li>You may need to integrate data across studies to infer CNAs that are cell line specific</li> </ul> <p>Other requirements: * Notebooks that document this task's analysis must be included in your GitHub repo</p>"},{"location":"hws/final_project.html#task-4-predict-cna-impact","title":"Task 4: Predict CNA impact","text":"<p>Extra credit</p> <p>This task is not required. It is a bonus task and will be scored as extra-credit.</p> <p>Devise and apply a method to predict the functional impact on PSCs of CNAs in catalog that you generated in Task 3. </p> <p>Other requirements: * Notebooks that document this task's analysis must be included in your GitHub repo </p>"},{"location":"hws/final_project.html#deliverables","title":"Deliverables","text":"<p>Your grade in this project has a team component and an individual component. All team members will receive the same grade on the team component, but individuals from the same team can receive different grades on the individual component. Below is a summary of each deliverable in the Team and Individual parts. </p>"},{"location":"hws/final_project.html#team-deliverables","title":"Team deliverables","text":"<ol> <li>A link to a GitHub repository that is home to your Python package. This link should be included in the paper that you send us (see deliverable 2).</li> <li>Write a paper that describes your tool and its application to characterize CNAs in PSCs. Your paper should follow the 'Problem solving article' format described here for the journal Briefings in Bioinformatics. This article type is described as:</li> </ol> <p>Paper format</p> <p>Problem solving protocols: development of methods based on comparison, new software, or new pipeline of existing software for solving a specific bioinformatics problem. Real experimental data must be analyzed. Problem solving protocol papers should demonstrate a new methodological application to a meaningful biological problem. Original algorithms also accepted. (2000-5000 words)</p> <p>Your paper must address how you completed each Task and your results. If your team went after Task 4, then your approach and results should also be included in the paper. You must include display items that clearly represent your work. Please try to format the display items as if you were really going to submit this to a journal. For example, each figure should fit on one page, axes clearly labeled. This makes the reading experience so much more enjoyable for your audience and these positive vibes tend to translate into higher scores.</p> <ol> <li>A pre-recorded presentation in which you show off your tool and what you learned by its application. Send us your slides, too.</li> <li>Attendance at the presentation viewing and Q &amp; A session on the morning of May 12th. At least one team member must participate (in person or via Zoom) and be prepared to answer questions following the showing of their teams video. </li> </ol>"},{"location":"hws/final_project.html#individual-deliverables","title":"Individual deliverables","text":"<ol> <li> <p>Your assessment of your teamates contributions to the final project. </p> <ul> <li>Please score each team member from 1 (superlative) to 10 (unacceptable) in the following categories:<ul> <li>Contributed to team discussions and planning</li> <li>Fulfilled their assigned tasks</li> <li>Timeliness of contributions</li> <li>Responsiveness to intra-team communications</li> <li>Pro-active member of the team</li> </ul> </li> <li>For each team member, write 1-3 sentences that summarizes their role in the project and any other comments</li> </ul> </li> <li> <p>Your assessment of another team's final project. Each student will be assigned to read another teams paper or test their code. In this deliverable, you must score the code or paper with the scoring system: 1 (superlative) to 10 (unacceptable) for the following categories.</p> <ul> <li>Paper<ul> <li>Does the paper address Task 1?</li> <li>Does the paper address Task 2?</li> <li>Does the paper address Task 3?</li> <li>Clarity of writing</li> <li>Depth of thought in discussion</li> <li>Appropriate framing of background in Introduction</li> <li>Use of appropriate display items (i.e. tables and figures)</li> <li>Finish your paper evaluation with a written summary of one paragraph and overall score (1-10). The summary might include specific examples from the paper for improvement or examples of excellent work.</li> </ul> </li> <li>Code<ul> <li>Ease of installation</li> <li>Clarity of documentation, including guidance for any parameter tuning</li> <li>Ease of running example(s) provided in README</li> <li>Experience when applying to a user-provided dataset</li> <li>Reproducibility of Task analysis notebooks</li> </ul> </li> </ul> </li> </ol>"},{"location":"hws/final_project.html#data","title":"Data","text":""},{"location":"hws/final_project.html#cna-benchmarking-data","title":"CNA benchmarking data","text":"<p>PBMC_simulated_cnas_041025.h5ad. We have created a scRNAseq dataset with defined CNAs. It is based on the PBMC data used earlier in course, but we have simulated the impact on expression of genes that overlap with three CNAs. One is on Chr X (a copy number gain), one is on Chr 22 (a homozygous loss -- both alleles were deleted), and one is on Chr 6 (a heterozygous loss -- only one allele was deleted). The CNA genotype (that is, the set of specfic genetic variants of a sample -- in this case, the set of CNAs that a cell has) of each cells is stored in <code>adata.obs[\"simulated_cnvs\"]</code>, which also indicates the precise genomic coordinates of the CNAs and its copy number (CN):</p> <pre><code>adata.obs['simulated_cnvs'].value_counts()\nsimulated_cnvs\n                                                           6312\nX:106533974-112956833 (CN 4)                               1731\n6:25435484-35035259 (CN 1)                                  895\n22:19807132-29743868 (CN 0), 6:25435484-35035259 (CN 1)     700\n22:19807132-29743868 (CN 0)                                 671 \n</code></pre> <p>The CNAs were simulated in a cell-type specific manner, meaning that each CNA appears only in one cell type, but not in all cells of that cell type. In this case, CD4 T cells have the ChrX gain, and CD14 monocytes have the Chr6 and Chr22 losses. This is a bit more complicated a situation that one might expect to face when inferrring CNAs from undifferentiated PSCs, but we include it here because some of the PSC data provided also include differentiated progeny. To quickly view how the CNAs impact expression, you could plot a heatmap in which the cells are the rows, grouped by genotype, and the columns are genes, ordered by genomic position:</p> <pre><code># get slice of cd14 monocytes and Chr22\nadMono = adata[adata.obs['cell_type'] == 'CD14 monocyte'].copy()\nadChr22 = adMono[:,adMono.var['chromosome']=='22'].copy()\n# Raw counts on left\nsc.pl.heatmap(adChr22, adChr22.var_names, groupby='simulated_cnvs',layer=\"counts\", log=True)\n# gene-scaled on right makes the CNA footprint more apparent\nsc.pl.heatmap(adChr22, adChr22.var_names, groupby='simulated_cnvs',layer=\"counts\", log=True, standard_scale='var')\n</code></pre> <p></p> <p>The CNA is evident as a region with no expression in a subset of the cells.</p>"},{"location":"hws/final_project.html#psc-scrnaseq-data","title":"PSC scRNAseq data","text":"<p>Here is a list of publicly available scRNA-seq data of human PSCs and/or their differentiated progeny. Note that in some cases, we were able to easily find the name of the PSC cell line(s), but in other cases you will have to do this yourself.</p> <ol> <li>2D gastruloids<ul> <li>Data: https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE262081</li> <li>Paper: https://pubmed.ncbi.nlm.nih.gov/38585971/</li> </ul> </li> <li>PSC-derived kidney organoids<ul> <li>Data: https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE252104</li> <li>Paper: https://www.ncbi.nlm.nih.gov/pubmed/39482314</li> </ul> </li> <li>iPSC -&gt; HSC<ul> <li>Data: https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE263152</li> </ul> </li> <li>PGP1 line:<ul> <li>https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE277604</li> </ul> </li> <li>Somitoids, days 1 - 5<ul> <li>hiPSC line NCRM1 human IPSC</li> <li>https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE194214</li> <li>https://pubmed.ncbi.nlm.nih.gov/35088712/</li> </ul> </li> <li>hESC -&gt; endothelial<ul> <li>H9 hESC cell line</li> <li>https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE131736</li> <li>https://pubmed.ncbi.nlm.nih.gov/31242503/</li> </ul> </li> <li>Somitoids and segmentoids<ul> <li>https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE195467</li> <li>day 0 -&gt; day 7</li> </ul> </li> <li>CM differentiation<ul> <li>days 0,2,4,10</li> <li>https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE130731</li> <li>2 cell lines were pooled! Can you distinguish them from scRNA-seq?</li> </ul> </li> <li>Fibroblasts reprogrammed to iPSCs<ul> <li>Available from ArrayExpress with accession E-MTAB-10060</li> <li>Paper: https://link.springer.com/article/10.1186/s13059-021-02293-3</li> </ul> </li> <li>Embryoid bodies<ul> <li>Paper: https://www.nature.com/articles/s41467-020-14457-z </li> <li>Data:  https://zenodo.org/records/3625024#.Xil-0y2cZ0s</li> </ul> </li> <li>CM differentiation from PSC<ul> <li>Paper: https://www.ahajournals.org/doi/10.1161/CIRCRESAHA.118.312913?doi=10.1161/CIRCRESAHA.118.312913</li> <li>Data: https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE116555</li> </ul> </li> <li>Embryoid body differentiation from hESCs<ul> <li>https://www.sciencedirect.com/science/article/pii/S2213671119300244</li> </ul> </li> <li>TF overexpression in hiPSCs<ul> <li>Paper: https://pubmed.ncbi.nlm.nih.gov/36608654/</li> <li>Data: https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE216481 </li> </ul> </li> <li>Embryoid bodies<ul> <li>Data: https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE125416</li> <li>Paper: https://www.biorxiv.org/content/10.1101/2022.07.20.500831v2.full</li> </ul> </li> <li>KOLF2.1J iPSC -&gt; neurons<ul> <li>Data: https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE243112</li> <li>Paper: https://www.ncbi.nlm.nih.gov/pubmed/38575728</li> <li>Note that it was later discovered that this cell line harbors some very small CNAs. See https://pmc.ncbi.nlm.nih.gov/articles/PMC11857058/.</li> </ul> </li> <li>hESC to microglia<ul> <li>Data: https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE139550</li> <li>Paper: https://www.ncbi.nlm.nih.gov/pubmed/33558694</li> </ul> </li> <li>PSC -&gt; CM<ul> <li>Note this data is multiplexed and unclear if there is sufficient information in the GEO access to de-multiplex</li> <li>Data: https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE202398</li> <li>Paper: https://elifesciences.org/articles/80075</li> </ul> </li> </ol>"},{"location":"hws/final_project.html#references","title":"References","text":"<ol> <li> <p>Screening ethnically diverse human embryonic stem cells identifies a chromosome 20 minimal amplicon conferring growth advantage Nat Biotechnol. 2011 Nov 27;29(12):1132-44. doi: 10.1038/nbt.2051. PMID: 22119741; \u21a9</p> </li> <li> <p>Abyzov A, Mariani J, Palejev D, Zhang Y, Haney MS, Tomasini L, Ferrandino AF, Rosenberg Belmaker LA, Szekely A, Wilson M, Kocabas A, Calixto NE, Grigorenko EL, Huttner A, Chawarska K, Weissman S, Urban AE, Gerstein M, Vaccarino FM. Somatic copy number mosaicism in human skin revealed by induced pluripotent stem cells. Nature. 2012 Dec 20;492(7429):438-42. doi: 10.1038/nature11629. Epub 2012 Nov 18. PMID: 23160490; PMCID: PMC3532053. \u21a9</p> </li> <li> <p>Laurent LC, Ulitsky I, Slavin I, Tran H, Schork A, Morey R, Lynch C, Harness JV, Lee S, Barrero MJ, Ku S, Martynova M, Semechkin R, Galat V, Gottesfeld J, Izpisua Belmonte JC, Murry C, Keirstead HS, Park HS, Schmidt U, Laslett AL, Muller FJ, Nievergelt CM, Shamir R, Loring JF. Dynamic changes in the copy number of pluripotency and cell proliferation genes in human ESCs and iPSCs during reprogramming and time in culture. Cell Stem Cell. 2011 Jan 7;8(1):106-18. doi: 10.1016/j.stem.2010.12.003. PMID: 21211785; PMCID: PMC3043464. \u21a9\u21a9</p> </li> <li> <p>Hussein SM, Batada NN, Vuoristo S, Ching RW, Autio R, N\u00e4rv\u00e4 E, Ng S, Sourour M, H\u00e4m\u00e4l\u00e4inen R, Olsson C, Lundin K, Mikkola M, Trokovic R, Peitz M, Br\u00fcstle O, Bazett-Jones DP, Alitalo K, Lahesmaa R, Nagy A, Otonkoski T. Copy number variation and selection during reprogramming to pluripotency. Nature. 2011 Mar 3;471(7336):58-62. doi: 10.1038/nature09871. PMID: 21368824. \u21a9</p> </li> <li> <p>Markouli C, Couvreu De Deckersberg E, Regin M, Nguyen HT, Zambelli F, Keller A, Dziedzicka D, De Kock J, Tilleman L, Van Nieuwerburgh F, Franceschini L, Sermon K, Geens M, Spits C. Gain of 20q11.21 in Human Pluripotent Stem Cells Impairs TGF-\u03b2-Dependent Neuroectodermal Commitment. Stem Cell Reports. 2019 Jul 9;13(1):163-176. doi: 10.1016/j.stemcr.2019.05.005. Epub 2019 Jun 6. PMID: 31178415; \u21a9</p> </li> <li> <p>Halliwell J, Barbaric I, Andrews PW. Acquired genetic changes in human pluripotent stem cells: origins and consequences. Nat Rev Mol Cell Biol. 2020 Dec;21(12):715-728. doi: 10.1038/s41580-020-00292-z. Epub 2020 Sep 23. PMID: 32968234. \u21a9</p> </li> <li> <p>Mayshar Y, Ben-David U, Lavon N, Biancotti JC, Yakir B, Clark AT, Plath K, Lowry WE, Benvenisty N. Identification and classification of chromosomal aberrations in human induced pluripotent stem cells. Cell Stem Cell. 2010 Oct 8;7(4):521-31. doi: 10.1016/j.stem.2010.07.017. PMID: 20887957. \u21a9</p> </li> <li> <p>Song M, Ma S, Wang G, Wang Y, Yang Z, Xie B, Guo T, Huang X, Zhang L. Benchmarking copy number aberrations inference tools using single-cell multi-omics datasets. Brief Bioinform. 2025 Mar 4;26(2):bbaf076. doi:10.1093/bib/bbaf076. PMID: 40037644; PMCID: PMC11879432. \u21a9</p> </li> </ol>"},{"location":"hws/guidelines.html","title":"Guidelines","text":"<p>Each homework entails applying what you have learned in class to analyze real (or realistic) single cell data. In some cases, you will be asked to devise new approaches to analze the data, or to adapt existing ones. In all cases, you will be asked to interpret your results in the context of the literature to which you have been exposed. Each Homework will have a Deliverables section that explicitly states what you must provide to receive full credit. </p> <p>Check you submissions</p> <p>All submissions must include all code necessary to replicate your results. And the must adhere to the posted guidelines for code documentation, cogent written reports, and meaningful figures (see below).</p>"},{"location":"hws/guidelines.html#style-guide-checklist","title":"Style guide checklist","text":"<p>Before turning in your assignments, please consult this checklist. This will make your work easier for us to understand, so that we can grade efficiently and fairly and provide more useful feedback. Check out the style guide example (below) to see what this looks like in practice. </p> <ul> <li>Organization:<ul> <li> The code and answers are in the same order as the questions in the assignment, OR </li> <li> There are reasonable deviations from the prescribed order, but the first chunk provides a table of contents or clear explanation. </li> </ul> </li> <li>Communication:<ul> <li> Statements about data/results are in Markdown chunks, not code comments.</li> <li> Code comments usually answer \"why?\" not \"what?\"<sup>1</sup> </li> </ul> </li> </ul> <ol> <li> <p>Our comments will often violate \"why not what\" because we need to convey what the code does to everyone in the class, even if they are new to Python and/or genomics. By contrast, you are writing for an audience with some experience (us), so you should follow \"why not what\" even if you see us breaking this rule.\u00a0\u21a9</p> </li> </ol>"},{"location":"hws/hw_1.html","title":"Homework 1","text":"<p>Homework 1: Fundamentals of scRNA-seq analysis in Python</p> <p>Deadline: Friday, Feb 7th 2025 11:59pm</p>"},{"location":"hws/hw_1.html#background","title":"Background","text":"<p>We discussed hematopoiesis and the types of cells found in peripheral blood mononuclear cells (PBMCs) during Lectures 3-4. We also walked through the analysis of a human PBMC scRNA-seq data set, from CellRanger output to a cleaned anndata object decorated with cell type annotations for each cell. In this homework, you are going to explore what scRNA-seq tells us about PBMC cell type composition, and you are going to explore the impact of varying steps in the analysis pipeline on your estimate of cell type composition.</p> <p>Cell type composition</p> <p>You should think about and compute Cell type composition relative to the total number of cells sampled. For example, after you perform QC on Sample 1, maybe your anndata object has 10,000 cells. Downstream analysis (i.e. all the steps from filtering to annotation) results in 7500 cells labeled as 'T cell'. In this case, the T cell fraction of the cell composition is 75%.</p>"},{"location":"hws/hw_1.html#cell-types-in-pbmcs-and-their-distinctive-genes","title":"Cell types in PBMCs and their distinctive genes","text":""},{"location":"hws/hw_1.html#composition-as-claimed-in-literature","title":"Composition, as claimed in literature","text":"<ul> <li>T cell: 70%</li> <li>B cell: 15%</li> <li>Natural killer (NK) cells: 10%</li> <li>Monocyte: 5%</li> <li>Dendritic cells: 1%</li> </ul>"},{"location":"hws/hw_1.html#marker-genes","title":"Marker genes","text":""},{"location":"hws/hw_1.html#monocytes","title":"Monocytes","text":"<ul> <li>LYZ (Lysozyme), CD14, CD68</li> <li>sub-types:<ul> <li>Classical:  CD14, LYZ, S100A8/S100A9, CCR2</li> <li>Intermediate: FCGR3A (CD16), CD163, IL1B</li> <li>non-classical: CX3CR1, FCGR3A (CD16), CCR5</li> </ul> </li> </ul>"},{"location":"hws/hw_1.html#nk-cell","title":"NK cell","text":"<ul> <li>NCAM1 , KIR2DL1, KIR2DL3, KIR2DL4, KIR3DL1, KIR3DL2, NKG2A/C/E (KLRC1/KLRC2/KLRC3), NKG2D (KLRK1), GNLY, GZMB</li> <li>Note that some are also expressed by subsets of T cell</li> </ul>"},{"location":"hws/hw_1.html#b-cell","title":"B cell","text":"<ul> <li>CD19, CD79A, CD79B, CD20</li> <li>Will leave sub-type exploration to student</li> </ul>"},{"location":"hws/hw_1.html#t-cell","title":"T cell","text":"<ul> <li>CD3D, CD3E, CD3G</li> <li>Will leave sub-type exploration to student</li> </ul>"},{"location":"hws/hw_1.html#dendritic-cell","title":"Dendritic cell","text":"<ul> <li>FLT3, CD11C CD1C</li> <li>CD123 &amp; CLEC4C  (plasmacytoid dendritic cell)</li> </ul>"},{"location":"hws/hw_1.html#granulocytes-and-megakaryocytes","title":"Granulocytes and Megakaryocytes","text":"<ul> <li>were not widely recognized as occupying PBMC</li> <li>If student suspects they may then they should identify and include makers thereof in their analysis.</li> </ul>"},{"location":"hws/hw_1.html#data","title":"Data","text":""},{"location":"hws/hw_1.html#sample-1","title":"Sample 1","text":"<p>This is the same Sample 1 as we used in Lecture 4. Here are some more details: - 10k PBMCs from a Healthy Donor (v3 chemistry) Single Cell Gene Expression Dataset by Cell Ranger 3.0.0 - Peripheral blood mononuclear cells (PBMCs) from a healthy donor (the same cells were used to generate pbmc_1k_v2, pbmc_10k_v3). PBMCs are primary cells with relatively small amounts of RNA (~1pg RNA/cell). - 11,769 cells detected by CellRanger - Sequenced on Illumina NovaSeq with approximately 54,000 reads per cell - 10X Genomics web page for this data - URL to h5 file: https://cf.10xgenomics.com/samples/cell-exp/3.0.0/pbmc_10k_v3/pbmc_10k_v3_filtered_feature_bc_matrix.h5 - file name: pbmc_10k_v3_filtered_feature_bc_matrix.h5</p> <p>Your mission</p> <p>Analyze the provided data to address the questions listed below</p> <ol> <li> <p>What is the cell type composition of PBMCs of Sample 1?</p> <p>Deliverables:</p> <ul> <li> new .obs column indicating cell type</li> <li> appropriate visualization (i.e. UMAP with clusters labeled, supported by dotplot that shows exwpression of marker genes)</li> </ul> </li> <li> <p>How does this estimate of cell composition compare to prior literature?     To evaluate this rapidly and efficiently, write a function that will take a list of anndata objects that have cell annotations, and produces stacked barplot figure, one bar for scRNAseq, one for proportions from literature. each rectangle in a bar reflects % of sample annotated as cell type X.</p> <p>Deliverables:</p> <ul> <li> The function definition</li> <li> Use of the function to produce the stacked boxplot that shows the cell type proportions from scRNAseq and from literature</li> </ul> </li> <li> <p>What are the transcriptional signatures of each of the PBMC cell types? We know about some genes that are preferentially expressed in each PBMC cell type (in fact, you used some of these to perform cluster annotation). But one of the benefits of performing genome-wide analyses is that it can identify genes previously unlinked to the phenomenon under study. Your task here is to identify all genes that are preferentially expressed in each PBMC cell type. </p> <p>Deliverables:</p> <ul> <li> One list per cell type containing genes defined by the student as 'preferentially  expressed' in the corresponding cell type.</li> <li> Visualization: dot plot showing expression and % cells expressed of the top X genes per cell type</li> </ul> </li> </ol> <p>ALL SUBMISSIONS MUST...</p> <p>... include all code necessary to replicate the results, and must adhere to posted guidelines for code documentation, cogent written reports, and meaningful figures.</p>"},{"location":"hws/hw_2.html","title":"Homework 2","text":"<p>Homework 2: Parameter Parcheesi</p> <p>Deadline: Tuesday, Feb 18th 2025 11:59pm</p>"},{"location":"hws/hw_2.html#background","title":"Background","text":"<p>This homework will ask you to to explore the impact of varying steps in the scRNA-seq analysis pipeline (as applied in HW1) on your estimate of cell type composition.</p> <p>Data</p> <p>We are using data from HW1 as well as a few more PBMC samples.</p>"},{"location":"hws/hw_2.html#data","title":"Data","text":""},{"location":"hws/hw_2.html#sample-1","title":"Sample 1","text":"<p>This is the same Sample 1 as we used in Lecture 4. Here are some more details:</p> <ul> <li>10k PBMCs from a Healthy Donor (v3 chemistry) Single Cell Gene Expression Dataset by Cell Ranger 3.0.0</li> <li>Peripheral blood mononuclear cells (PBMCs) from a healthy donor (the same cells were used to generate pbmc_1k_v2, pbmc_10k_v3). PBMCs are primary cells with relatively small amounts of RNA (~1pg RNA/cell).</li> <li>11,769 cells detected by CellRanger</li> <li>Sequenced on Illumina NovaSeq with approximately 54,000 reads per cell</li> <li>10X Genomics web page for this data</li> <li>pbmc_10k_v3_filtered_feature_bc_matrix.h5</li> </ul>"},{"location":"hws/hw_2.html#sample-2","title":"Sample 2","text":"<p>Here are some more details:</p> <ul> <li>20k Human PBMCs, 3\u2019 HT v3.1, Chromium X</li> <li>Sourced from a healthy female donor</li> <li>23,837 cells</li> <li>35,000 reads per cell</li> <li>link to downlad</li> </ul>"},{"location":"hws/hw_2.html#sample-3","title":"Sample 3","text":"<p>This sample was not included in Lecture 4. </p> <ul> <li>Single Cell 3' v2</li> <li>2,909 cells</li> <li>115,061 reads per cell</li> <li>healthy donor</li> <li>download</li> </ul>"},{"location":"hws/hw_2.html#your-mission","title":"Your mission","text":"<p>Analyze the provided data to address the following questions:</p> <ol> <li>You are curious about some of the steps in the processing pipeline. While some seem reasonable, others seem highly arbitrary. How does altering the pipeline impact cell composition estimates? If so, in what ways?<ul> <li>Specifically, determine how each of the following changes (independently) impacts the estimated cell composition (as applied to Sample 1 data):<ul> <li>Don't filter cells based on MT content</li> <li>Don't filter cells based on total counts</li> <li>Don't normalize expression (so skip both <code>sc.pp.normalize_total()</code> and <code>sc.pp.log1p()</code></li> <li>Don't use PCs for kNN graph</li> <li>Test extreme values of n_pcs (e.g. n_pcs = 3, n_pcs = 50) when computing kNN graph</li> <li>Test extreme values of n_neighbors when computing kNN graph</li> <li>How do each pipeline variant above alter the cell type gene signatures that you defined? </li> </ul> </li> <li>Deliverables:<ul> <li>Efficient visualisation of the cell type proportions across pipeline variant. Ideally the students will use their barplot function and pass it the adatas that result from annotation each of the outcomes of each variation to the pipeline.</li> <li>Written summary detailing effect of each change to the pipeline and an explanation (or speculation) for this result.</li> </ul> </li> </ul> </li> <li>To what extent do cell type compositions (as estimated by scRNA-seq) vary between samples? From your work on qustion 1 above, you have arrived at an opinion as to the best pipeline. Apply that to pipeline the additional two PBMC samples (i.e. Sample 2 and Sample 3). Compare all three to the proportion estimates from the literature (see HW1). Do you think that the variation that you observe in the scRNAseq-based estimates primarily reflect real biological variation, or do they reflect technical variation due to the vicissitudes of scRNAseq data generation and analysis?<ul> <li>Deliverables:<ul> <li>stacked barplots showing cell type compositions across samples and literature</li> <li>Written answer to questions about source of variation plus justification.</li> </ul> </li> </ul> </li> <li>Adult stem cells are not as numerous as their downstream progeny and so you wonder about the factors that impact scRNA-seq's sensitivty for detecting such rare populations. Some factors include read depth (the number of UMIs per cell), size of the 'rare' population, the degree of distinctness of its transcriptome, and the analysis pipeline steps and parameters (among many other factors). Use existing Scanpy functions to explore the impact of read depth, population size, and analysis pipeline steps/parameters on the power to detect rare populations.<ul> <li>Deliverables:<ul> <li>Written report including the strategy (including what cell type(s) treated as 'rare' population'), rationale, and general lessons derived from the analyses with relevant figures. What is the most important factor? What is the minimum population size (expressed as fraction of total number of cells in sample) that yields a detectable distinct cluster? How does this vary with read depth? Do variations in the pipeline alter the chance of detecting the rare population?</li> </ul> </li> </ul> </li> </ol> <p>ALL SUBMISSIONS MUST...</p> <p>... include all code necessary to replicate the results, and must adhere to posted guidelines for code documentation, cogent written reports, and meaningful figures.</p>"},{"location":"hws/hw_3.html","title":"Homework 3","text":"<p>The Mandocellorian: This is the way (to cell typing)</p> <p>The overall goal of this homework is for you to gain a sophisticated understanding of these 'cell-typing' techniques and their relative merits in the context of cell fate engineering.</p> <p>Deadline: Monday, March 3rd 2025 11:59pm</p>"},{"location":"hws/hw_3.html#background","title":"Background","text":"<p>We have discussed different approaches for determining the identity of cells in scRNAseq data, including:</p> <ol> <li>Manual annotation by identifying known marker occurrence in clusters. Sometimes referred to as 'cluster-then-annotate'<sup>1</sup></li> <li>Integration with a reference data set for which cell annotations have been determined<sup>2</sup></li> <li>Applying a classifier that has been trained on a reference data set<sup>3</sup></li> </ol> <p>We have provided three scRNAseq data sets as described in the 'Data' section below. You will use these data and the 3 cell-typing approaches (i.e. 'cluster-then-annotate', BKKNN, and PySingleCellNet) to address the questions listed below. </p> <p>A bit of important background: Cell fate engineering (e.g. directed differentiation, direct conversion, etc) frequently generates populations of cells that exhibit mixed identities. Let's call these hybrids. Unlike the Tooth Fairy, Easter Bunny, or Santa Claus, hybrids are real (sorry if that was a spoiler). Hybrids are not doublets. And hybrids are not frequently observed in physiological contexts. In other words, we do not see them in scRNA-seq atlases from nominally normal tissues. </p>"},{"location":"hws/hw_3.html#question-1","title":"Question 1","text":"<p>How do manual annotation, classification, and integration compare in terms of accurately and sensitively predicting cell type identity? You should answer this by using each method to predict cell identities of the validation data. Select the best metric(s), compute these metrics for each method, and compare the results to answer the question.</p>"},{"location":"hws/hw_3.html#question-2","title":"Question 2","text":"<p>How do you think an ideal cell-typing method should handle hybrids? Discuss strategies for distinguishing true hybrids from doublets. The answer to this part does not require code or analysis. You just need to cogently describe your viewpoint. Keep in mind various use cases, such as application to cells from 'normal tissues', to cells from pathological contexts, and to cells derived via cell fate engineering.</p>"},{"location":"hws/hw_3.html#question-3","title":"Question 3","text":"<p>How well do the three cell-typing methods above perform when analyzing populations that include hybrids? To answer this question, you should</p> <ul> <li> <p>Generate synthetic hybrids by summing or averaging the expression profiles of cells of different identities from the validation data. You should generate various hybrid populations based on the cell types mixed, and the proportion of each. You could even explore which genes to use rather than randomly sampling from all genes.</p> </li> <li> <p>Combine your new synthetic data that includes hybrids with the validation data to make a new validation data set</p> </li> <li> <p>Predict cell identity of the new validation data using all three cell-typing methods</p> </li> <li> <p>Compute prediction metrics of all three cell-typing methods</p> </li> <li> <p>Please characterize the types of failures that are common and unique to each method and discuss how these failures could impact the analysis of real engineered cell</p> </li> </ul>"},{"location":"hws/hw_3.html#question-4","title":"Question 4","text":"<p>How does transplantation affect engineered pancreatic-like cells? More specifically:</p> <ul> <li> <p>Does the proportion of cells of uncertain identity change?</p> </li> <li> <p>Do the proportion of cell types differ between transplanted and non-transplanted cells? If so, do you think that these differences reflect real biology or could they just reflect sampling variation?</p> </li> <li> <p>How does transplantation affect transcriptional state of the cell types? To answer this ...</p> <ul> <li> <p>Use the cell-type predictions of the query data from your preferred cell-typing method</p> </li> <li> <p>For each cell type, perform differential gene expression analysis comparing transplanted vs non-transplanted cells of that cell type</p> <ul> <li> <p>What are the top 10 genes differentially expressed? Select a maximally informative and efficient visualization to show these genes and their expression patterns in the transplanted vs non-transplanted cells.</p> </li> <li> <p>What biological processes or pathways distinguish the transplanted and non-transplanted cells? You should answer this by performing enrichment analysis. As above, select a maximally informative and efficient visualization to illustrate these pathways.</p> </li> </ul> </li> <li> <p>Are there shared genes across pancreatic cell types that are commonly dysregulated in un-transplanted versus transplanted cells? </p> </li> </ul> </li> </ul>"},{"location":"hws/hw_3.html#extra-credit","title":"Extra-credit","text":"<p>Implement a function that computes a 'hybrid identity' score. Use this function to evaluate my assertion above that hybrid cells are not typically seen in normal contexts but are observed in engineered populations.</p>"},{"location":"hws/hw_3.html#data","title":"Data","text":"<p>The training and validation data sets are of human cadaver-derived pancreatic islet cells. The query data set is derived from pluripotent stem cells that have been engineered with the intention of producing insulin-producing beta cells. Some of the engineered cells were transplanted into mice and subsequently recovered to see how the in vivo environment impacted their identity. All scRNAseq data here was produced using the 10x platform. We have performed some data cleaning and trimming.</p>"},{"location":"hws/hw_3.html#training-data","title":"Training data<sup>4</sup>","text":"<ul> <li>Sorted human pancreatic islet cells from 3 donors</li> <li>raw counts</li> <li>cells QC-ed</li> <li>cell type annotation in .obs['cell_type']</li> <li>h5ad: adTrain_n110_CSCB_HW3.h5ad</li> </ul>"},{"location":"hws/hw_3.html#validation-data","title":"Validation data<sup>5</sup>","text":"<ul> <li>pancreatic islets from 4 donors</li> <li>raw counts</li> <li>cells QC-ed</li> <li>cell type annotation in .obs['cell_type']</li> <li>h5ad: adValidation_n300_CSCB_HW3.h5ad</li> </ul>"},{"location":"hws/hw_3.html#query-data","title":"Query data<sup>6</sup>","text":"<ul> <li>Directed differentiation of hESCs and iPSCs towards beta-like cells (6 stage differentiation)</li> <li>transplanted into mouse kidney capsule, then cells subsequently recovered</li> <li>cells QC-ed and contaminating mouse cells removed</li> <li>raw counts</li> <li>h5ad: adQuery_n2000_CSCB_HW3.h5ad</li> </ul>"},{"location":"hws/hw_3.html#marker-genes","title":"Marker genes","text":"<p>Here are solid marker genes of the major cell types that you can expect to encounter in this HW:</p> <pre><code>marker_genes_dict = {\n    'Acinar': ['PRSS2', 'REG1A'],\n    'Ductal': ['MMP7', 'KRT19'],\n    'Alpha': ['GCG', 'TTR', 'HIGD1A'],\n    'Beta': ['INS', 'IAPP', \"G6PC2\"],\n    'Delta': ['SST', 'RBP4', 'LEPR'],\n    'Gamma': ['PPY', 'ID2', \"GCNT3\"],\n    'Episilon': [\"GHRL\", \"NNMT\", \"APOH\"],\n    'Macrophage': ['IFI30', 'LAPTM5'],\n    'Mast': ['TPSB2', \"PTPRC\"],\n    'Stellate': ['COL1A2', 'COL6A2'],\n}\n</code></pre> <ol> <li> <p>Challenges in unsupervised clustering of single-cell RNA-seq data. Kiselev VY, Andrews TS, Hemberg M. Nat Rev Genet. 2019 May;20(5):273-282. doi: 10.1038/s41576-018-0088-9. PMID: 30617341 \u21a9</p> </li> <li> <p>Benchmarking atlas-level data integration in single-cell genomics. Luecken MD, B\u00fcttner M, Chaichoompu K, Danese A, Interlandi M, Mueller MF, Strobl DC, Zappia L, Dugas M, Colom\u00e9-Tatch\u00e9 M, Theis FJ. Nat Methods. 2022 Jan;19(1):41-50. doi: 10.1038/s41592-021-01336-8. Epub 2021 Dec 23. PMID: 34949812 \u21a9</p> </li> <li> <p>SingleCellNet: A Computational Tool to Classify Single Cell RNA-Seq Data Across Platforms and Across Species.Tan Y, Cahan P. Cell Syst. 2019 Aug 28;9(2):207-213.e2. doi: 10.1016/j.cels.2019.06.004. Epub 2019 Jul 31. PMID: 31377170 \u21a9</p> </li> <li> <p>van Gurp L, Fodoulian L, Oropeza D, Furuyama K, Bru-Tari E, Vu AN, Kaddis JS, Rodr\u00edguez I, Thorel F, Herrera PL. Generation of human islet cell type-specific identity genesets. Nat Commun. 2022 Apr 19;13(1):2020. doi: 10.1038/s41467-022-29588-8. PMID: 35440614 \u21a9</p> </li> <li> <p>Xin Y, Dominguez Gutierrez G, Okamoto H, Kim J, Lee AH, Adler C, Ni M, Yancopoulos GD, Murphy AJ, Gromada J. Pseudotime Ordering of Single Human \u03b2-Cells Reveals States of Insulin Production and Unfolded Protein Response. Diabetes. 2018 Sep;67(9):1783-1794. doi: 10.2337/db18-0365. Epub 2018 Jun 27. PMID: 29950394 \u21a9</p> </li> <li> <p>Augsornworawat P, Maxwell KG, Velazco-Cruz L, Millman JR. Single-Cell Transcriptome Profiling Reveals \u03b2 Cell Maturation in Stem Cell-Derived Islets after Transplantation. Cell Rep. 2020 Aug 25;32(8):108067. doi: 10.1016/j.celrep.2020.108067. Erratum in: Cell Rep. 2021 Mar 9;34(10):108850. PMID: 32846125 \u21a9</p> </li> </ol>"},{"location":"hws/hw_4.html","title":"Homework 4","text":"<p>Do you believe in fate, Neo?</p> <p>The overall goal of this homework is for you to gain experience in using trajectory inference (TI) and cell fate potency methods. </p> <p>Deadline: Tues, March 25th 2025 11:59pm</p>"},{"location":"hws/hw_4.html#background","title":"Background","text":"<p>Gastrulation marks the point during embryonic development at which some pluripotent epiblast cells commit to endoderm or mesoderm fates. Gastrulation initiates with posterior epiblast cells undergoing an epithelial-to-mesenchymal transition (EMT). These cells delaminate, ingress through, and ultimately migrate away from, the primitive streak.  The fate of many embryonic cells and their progeny are determined by where and when they undergo this process. In general, cells located anteriorly and that delaminte early during gastrulation (i.e. anterior primitive streak or APS) are fated to become definitive endoderm (DE) cells. Cells that delaminate later and are located more posteriorly are generally fated to become mesoderm lineages cells. </p> <p>We have provided a scRNA-seq data set from mouse embryos at the gastrula-stage as described in the Data section. In brief, it consists of epiblast cells, nascent mesoderm, anterior primitive streak, and visceral endoderm cells from E6.5 to E8.5 stage mouse embryos. Starting at E6.5, some epiblast cells will undergo the processes described above, and they will ultimately give rise to definitive endoderm or mesoderm cells. However, visceral endoderm cells are specified earlier in development and are not derived from the epiblast cells present in this data set. </p> <p>TI pitfalls</p> <ol> <li>TI analysis typically assumes that the input cells are developmentally interlinked. Even when data violate this assumption, most TI methods will still try to link them purely on the basis of transcriptional similarity. This is bad. </li> <li>TI analysis also typically requires the user to input a start point or 'root' of a trajectory. </li> </ol>"},{"location":"hws/hw_4.html#task-1-perform-cell-typing","title":"Task 1: Perform cell-typing","text":"<p>Before you can reliably appy TI to this data, you must perform cell-typing to (A) identify and exclude VE cells, and (B) to identify the epiblast, mesoderm, and anterior primitive streak cells. This will allow you to suggest a root for the TI analysis. To help you with this part, here are some well-established marker genes:</p> <ul> <li>Epiblast: Utf1, Slc7a3, Pou3f1</li> <li>Mesoderm: Mesp1, Fgf3, Snai1</li> <li>Anterior primitive streak: Foxa2, Gsc, Sox17</li> <li>Visceral endoderm: Use your highly refined literature-mining skills to find these. Please select 3-5 genes that are reported to be VE-specific from the literature. You must cite the primary papers in which each gene has been demonstrated to be a marker of murine VE. </li> </ul> <p>You will know that you are done with Task 1 when you have clearly annotated each cell and have excluded the VE cells from the input data.</p>"},{"location":"hws/hw_4.html#task-2-infer-trajectory-and-pseudotime","title":"Task 2: Infer trajectory and pseudotime","text":"<p>Use scFates to reconstruct a trajectory that connects epiblast to APS, and epiblast to mesoderm. Then predict the pseudotime for each cell. To receive full credit for Part 2, you must infer the tree, justify your parameter selections, and visualize the resulting tree with labeled branches and milestones, and visualize pseudotime.</p>"},{"location":"hws/hw_4.html#task-3-discover-regulators-of-differentiation","title":"Task 3: Discover regulators of differentiation","text":"<p>What transcription factors might promote the transition from epiblast to mesoderm or to endoderm? Develop a critiera for ranking transcription factors (TFs) accoring to their predicted importance or influence on differentiation. This could be simply the p-value from scFates's association test, or you might conceive of other criteria. Use this criteria to select the top X TFs (where X &gt;4) that specifically promotes mesoderm or endoderm differentiation from the epiblast. Mine the literature around each of your candidate TFs to assess the extent to which your criteria and application of scFates recovered bona fide regulators of gastrulation. Your answer should cite the primary papers that you use here. You must have two sets of X candidates TFs, one for mesoderm differentiation, and one for endoderm differentiation.</p>"},{"location":"hws/hw_4.html#task-4-discover-regulators-of-pluripotency","title":"Task 4: Discover regulators of pluripotency","text":"<p>What transcription factors potentially oppose epiblast cells from differentiation, and thus promote pluripotency? Perform the same kind of analysis as you did for Task 3 here, but now apply it to find TFs that inhibit epiblast differentaition.</p>"},{"location":"hws/hw_4.html#task-5-compare-cytotrace-to-pseudotime","title":"Task 5: Compare Cytotrace to pseudotime","text":"<p>To what extent do Cytotrace and scFtes pseudotime agree? Compute Cytotrace's cell potency on this data and compute its correlation with scFates pseudotime. Do they agree? If not, perform further analyses to explore why this might be the case. </p>"},{"location":"hws/hw_4.html#data","title":"Data","text":""},{"location":"hws/hw_4.html#scrna-seq-data-of-mouse-gastrulation-embryonic-cells","title":"scRNA-seq data of mouse gastrulation embryonic cells","text":"<ul> <li>h5ad: adHW3_2024.h5ad</li> <li>Includes only VE, APS, nascent mesoderm, and epiblast cells</li> <li>We have already performed cell quality control. You will want to perform gene quality control and standard downstream processing.</li> <li>There should be roughly equivalent numbers of cells per population.</li> </ul>"},{"location":"hws/hw_4.html#list-of-mouse-transcription-factors","title":"List of mouse transcription factors:","text":"<ul> <li>allTFs_mm_aertslab_011924.txt</li> </ul>"},{"location":"hws/hw_5.html","title":"Homework 5","text":"<p>Warning</p> <p>The goal of this homework is for you to gain experience in using gene regulatory network inference methods and to apply them to simulate cell state dynamics.</p> <p>Deadline: Thurs, April 3rd 2025 11:59pm</p>"},{"location":"hws/hw_5.html#background","title":"Background","text":"<p>We have discussed why groups are attempting to engineer cell fate, and we have discussed various experimental approaches, namely directed differentiation of pluripotent stem cells and direct conversion from one somatic cell type into another. We have also seen how time-consuming and resource-intensive it is to try to empirically devise experimental protocols to produce a given cell type. Several computational tools have been invented to amerliorate this problem. In general, these methods tend to leverage expression data and regulatory networks in an attempt to prioritize targeting the most impactful nodes. The overall goal of this homework is for you to gain some experience with computational methods for cell fate engineering. This will entail reversen engineering gene regulatory networks, and using them to simulate the effect of over-expressing and knocking down transcription factors on fate outcomes. You will also build on what you have learned about trajectory inference and cell typing to complete this homework.</p> <p>Your mission is to predict a minimal set of perturbations to apply to mouse embryonic stem cells so that they will differentiate to a) nascent mesoderm, and to b) anterior primitive streak/nascent endoderm. To achieve this, you will be asked to reverse engineer the GRN that underpins the differentiation of epiblast to mesoderm or APS/endoderm, and then use this GRN to simulate the fate outcome from perturbing TFs that you select. We have provied a scRNA-seq data set (specifications in Data section) that you are now familar with: it is the mouse embryo data set of epiblast cells, nascent mesoderm, and anterior primitive streak cells. This is the data set that you should use to infer the GRN. Note that we have excluded visceral endoderm cells from this data set. We have also provided a scRNA-seq data set of mouse embryonic stem cells in an undifferentiated state, which should be used to set the initial state of the cells for your simulations.</p>"},{"location":"hws/hw_5.html#task-1-trajectory-inference","title":"Task 1: trajectory inference","text":"<p>After loading the gastrulation data, use scFates to reconstruct a trajectory tree that connects epiblast to APS, and epiblast to mesoderm, and also use scFates to predict a pseudotime for each cell. If you did well on HW4 part 2, this part should be super easy for you.</p>"},{"location":"hws/hw_5.html#task-2-tf-selection","title":"Task 2: TF selection","text":"<p>Select 10-15 TFs to use for GRN reconstruction. You can choose to use functions in scFates to identify these TFs, or another approach such as differential gene expression, or another method of your choicee. Describe how you identified these TFs and justify why your choice is a good one.</p>"},{"location":"hws/hw_5.html#task-3-reconstruct-gene-regulatory-network","title":"Task 3: Reconstruct gene regulatory network","text":"<p>Use oneSC to infer the GRN assoicated with the gastrulation data set. You need to limit your analysis to TFs identified in Task 2, and ensure that the state graph is consistent with what you know about development. If oneSC's state graph conflicts with this, then you should manually define this.</p>"},{"location":"hws/hw_5.html#task-4-find-minimal-tf-set","title":"Task 4: Find minimal TF set","text":"<p>Devise a strategy to predict a minimal set of TFs that, when perturbed in mouse embryonic stem cells, will yield the highest proportion of APS cells. Your method should be based on the GRN you inferred in Task 3, and optionally on the scRNA-seq data provided below. Use the method to generate a set of candidate TFs and then check how your prediction performs by simulating the impact of the perturbation using oneSC. You should compare the performance of your method to a judiciously chosen baseline method.</p> <p>Now apply your method to predict TFs to perturb in mESCs to yield the highest proportion of nascent mesoderm cells. Evaluate your predictions as above (i.e. perform simulations with your perturbations, qunatify cell type numbers, and compare to results using a baseline method). </p> <p>Did your method outperform the baseline method? Discuss why or why not.</p>"},{"location":"hws/hw_5.html#data","title":"Data","text":""},{"location":"hws/hw_5.html#list-of-mouse-transcription-factors","title":"List of mouse transcription factors:","text":"<ul> <li>allTFs_mm_aertslab_011924.txt</li> </ul>"},{"location":"hws/hw_5.html#scrna-seq-data-of-mouse-gastrulation-embryonic-cells","title":"scRNA-seq data of mouse gastrulation embryonic cells","text":"<ul> <li>h5ad: adHW5_EpiMesoAPS_n500.h5ad</li> <li>Includes only APS, nascent mesoderm, and epiblast cells</li> <li>We have already performed cell quality control. You will want to perform gene quality control and standard downstream processing.</li> </ul>"},{"location":"hws/hw_5.html#scrna-seq-data-of-pluripotent-mouse-embryonic-stem-cells","title":"scRNA-seq data of pluripotent mouse embryonic stem cells","text":"<ul> <li>h5ad: adHW5_mESC.h5ad</li> </ul>"},{"location":"hws/hw_example.html","title":"Example homework assignment","text":"<p>Warning</p> <p>This is not a real assignment for CSCB! It's just a realistic example to demonstrate the style guide.</p>"},{"location":"hws/hw_example.html#goal","title":"Goal","text":"<p>The goal of this assignment is to give you some experience in data wrangling and quality control of scRNA-seq data.</p>"},{"location":"hws/hw_example.html#due-date-jan-1st-2001","title":"Due date: Jan 1st, 2001.","text":""},{"location":"hws/hw_example.html#data","title":"Data","text":"<p>In this assignment, you will perform a few initial steps in the analysis of a dataset from a tech-dev paper showing off an unusual combination of cababilities. The paper includes several large experiments with genetic perturbations followed by a scRNA-seq readout (Replogle et al 2020). These assays are applied to mostly the K562 leukemia cell line.  We'll focus on just the CRISPRa multiplexing experiment, which does gene overexpression followed by scRNA. </p>"},{"location":"hws/hw_example.html#your-mission","title":"Your mission","text":""},{"location":"hws/hw_example.html#task-1","title":"Task 1","text":"<ul> <li>Tidy the dataset so that it fits in an AnnData object.</li> <li>For each overexpressed gene, how many cells are measured?</li> </ul>"},{"location":"hws/hw_example.html#task-2","title":"Task 2","text":"<ul> <li>Compute typical scRNA quality metrics and filter out genes and cells as discussed in class.</li> <li>As you apply each filter, print the number of cells remaining so that anyone following your code can see which filtering steps are most impactful.</li> </ul>"},{"location":"hws/hw_example.html#task-3","title":"Task 3","text":"<ul> <li>Write code to visualize the data using scanpy.</li> <li>Run the code and describe the results.</li> </ul>"},{"location":"hws/hw_example.html#resources","title":"Resources","text":"<p>You may use the provided code (<code>ingestion.py</code>) to convert gene names from Ensembl gene id's (example: <code>ENSG00000109101</code>) to more readable Entrez gene symbols (example: <code>Foxn1</code>).</p>"},{"location":"hws/hw_example.html#deliverables","title":"Deliverables","text":"<p>A Jupyter notebook that contains documented code achieving Tasks 1, 2, and 3. For an example submission, [['HWEX Done']].</p>"},{"location":"lectures/index.html","title":"Schedule","text":"<p>There are four chapters, or broad themes, that we will cover in this course:</p> <ol> <li>single cell genomics</li> <li>cell typing and data integration</li> <li>trajectory inference and differentiation potential</li> <li>gene regulatory networks</li> </ol> <p>Access to lecture videos is available to current students</p> <p>The lecture videos below can only be viewed after authenticating via Hopkin's SSO</p> Lecture Date Chapter Topic link to video lecture slides 1 01-20-26 1 Course introduction intro to course slides 2 01-22-26 1 scRNAseq data generation dropseq slides <pre><code>             |\n</code></pre> <p>| 2      | 01-23-25 | Single cell biology | game show video | NA | | 3      | 01-28-25 | scRNAseq data generation | dropseq | slides | | 4      | 01-30-25 | Scanpy tutorial | scanpy analysis | notebook | | 5      | 02-04-25 | Data integration and cell typing | hcl,scmap,bbknn,scn | slides| | 6      | 02-06-25 | Integration &amp; typing tutorial | cell typing and integration | notebook | | 7      | 02-11-25 | Trajectory inference and pseudotime | theory | TI slides| | 8      | 02-13-25 | TI tutorial | video | notebook | | 9     | 02-18-25 | Fate potency and stemness (pre-recorded) | video | slides | | 10     | 02-20-25 | How-to infer fate potency (pre-recorded) | video | notebook | | 11     | 02-25-25 | Gene regulatory networks  | video | slides| | 12     | 02-27-25 | scGRN | video | slides | | 13     | 03-04-25 | Computational approaches to cell fate engineering | video | slides | | 14      | 03-06-25 | Simulating single cell trajectories | video | slides | | 15      | 03-11-25 | Intro to ST and Cell-to-cell communications | video | slides | | 16      | 03-13-25 | Machine Learning for Spatial and Network Biology (In Malone 228; Uhtsav Chitra) | - | -| | --      | 03-18-25 | Spring break | - | - | | --      | 03-20-25 | Spring break | - | - | | 17      | 03-25-25 | Early development and signaling| video | slides | | 18      | 03-27-25 | Till and McCulloch | video | slides | | 19      | 04-01-25 | Final project overview | video | slides | | 20      | 04-03-25 | Epigenomics | video | slides | | 21      | 04-08-25 | Multiomics | video | slides | | 22      | 04-15-25 | Chromatin accessibility &amp; ChIP-seq analysis | video | slides | | 23A      | 04-17-25 | RNA Velocity | video | slides | | 23B      | 04-17-25 | Cell modeling | video | slides | | 24      | 04-22-25 | Controversies in the stem cell world | - | - | | 25      | 04-24-25 | Clinical trials with stem cells | - | - |</p>"},{"location":"lectures/topics.html","title":"Lectures","text":"<p>The topics that we cover can be broadly split into three categories: stem cell biology, single cell data generation platforms, and computational methods for analyses of these data.</p> <p>!!warning \"Acces to lecture videos is available to current students\"</p> <pre><code>The lecture videos below can only be viewed after authenticating via [Hopkin's SSO](https://my.jh.edu/html/myjh.html)\n</code></pre> Number Date Topic link to video slides 1 01-21-25 Course introduction video topics/intro.md 2 01-23-25 Single cell biology [topics/"},{"location":"lectures/topics.html#stem-cell-biology","title":"(Stem) cell biology","text":"<p>We will cover some basic cell biology and then discuss the main areas of focus in stem cell biology.</p> <ul> <li>Stem cell biology basics</li> <li>Cell identity</li> <li>Development and differentiation</li> <li>Cell fate engineering</li> <li>Gene regulatory networks</li> <li>Cell-to-cell communication</li> <li>Controversies</li> </ul>"},{"location":"lectures/topics.html#single-cell-data-generation-platforms","title":"Single cell data generation platforms","text":"<p>The course will mainly use scRNA-seq data but we will also discuss other data modalities.</p> <ul> <li>Single cell RNA-seq</li> <li>Single cell ATAC-seq</li> <li>Spatial transcriptomics</li> <li>Lineage tracing</li> </ul>"},{"location":"lectures/topics.html#computational-methods","title":"Computational methods","text":"<p>In addition to the basic standard analysis pipelines, we will also cover more advanced methods.</p> <ul> <li>Integration and cell typing</li> <li>Trajectory inference</li> <li>Fate potential</li> <li>Forecasting and simulations</li> </ul>"},{"location":"notebooks/index.html","title":"Topics","text":"<p>The topics covered can be broadly split into three categories: stem cell biology, single cell data generation platforms, and computational methods for analyses of these data.</p>"},{"location":"notebooks/index.html#stem-cell-biology","title":"(Stem) cell biology","text":"<p>We will cover some basic cell biology and then discuss the main areas of focus in stem cell biology.</p> <ul> <li>Stem cell biology basics</li> <li>Cell identity</li> <li>Development and differentiation</li> <li>Cell fate engineering</li> <li>Gene regulatory networks</li> <li>Cell-to-cell communication</li> <li>Controversies</li> </ul>"},{"location":"notebooks/index.html#single-cell-data-generation-platforms","title":"Single cell data generation platforms","text":"<p>The course will mainly use scRNA-seq data but we will also discuss other data modalities.</p> <ul> <li>Single cell RNA-seq</li> <li>Single cell ATAC-seq</li> <li>Spatial transcriptomics</li> <li>Lineage tracing</li> </ul>"},{"location":"notebooks/index.html#computational-methods","title":"Computational methods","text":"<p>In addition to the basic standard analysis pipelines, we will also cover more advanced methods.</p> <ul> <li>Integration and cell typing</li> <li>Trajectory inference</li> <li>Fate potential</li> <li>Forecasting and simulations</li> </ul>"},{"location":"notebooks/colab.html","title":"Colab","text":""},{"location":"notebooks/colab.html#google-colab","title":"Google Colab\u00b6","text":"<p>You may already know about Jupyter and how to use it. For this course, students are encouraged to use Google's Colab cloud platform to perform analysis of scRNA-seq data. This platform allows users to run analyses on the cloud for free using Jupyter. But, you need a Google account to do so.</p> <ol> <li><p>Please create a Google account, if you do not already have one.</p> </li> <li><p>Log in to your Google account, if you are not already logged in.</p> </li> <li><p>Test your access to Google Colab. You should see a screen like the following:</p> </li> </ol> Screenshot of Colab diaglog box <ol> <li><p>Create a new notebook. If you see the dialog shown above, then click 'create notebook'. You can also create a notebook using the Menu at the top of the page: File -&gt; New notebook in Drive. Either will result in the launching of a new Jupyter notebook.</p> </li> <li><p>The End. You are done and can close the browser page on Colab.</p> </li> </ol>"},{"location":"notebooks/hwex_done.html","title":"Hwex done","text":"<p>This is not a real assignment for CSCB! It's just a realistic example to demonstrate the style guide.</p> In\u00a0[7]: Copied! <pre>import warnings\nwarnings.filterwarnings('ignore')\nimport os\nimport shutil\nimport importlib\nimport matplotlib.colors as colors\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nimport scanpy as sc\nimport seaborn as sns\nimport anndata\nfrom IPython.display import display, HTML\n\n# Import the code provided with the assignment\nimport importlib\nimport sys\nsys.path.append(\"setup\")\nimport ingestion\nimportlib.reload(ingestion)\n\n# visualization settings\n%matplotlib inline\nplt.rcParams['figure.figsize'] = [6, 4.5]\nplt.rcParams[\"savefig.dpi\"] = 300\n\n# Some useful gene annotation files\ngeneAnnotationPath = \"../accessory_data/gencode.v35.annotation.gtf.gz\"       # Downloaded from https://www.gencodegenes.org/human/release_35.html\ncellcycleGenePath = \"../accessory_data/regev_lab_cell_cycle_genes.txt\"\n</pre> import warnings warnings.filterwarnings('ignore') import os import shutil import importlib import matplotlib.colors as colors import matplotlib.pyplot as plt import numpy as np import pandas as pd import scanpy as sc import seaborn as sns import anndata from IPython.display import display, HTML  # Import the code provided with the assignment import importlib import sys sys.path.append(\"setup\") import ingestion importlib.reload(ingestion)  # visualization settings %matplotlib inline plt.rcParams['figure.figsize'] = [6, 4.5] plt.rcParams[\"savefig.dpi\"] = 300  # Some useful gene annotation files geneAnnotationPath = \"../accessory_data/gencode.v35.annotation.gtf.gz\"       # Downloaded from https://www.gencodegenes.org/human/release_35.html cellcycleGenePath = \"../accessory_data/regev_lab_cell_cycle_genes.txt\"   In\u00a0[8]: Copied! <pre># Reading from .mtx is slow, so we memoize to h5ad. \ndataset_name = \"replogle\"\nif not os.path.exists(f\"not_ready/{dataset_name}/GSM4367986_exp8/overall.h5ad.gzip\"):\n    expression_quantified = sc.read_10x_mtx(f\"not_ready/{dataset_name}/GSM4367986_exp8/\")\n    expression_quantified.write_h5ad(f\"not_ready/{dataset_name}/GSM4367986_exp8/overall.h5ad.gzip\", compression=\"gzip\")\nelse:\n    expression_quantified = sc.read_h5ad(f\"not_ready/{dataset_name}/GSM4367986_exp8/overall.h5ad.gzip\")\n</pre> # Reading from .mtx is slow, so we memoize to h5ad.  dataset_name = \"replogle\" if not os.path.exists(f\"not_ready/{dataset_name}/GSM4367986_exp8/overall.h5ad.gzip\"):     expression_quantified = sc.read_10x_mtx(f\"not_ready/{dataset_name}/GSM4367986_exp8/\")     expression_quantified.write_h5ad(f\"not_ready/{dataset_name}/GSM4367986_exp8/overall.h5ad.gzip\", compression=\"gzip\") else:     expression_quantified = sc.read_h5ad(f\"not_ready/{dataset_name}/GSM4367986_exp8/overall.h5ad.gzip\") In\u00a0[9]: Copied! <pre># Typical reshaping of data and computation of QC metrics\nsc.pp.calculate_qc_metrics(expression_quantified, inplace = True)\ncell_metadata = pd.read_csv(f\"not_ready/{dataset_name}/GSM4367986_exp8/cell_identities.csv.gz\")\ncell_metadata.index = cell_metadata[\"cell_barcode\"]\ncell_metadata[\"target_symbol\"] = ingestion.convert_ens_to_symbol(\n    cell_metadata[\"target\"], \n    gtf=geneAnnotationPath, \n    strip_version = True)\nexpression_quantified.obs = pd.merge(expression_quantified.obs,\n                                     cell_metadata, \n                                     how = \"left\", \n                                     left_index = True, \n                                     right_index = True)\n\nexpression_quantified.obs[\"has_guide_annotations\"] = pd.notnull(expression_quantified.obs[\"coverage\"]).astype(\"int\")\nexpression_quantified.obs[\"good_coverage\"] = expression_quantified.obs[\"good_coverage\"].astype(\"str\")\nexpression_quantified.raw = expression_quantified.copy()\n</pre> # Typical reshaping of data and computation of QC metrics sc.pp.calculate_qc_metrics(expression_quantified, inplace = True) cell_metadata = pd.read_csv(f\"not_ready/{dataset_name}/GSM4367986_exp8/cell_identities.csv.gz\") cell_metadata.index = cell_metadata[\"cell_barcode\"] cell_metadata[\"target_symbol\"] = ingestion.convert_ens_to_symbol(     cell_metadata[\"target\"],      gtf=geneAnnotationPath,      strip_version = True) expression_quantified.obs = pd.merge(expression_quantified.obs,                                      cell_metadata,                                       how = \"left\",                                       left_index = True,                                       right_index = True)  expression_quantified.obs[\"has_guide_annotations\"] = pd.notnull(expression_quantified.obs[\"coverage\"]).astype(\"int\") expression_quantified.obs[\"good_coverage\"] = expression_quantified.obs[\"good_coverage\"].astype(\"str\") expression_quantified.raw = expression_quantified.copy() In\u00a0[10]: Copied! <pre>expression_quantified = expression_quantified[~expression_quantified.obs.target_symbol.isna(), :]\n</pre> expression_quantified = expression_quantified[~expression_quantified.obs.target_symbol.isna(), :] In\u00a0[11]: Copied! <pre>expression_quantified.var_names = ingestion.convert_ens_to_symbol(\n    expression_quantified.var_names, \n    gtf=geneAnnotationPath, \n)\ndisplay(expression_quantified.var.head())\ndisplay(expression_quantified.var_names[0:5])\n</pre> expression_quantified.var_names = ingestion.convert_ens_to_symbol(     expression_quantified.var_names,      gtf=geneAnnotationPath,  ) display(expression_quantified.var.head()) display(expression_quantified.var_names[0:5]) gene_ids feature_types n_cells_by_counts mean_counts log1p_mean_counts pct_dropout_by_counts total_counts log1p_total_counts RP11-34P13.3 ENSG00000243485 Gene Expression 14 0.000127 0.000127 99.987326 14.0 2.708050 FAM138A ENSG00000237613 Gene Expression 0 0.000000 0.000000 100.000000 0.0 0.000000 OR4F5 ENSG00000186092 Gene Expression 0 0.000000 0.000000 100.000000 0.0 0.000000 RP11-34P13.7 ENSG00000238009 Gene Expression 343 0.003105 0.003100 99.689486 343.0 5.840641 RP11-34P13.8 ENSG00000239945 Gene Expression 55 0.000498 0.000498 99.950209 55.0 4.025352 <pre>Index(['RP11-34P13.3', 'FAM138A', 'OR4F5', 'RP11-34P13.7', 'RP11-34P13.8'], dtype='object')</pre> In\u00a0[13]: Copied! <pre>n_cells_per_target = expression_quantified.obs.groupby(\"target_symbol\")[[\"cell_barcode\"]].count().sort_values(\"cell_barcode\")\nn_cells_per_target.columns = [\"n_cells\"]\nn_cells_per_target.reset_index(inplace = True)\ndisplay(n_cells_per_target)\nplt.rcParams['figure.figsize'] = [6, 9]\n</pre> n_cells_per_target = expression_quantified.obs.groupby(\"target_symbol\")[[\"cell_barcode\"]].count().sort_values(\"cell_barcode\") n_cells_per_target.columns = [\"n_cells\"] n_cells_per_target.reset_index(inplace = True) display(n_cells_per_target) plt.rcParams['figure.figsize'] = [6, 9] target_symbol n_cells 0 CEBPB 212 1 LHX4 238 2 PTPN1 284 3 CDKN1B 303 4 TBX21 315 ... ... ... 59 TTC6 1513 60 RPL30 1712 61 MTOR 1735 62 MAP2K3 1861 63 Non-Targeting 5126 <p>64 rows \u00d7 2 columns</p> In\u00a0[14]: Copied! <pre>sc.pl.highest_expr_genes(expression_quantified, n_top=30, palette=\"Blues\", width=.3)\n</pre> sc.pl.highest_expr_genes(expression_quantified, n_top=30, palette=\"Blues\", width=.3) In\u00a0[15]: Copied! <pre>expression_quantified.var['mt']   = expression_quantified.var_names.str.startswith((\"MT-\"))\nexpression_quantified.var['ribo'] = expression_quantified.var_names.str.startswith((\"RPS\",\"RPL\"))\nexpression_quantified.var['mt'].sum(), expression_quantified.var['ribo'].sum(),\n</pre> expression_quantified.var['mt']   = expression_quantified.var_names.str.startswith((\"MT-\")) expression_quantified.var['ribo'] = expression_quantified.var_names.str.startswith((\"RPS\",\"RPL\")) expression_quantified.var['mt'].sum(), expression_quantified.var['ribo'].sum(),  Out[15]: <pre>(13, 103)</pre> In\u00a0[16]: Copied! <pre>sc.pp.calculate_qc_metrics(expression_quantified, qc_vars=['ribo', 'mt'], percent_top=None, log1p=False, inplace=True)\n</pre> sc.pp.calculate_qc_metrics(expression_quantified, qc_vars=['ribo', 'mt'], percent_top=None, log1p=False, inplace=True) In\u00a0[17]: Copied! <pre>axs = sc.pl.violin(expression_quantified, ['n_genes_by_counts', \n                                           'total_counts', \n                                           'pct_counts_mt', \n                                           'pct_counts_ribo', \n                                           'pct_counts_in_top_50_genes'], \n                   jitter=0.5, multi_panel=True)\n</pre> axs = sc.pl.violin(expression_quantified, ['n_genes_by_counts',                                             'total_counts',                                             'pct_counts_mt',                                             'pct_counts_ribo',                                             'pct_counts_in_top_50_genes'],                     jitter=0.5, multi_panel=True) In\u00a0[18]: Copied! <pre>fig, ax = plt.subplots(1,1,figsize=(2,2))\nsc.pl.scatter(expression_quantified, x='total_counts', y='n_genes_by_counts', ax=ax)\n</pre> fig, ax = plt.subplots(1,1,figsize=(2,2)) sc.pl.scatter(expression_quantified, x='total_counts', y='n_genes_by_counts', ax=ax) In\u00a0[19]: Copied! <pre>print(\"Number of cells: \", expression_quantified.n_obs)\n\n# figure out the total counts == 95 percentile\nthresh = np.percentile(expression_quantified.obs['total_counts'], 99)\nprint(\"99th percentile: \", thresh)\n</pre> print(\"Number of cells: \", expression_quantified.n_obs)  # figure out the total counts == 95 percentile thresh = np.percentile(expression_quantified.obs['total_counts'], 99) print(\"99th percentile: \", thresh) <pre>Number of cells:  60725\n99th percentile:  17000.280000000006\n</pre> In\u00a0[20]: Copied! <pre>expression_quantified = expression_quantified[expression_quantified.obs['total_counts'] &lt; thresh, :].copy()\nprint(\"Number of cells: \", expression_quantified.n_obs)\n</pre> expression_quantified = expression_quantified[expression_quantified.obs['total_counts'] &lt; thresh, :].copy() print(\"Number of cells: \", expression_quantified.n_obs) <pre>Number of cells:  60117\n</pre> In\u00a0[21]: Copied! <pre>expression_quantified = expression_quantified[expression_quantified.obs[\"total_counts\"] &gt;= 2000, :].copy()\nprint(\"Number of cells: \", expression_quantified.n_obs)\n</pre> expression_quantified = expression_quantified[expression_quantified.obs[\"total_counts\"] &gt;= 2000, :].copy() print(\"Number of cells: \", expression_quantified.n_obs) <pre>Number of cells:  58809\n</pre> In\u00a0[22]: Copied! <pre>expression_quantified = expression_quantified[expression_quantified.obs[\"pct_counts_in_top_50_genes\"] &lt;= 40, :].copy()\nprint(\"Number of cells: \", expression_quantified.n_obs)\n</pre> expression_quantified = expression_quantified[expression_quantified.obs[\"pct_counts_in_top_50_genes\"] &lt;= 40, :].copy() print(\"Number of cells: \", expression_quantified.n_obs) <pre>Number of cells:  58589\n</pre> In\u00a0[23]: Copied! <pre># filter for % mt\nexpression_quantified = expression_quantified[expression_quantified.obs['pct_counts_mt'] &lt; 20, :].copy()\nprint(\"Number of cells: \", expression_quantified.n_obs)\n</pre> # filter for % mt expression_quantified = expression_quantified[expression_quantified.obs['pct_counts_mt'] &lt; 20, :].copy() print(\"Number of cells: \", expression_quantified.n_obs) <pre>Number of cells:  58484\n</pre> In\u00a0[24]: Copied! <pre># filter for % ribo &gt; 50%\nexpression_quantified = expression_quantified[expression_quantified.obs['pct_counts_ribo'] &lt; 30, :].copy()\nprint(\"Number of cells: \", expression_quantified.n_obs)\n</pre> # filter for % ribo &gt; 50% expression_quantified = expression_quantified[expression_quantified.obs['pct_counts_ribo'] &lt; 30, :].copy() print(\"Number of cells: \", expression_quantified.n_obs) <pre>Number of cells:  58415\n</pre> In\u00a0[25]: Copied! <pre>\"\"\" To verify the outcome of filtering cells \"\"\"\nsc.pp.calculate_qc_metrics(expression_quantified, qc_vars=['ribo', 'mt'], percent_top=None, log1p=False, inplace=True)\n</pre> \"\"\" To verify the outcome of filtering cells \"\"\" sc.pp.calculate_qc_metrics(expression_quantified, qc_vars=['ribo', 'mt'], percent_top=None, log1p=False, inplace=True) In\u00a0[26]: Copied! <pre>axs = sc.pl.violin(expression_quantified, ['n_genes_by_counts', \n                                           'total_counts', \n                                           'pct_counts_mt', \n                                           'pct_counts_ribo', \n                                           'pct_counts_in_top_50_genes'], \n                   jitter=0.4, multi_panel=True)\n</pre> axs = sc.pl.violin(expression_quantified, ['n_genes_by_counts',                                             'total_counts',                                             'pct_counts_mt',                                             'pct_counts_ribo',                                             'pct_counts_in_top_50_genes'],                     jitter=0.4, multi_panel=True) In\u00a0[27]: Copied! <pre>fig, ax = plt.subplots(1,1,figsize=(2,2))\nsc.pl.scatter(expression_quantified, x='total_counts', y='n_genes_by_counts', ax=ax)\n</pre> fig, ax = plt.subplots(1,1,figsize=(2,2)) sc.pl.scatter(expression_quantified, x='total_counts', y='n_genes_by_counts', ax=ax) In\u00a0[28]: Copied! <pre>print(\"Number of genes: \", expression_quantified.n_vars)\ngThresh = 10\n\nsc.pp.filter_genes(expression_quantified, min_cells=gThresh)\nprint(\"Number of genes: \", expression_quantified.n_vars)\n</pre> print(\"Number of genes: \", expression_quantified.n_vars) gThresh = 10  sc.pp.filter_genes(expression_quantified, min_cells=gThresh) print(\"Number of genes: \", expression_quantified.n_vars) <pre>Number of genes:  33694\nNumber of genes:  18811\n</pre> In\u00a0[30]: Copied! <pre>mito_genes = expression_quantified.var_names.str.startswith('MT-')\nribo_genes = expression_quantified.var_names.str.startswith((\"RPL\",\"RPS\"))\nmalat_gene = expression_quantified.var_names.str.startswith(\"MALAT1\")\n</pre> mito_genes = expression_quantified.var_names.str.startswith('MT-') ribo_genes = expression_quantified.var_names.str.startswith((\"RPL\",\"RPS\")) malat_gene = expression_quantified.var_names.str.startswith(\"MALAT1\") In\u00a0[32]: Copied! <pre>remove = np.add(mito_genes, ribo_genes)\nremove = np.add(remove, malat_gene)\nkeep = np.invert(remove)\nexpression_quantified = expression_quantified[:,keep].copy()\nprint(\"Number of genes: \", expression_quantified.n_vars)\n</pre> remove = np.add(mito_genes, ribo_genes) remove = np.add(remove, malat_gene) keep = np.invert(remove) expression_quantified = expression_quantified[:,keep].copy() print(\"Number of genes: \", expression_quantified.n_vars) <pre>Number of genes:  18700\n</pre> In\u00a0[33]: Copied! <pre>[idx for idx, n in enumerate(expression_quantified.var.index) if n.upper() == 'GAPDH']\n</pre> [idx for idx, n in enumerate(expression_quantified.var.index) if n.upper() == 'GAPDH'] Out[33]: <pre>[11180]</pre> In\u00a0[34]: Copied! <pre>sc.pl.highest_expr_genes(expression_quantified, n_top=20, palette=\"Blues\", width=.3)\n</pre> sc.pl.highest_expr_genes(expression_quantified, n_top=20, palette=\"Blues\", width=.3) In\u00a0[35]: Copied! <pre>\"\"\" To verify the outcome of filtering genes \"\"\"\nsc.pp.calculate_qc_metrics(expression_quantified, qc_vars=['ribo', 'mt'], percent_top=None, log1p=False, inplace=True)\n</pre> \"\"\" To verify the outcome of filtering genes \"\"\" sc.pp.calculate_qc_metrics(expression_quantified, qc_vars=['ribo', 'mt'], percent_top=None, log1p=False, inplace=True) In\u00a0[36]: Copied! <pre>axs = sc.pl.violin(expression_quantified, ['n_genes_by_counts', \n                                           'total_counts', \n                                           'pct_counts_mt', \n                                           'pct_counts_ribo', \n                                           'pct_counts_in_top_50_genes'], \n                   jitter=0.4, multi_panel=True)\n</pre> axs = sc.pl.violin(expression_quantified, ['n_genes_by_counts',                                             'total_counts',                                             'pct_counts_mt',                                             'pct_counts_ribo',                                             'pct_counts_in_top_50_genes'],                     jitter=0.4, multi_panel=True) In\u00a0[37]: Copied! <pre>fig, ax = plt.subplots(1,1,figsize=(2,2))\nsc.pl.scatter(expression_quantified, x='total_counts', y='n_genes_by_counts', ax=ax)\n</pre> fig, ax = plt.subplots(1,1,figsize=(2,2)) sc.pl.scatter(expression_quantified, x='total_counts', y='n_genes_by_counts', ax=ax) In\u00a0[44]: Copied! <pre>sc.pp.log1p(expression_quantified)\nsc.pp.highly_variable_genes(expression_quantified, min_mean=0.2, max_mean=4, min_disp=0.2, n_bins=50)\nsc.pl.highly_variable_genes(expression_quantified)\nwith warnings.catch_warnings():\n    sc.tl.pca(expression_quantified, n_comps=100)\nsc.pp.neighbors(expression_quantified)\nsc.tl.umap(expression_quantified)\nclusterResolutions = []\nsc.tl.leiden(expression_quantified)\ncc_genes = pd.read_csv(cellcycleGenePath, header = None)[0]\nsc.tl.score_genes_cell_cycle(expression_quantified, s_genes=cc_genes[:43], g2m_genes=cc_genes[43:])\nplt.rcParams['figure.figsize'] = [6, 4.5]\n</pre> sc.pp.log1p(expression_quantified) sc.pp.highly_variable_genes(expression_quantified, min_mean=0.2, max_mean=4, min_disp=0.2, n_bins=50) sc.pl.highly_variable_genes(expression_quantified) with warnings.catch_warnings():     sc.tl.pca(expression_quantified, n_comps=100) sc.pp.neighbors(expression_quantified) sc.tl.umap(expression_quantified) clusterResolutions = [] sc.tl.leiden(expression_quantified) cc_genes = pd.read_csv(cellcycleGenePath, header = None)[0] sc.tl.score_genes_cell_cycle(expression_quantified, s_genes=cc_genes[:43], g2m_genes=cc_genes[43:]) plt.rcParams['figure.figsize'] = [6, 4.5]  <pre>WARNING: adata.X seems to be already log-transformed.\n</pre> <pre>WARNING: genes are not in var_names and ignored: ['MLF1IP']\n</pre> In\u00a0[43]: Copied! <pre>sc.pl.umap(expression_quantified, color = [\n    # \"PTPRC\",\n    \"leiden\", \n    'total_counts', \n    'log1p_total_counts',\n    'pct_counts_in_top_50_genes', \n    'has_guide_annotations',\n    \"phase\",\n    \"target_symbol\",\n])\n</pre> sc.pl.umap(expression_quantified, color = [     # \"PTPRC\",     \"leiden\",      'total_counts',      'log1p_total_counts',     'pct_counts_in_top_50_genes',      'has_guide_annotations',     \"phase\",     \"target_symbol\", ]) <pre>Index(['n_genes_by_counts', 'log1p_n_genes_by_counts', 'total_counts',\n       'log1p_total_counts', 'pct_counts_in_top_50_genes',\n       'pct_counts_in_top_100_genes', 'pct_counts_in_top_200_genes',\n       'pct_counts_in_top_500_genes', 'cell_barcode', 'guide_identity',\n       'num_guides', 'gene', 'best_gamma', 'correction', 'distance', 'gamma_A',\n       'gamma_B', 'gene_type', 'protospacer_A', 'protospacer_B', 'rank_A',\n       'rank_B', 'sgID_A', 'sgID_B', 'type', 'target', 'umi_A', 'umi_B',\n       'read_count', 'UMI_count', 'coverage', 'good_coverage',\n       'number_of_cells', 'gemgroup', 'target_symbol', 'has_guide_annotations',\n       'total_counts_ribo', 'pct_counts_ribo', 'total_counts_mt',\n       'pct_counts_mt', 'leiden', 'S_score', 'G2M_score', 'phase'],\n      dtype='object')\n</pre>"},{"location":"notebooks/hwex_done.html#organization","title":"Organization\u00b6","text":"<p>After the usual imports, we follow the order as described in the assignment, except that out of convenience, some QC metrics are computed before the data reshaping is done.</p>"},{"location":"notebooks/hwex_done.html#1-tidy-the-dataset-so-that-it-fits-in-an-anndata-object","title":"1. Tidy the dataset so that it fits in an AnnData object.\u00b6","text":""},{"location":"notebooks/hwex_done.html#11-for-each-overexpressed-gene-how-many-cells-are-measured","title":"1.1 For each overexpressed gene, how many cells are measured?\u00b6","text":"<p>The code below shows that between 212 and 1861 cells are measured for any given perturbation, with ~5k controls.</p>"},{"location":"notebooks/hwex_done.html#2-compute-typical-scrna-quality-metrics-and-filter-out-genes-and-cells-as-discussed-in-class","title":"2. Compute typical scRNA quality metrics and filter out genes and cells as discussed in class.\u00b6","text":"<p>For this particular project, we prefer to err on the side of discarding real cells rather than risking inclusion of empty droplets, doublets, or other artifacts in our analysis. Out of an abundance of caution, we remove droplets with especially high or low total counts, and we remove droplets with high fractions of RNA from mitochondrial RNA's, ribosomal protein subunit RNA's, or high-expressed RNA's. Please consult the code below for exact thresholds and numbers.</p>"},{"location":"notebooks/hwex_done.html#basic-eda","title":"Basic EDA\u00b6","text":"<p>Visualize the data using scanpy.</p>"},{"location":"notebooks/hwex_done.html#31-run-the-code-and-describe-the-results","title":"3.1 Run the code and describe the results.\u00b6","text":"<p>The UMAP shows a roughly unimodal distribution a lot of variation driven by cell cycle and read depth. Cells do not obviously cluster by which gene was overexpressed. This suggests that most of these perturbations do not cause extensive reprogramming of cell state.</p>"},{"location":"notebooks/integration.html","title":"Integration","text":"In\u00a0[\u00a0]: Copied! In\u00a0[1]: Copied! <pre>import warnings\nwarnings.filterwarnings(\"ignore\", category=FutureWarning)\nimport os, sys\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport scanpy as sc\nimport pySingleCellNet as cn\n</pre> import warnings warnings.filterwarnings(\"ignore\", category=FutureWarning) import os, sys import numpy as np import pandas as pd import matplotlib.pyplot as plt import scanpy as sc import pySingleCellNet as cn In\u00a0[2]: Copied! <pre>adPijuan = sc.read_h5ad(\"ad_Pijuan_demo.h5ad\")\nadPijuan\n</pre> adPijuan = sc.read_h5ad(\"ad_Pijuan_demo.h5ad\") adPijuan Out[2]: <pre>AnnData object with n_obs \u00d7 n_vars = 2071 \u00d7 21133\n    obs: 'cell', 'stage', 'celltype'\n    var: 'ENSEMBL'</pre> In\u00a0[3]: Copied! <pre>adPijuan.obs['celltype'].value_counts()\n</pre> adPijuan.obs['celltype'].value_counts() Out[3]: <pre>celltype\nMeso.Cardio     300\nPGC             297\nEndo.Gut        296\nEpiblast        296\nAnterior.PS     294\nEcto.Neural     294\nMeso.Nascent    294\nName: count, dtype: int64</pre> In\u00a0[4]: Copied! <pre>adTrain = adPijuan\nadTrain.layers['counts'] = adTrain.X.copy()\nsc.pp.normalize_total(adTrain)\nsc.pp.log1p(adTrain)\nsc.pp.highly_variable_genes(adTrain, n_top_genes=2000, flavor='seurat_v3', layer='counts')\n</pre> adTrain = adPijuan adTrain.layers['counts'] = adTrain.X.copy() sc.pp.normalize_total(adTrain) sc.pp.log1p(adTrain) sc.pp.highly_variable_genes(adTrain, n_top_genes=2000, flavor='seurat_v3', layer='counts') In\u00a0[5]: Copied! <pre>sc.tl.pca(adTrain, mask_var='highly_variable')\nsc.pl.pca_variance_ratio(adTrain, n_pcs=50)\n</pre> sc.tl.pca(adTrain, mask_var='highly_variable') sc.pl.pca_variance_ratio(adTrain, n_pcs=50) In\u00a0[6]: Copied! <pre>def_npcs = 20\ndef_nneigh = 10\nsc.pp.neighbors(adTrain, n_neighbors = def_nneigh,  n_pcs = def_npcs)\n</pre> def_npcs = 20 def_nneigh = 10 sc.pp.neighbors(adTrain, n_neighbors = def_nneigh,  n_pcs = def_npcs) In\u00a0[7]: Copied! <pre>sc.tl.umap(adTrain)\nsc.pl.umap(adTrain, color=['celltype', 'stage'], size=30, alpha=.95,frameon=False)\n</pre> sc.tl.umap(adTrain) sc.pl.umap(adTrain, color=['celltype', 'stage'], size=30, alpha=.95,frameon=False) In\u00a0[8]: Copied! <pre>adGross = sc.read_h5ad(\"ad_Grosswendt_demo.h5ad\")\nadGross\n</pre> adGross = sc.read_h5ad(\"ad_Grosswendt_demo.h5ad\") adGross Out[8]: <pre>AnnData object with n_obs \u00d7 n_vars = 700 \u00d7 21133\n    obs: 'embryo', 'stage', 'celltype'\n    var: 'name'</pre> In\u00a0[9]: Copied! <pre>adPijuan = sc.read_h5ad(\"ad_Pijuan_demo.h5ad\")\nadPijuan.obs['study'] = 'Pijuan'\nadGross.obs['study'] = 'Grosswendt'\n</pre> adPijuan = sc.read_h5ad(\"ad_Pijuan_demo.h5ad\") adPijuan.obs['study'] = 'Pijuan' adGross.obs['study'] = 'Grosswendt' In\u00a0[10]: Copied! <pre>import anndata as ad\ndel(adPijuan.raw)\nadComb = ad.concat([adPijuan, adGross])\n</pre> import anndata as ad del(adPijuan.raw) adComb = ad.concat([adPijuan, adGross]) In\u00a0[11]: Copied! <pre>adComb.obs['study'].value_counts()\n</pre> adComb.obs['study'].value_counts() Out[11]: <pre>study\nPijuan        2071\nGrosswendt     700\nName: count, dtype: int64</pre> In\u00a0[12]: Copied! <pre>adComb.layers['counts'] = adComb.X.copy()\nsc.pp.normalize_total(adComb)\nsc.pp.log1p(adComb)\nsc.pp.highly_variable_genes(adComb, n_top_genes=2000, flavor='seurat_v3', layer='counts')\nsc.tl.pca(adComb, mask_var='highly_variable')\nsc.pl.pca_variance_ratio(adComb, n_pcs=50)\n</pre> adComb.layers['counts'] = adComb.X.copy() sc.pp.normalize_total(adComb) sc.pp.log1p(adComb) sc.pp.highly_variable_genes(adComb, n_top_genes=2000, flavor='seurat_v3', layer='counts') sc.tl.pca(adComb, mask_var='highly_variable') sc.pl.pca_variance_ratio(adComb, n_pcs=50) In\u00a0[13]: Copied! <pre>def_npcs = 20\ndef_nneigh = 10 # preference -- allows detection of rare populations\nsc.pp.neighbors(adComb, n_neighbors = def_nneigh,  n_pcs = def_npcs)\nsc.tl.umap(adComb)\nsc.pl.umap(adComb, color=['study', 'celltype'], size=30, alpha=.95,frameon=False)\n</pre> def_npcs = 20 def_nneigh = 10 # preference -- allows detection of rare populations sc.pp.neighbors(adComb, n_neighbors = def_nneigh,  n_pcs = def_npcs) sc.tl.umap(adComb) sc.pl.umap(adComb, color=['study', 'celltype'], size=30, alpha=.95,frameon=False) <p>The embedding above strongly suggests that there will be very little clustering of cells from the same type across data from the two studies.</p> In\u00a0[14]: Copied! <pre>adComb2 = ad.concat([adPijuan, adGross])\nbatch_key = \"study\"\n\nsc.pp.filter_genes(adComb2, min_cells=3)\nadComb2.layers['counts'] = adComb2.X.copy()\n</pre> adComb2 = ad.concat([adPijuan, adGross]) batch_key = \"study\"  sc.pp.filter_genes(adComb2, min_cells=3) adComb2.layers['counts'] = adComb2.X.copy() In\u00a0[15]: Copied! <pre>sc.pp.normalize_total(adComb2)\nsc.pp.log1p(adComb2)\nsc.pp.highly_variable_genes(adComb2, n_top_genes=2000, flavor=\"cell_ranger\", batch_key=batch_key)\n</pre> sc.pp.normalize_total(adComb2) sc.pp.log1p(adComb2) sc.pp.highly_variable_genes(adComb2, n_top_genes=2000, flavor=\"cell_ranger\", batch_key=batch_key) In\u00a0[17]: Copied! <pre>adata_hvg = adComb2[:,adComb2.var[\"highly_variable\"]].copy()\nsc.pp.pca(adata_hvg)\nsc.external.pp.bbknn(adata_hvg, batch_key=batch_key)\n</pre> adata_hvg = adComb2[:,adComb2.var[\"highly_variable\"]].copy() sc.pp.pca(adata_hvg) sc.external.pp.bbknn(adata_hvg, batch_key=batch_key) <pre>WARNING: consider updating your call to make use of `computation`\n</pre> In\u00a0[18]: Copied! <pre>adata_hvg\n</pre> adata_hvg Out[18]: <pre>AnnData object with n_obs \u00d7 n_vars = 2771 \u00d7 2000\n    obs: 'stage', 'celltype', 'study'\n    var: 'n_cells', 'highly_variable', 'means', 'dispersions', 'dispersions_norm', 'highly_variable_nbatches', 'highly_variable_intersection'\n    uns: 'log1p', 'hvg', 'pca', 'neighbors'\n    obsm: 'X_pca'\n    varm: 'PCs'\n    layers: 'counts'\n    obsp: 'distances', 'connectivities'</pre> In\u00a0[19]: Copied! <pre>sc.tl.umap(adata_hvg)\nsc.pl.umap(adata_hvg, color=['study', 'celltype'], size=30, alpha=.95,frameon=False)\n</pre> sc.tl.umap(adata_hvg) sc.pl.umap(adata_hvg, color=['study', 'celltype'], size=30, alpha=.95,frameon=False) <p>The integration by BBKNN in this example looks pretty good! Note that in both this approach and the naive integration, the user would still need to perform some post-integration processing in order to label the query cells. This could easily be done by clustering and then assotating query cells based on the most frequent label of reference cells sharing the same cluster as query cells. Try to think of other approaches to this task.</p> In\u00a0[20]: Copied! <pre>adRef2 = sc.read_h5ad(\"ad_Pijuan_demo.h5ad\")\nadQuery = sc.read_h5ad(\"ad_Grosswendt_demo.h5ad\")\n</pre> adRef2 = sc.read_h5ad(\"ad_Pijuan_demo.h5ad\") adQuery = sc.read_h5ad(\"ad_Grosswendt_demo.h5ad\") In\u00a0[21]: Copied! <pre>cn.ut.limit_anndata_to_common_genes([adRef2, adQuery])\n</pre> cn.ut.limit_anndata_to_common_genes([adRef2, adQuery]) In\u00a0[22]: Copied! <pre>n_cells = 100\ngroupby = 'celltype'\n# explain\nstrata_col = 'stage'\n\ntids, vids = cn.ut.split_adata_indices(adRef2, n_cells, groupby=groupby, cellid=None, strata_col=strata_col)\n</pre> n_cells = 100 groupby = 'celltype' # explain strata_col = 'stage'  tids, vids = cn.ut.split_adata_indices(adRef2, n_cells, groupby=groupby, cellid=None, strata_col=strata_col) In\u00a0[23]: Copied! <pre>adTrain = adRef2[tids].copy()\nadHO = adRef2[vids].copy()\n</pre> adTrain = adRef2[tids].copy() adHO = adRef2[vids].copy() In\u00a0[24]: Copied! <pre>sc.pp.highly_variable_genes(adTrain, n_top_genes=3000, flavor='seurat_v3')\nsc.pp.normalize_total(adTrain)\nsc.pp.log1p(adTrain)\n</pre> sc.pp.highly_variable_genes(adTrain, n_top_genes=3000, flavor='seurat_v3') sc.pp.normalize_total(adTrain) sc.pp.log1p(adTrain) In\u00a0[25]: Copied! <pre>n_rand = n_cells\nnTopGenes = 30\nnTopGenePairs = 40\nn_comps = 30\nn_trees = 1000\nobs_pred = \"SCN_class_argmax\"\n\nclf = cn.cl.train_classifier(adTrain, groupby, nRand = n_rand, nTopGenes = nTopGenes, nTopGenePairs = nTopGenePairs, n_comps = n_comps)\n</pre> n_rand = n_cells nTopGenes = 30 nTopGenePairs = 40 n_comps = 30 n_trees = 1000 obs_pred = \"SCN_class_argmax\"  clf = cn.cl.train_classifier(adTrain, groupby, nRand = n_rand, nTopGenes = nTopGenes, nTopGenePairs = nTopGenePairs, n_comps = n_comps) <pre>Training classifier |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 5/5 [100%] in 1.9s (2.59/s) \n</pre> In\u00a0[26]: Copied! <pre>cn.cl.classify_anndata(adHO, clf)\n</pre> cn.cl.classify_anndata(adHO, clf) In\u00a0[27]: Copied! <pre>adHO\n# cn.pl.heatmap_scores(adHO, groubpy='SCN_class_argmax')\n</pre> adHO # cn.pl.heatmap_scores(adHO, groubpy='SCN_class_argmax') Out[27]: <pre>AnnData object with n_obs \u00d7 n_vars = 1386 \u00d7 21133\n    obs: 'cell', 'stage', 'celltype', 'cellid', 'SCN_class_argmax'\n    var: 'ENSEMBL'\n    uns: 'SCN_class_argmax_colors'\n    obsm: 'SCN_score'</pre> In\u00a0[28]: Copied! <pre>type(adHO.obsm)\n</pre> type(adHO.obsm) Out[28]: <pre>anndata._core.aligned_mapping.AxisArrays</pre> In\u00a0[29]: Copied! <pre>adHO.obsm\n</pre> adHO.obsm Out[29]: <pre>AxisArrays with keys: SCN_score</pre> In\u00a0[30]: Copied! <pre>cn.pl.heatmap_scores(adHO, groupby = 'SCN_class_argmax')\n</pre> cn.pl.heatmap_scores(adHO, groupby = 'SCN_class_argmax') In\u00a0[31]: Copied! <pre>cn.pl.heatmap_scores(adHO, groupby = 'celltype')\n</pre> cn.pl.heatmap_scores(adHO, groupby = 'celltype') In\u00a0[32]: Copied! <pre>c_report = cn.cl.create_classifier_report(adHO, ground_truth=groupby, prediction=obs_pred)\n</pre> c_report = cn.cl.create_classifier_report(adHO, ground_truth=groupby, prediction=obs_pred) In\u00a0[33]: Copied! <pre>cn.pl.heatmap_classifier_report(c_report)\n</pre> cn.pl.heatmap_classifier_report(c_report) In\u00a0[34]: Copied! <pre>cn.cl.classify_anndata(adQuery, clf)\n</pre> cn.cl.classify_anndata(adQuery, clf) In\u00a0[35]: Copied! <pre>cn.pl.heatmap_scores(adQuery, groupby = 'SCN_class_argmax')\n</pre> cn.pl.heatmap_scores(adQuery, groupby = 'SCN_class_argmax') In\u00a0[36]: Copied! <pre>adQuery.obs['SCN_class_argmax'].value_counts()\n</pre> adQuery.obs['SCN_class_argmax'].value_counts() Out[36]: <pre>SCN_class_argmax\nEpiblast        113\nEndo.Gut        105\nEcto.Neural     104\nMeso.Cardio     102\nMeso.Nascent     98\nAnterior.PS      89\nPGC              87\nrand              2\nName: count, dtype: int64</pre> In\u00a0[37]: Copied! <pre>c_report_2 = cn.cl.create_classifier_report(adQuery, ground_truth=groupby, prediction=obs_pred)\n</pre> c_report_2 = cn.cl.create_classifier_report(adQuery, ground_truth=groupby, prediction=obs_pred) In\u00a0[38]: Copied! <pre>cn.pl.heatmap_classifier_report(c_report_2)\n</pre> cn.pl.heatmap_classifier_report(c_report_2) In\u00a0[39]: Copied! <pre>tThrs_val_05_HO = cn.cl.comp_ct_thresh(adHO, 0.05)\n</pre> tThrs_val_05_HO = cn.cl.comp_ct_thresh(adHO, 0.05) In\u00a0[40]: Copied! <pre>tThrs_val_05_HO\n</pre> tThrs_val_05_HO Out[40]: 0 Anterior.PS 0.36695 Ecto.Neural 0.39885 Endo.Gut 0.38820 Epiblast 0.31290 Meso.Cardio 0.56400 Meso.Nascent 0.32700 PGC 0.35690 In\u00a0[41]: Copied! <pre>rela_graph = cn.cl.paga_connectivities_to_igraph(adTrain, threshold = 0.3, n_comps = n_comps, group_key = groupby)\n</pre> rela_graph = cn.cl.paga_connectivities_to_igraph(adTrain, threshold = 0.3, n_comps = n_comps, group_key = groupby) In\u00a0[42]: Copied! <pre>cn.cl.categorize_classification(adQuery, tThrs_val_05_HO, rela_graph)\n</pre> cn.cl.categorize_classification(adQuery, tThrs_val_05_HO, rela_graph) In\u00a0[44]: Copied! <pre>cn.pl.stackedbar_categories(adQuery, class_col_name='celltype', show_pct_total=True)\n</pre> cn.pl.stackedbar_categories(adQuery, class_col_name='celltype', show_pct_total=True) Out[44]: In\u00a0[45]: Copied! <pre>adQuery\n</pre> adQuery Out[45]: <pre>AnnData object with n_obs \u00d7 n_vars = 700 \u00d7 21133\n    obs: 'embryo', 'stage', 'celltype', 'SCN_class_argmax', 'SCN_class_emp', 'SCN_class_type', 'SCN_class_cat'\n    var: 'name'\n    uns: 'SCN_class_argmax_colors'\n    obsm: 'SCN_score'</pre> In\u00a0[46]: Copied! <pre>cn.pl.heatmap_scores(adQuery, groupby = 'SCN_class_cat')\n</pre> cn.pl.heatmap_scores(adQuery, groupby = 'SCN_class_cat') In\u00a0[47]: Copied! <pre>adtest2 = adQuery.copy()\nadtest2.layers['counts'] = adtest2.X.copy()\nsc.pp.normalize_total(adtest2)\nsc.pp.log1p(adtest2)\nsc.pp.highly_variable_genes(adtest2, n_top_genes=3000, flavor='seurat_v3', layer='counts')\nsc.tl.pca(adtest2, mask_var='highly_variable')\nsc.pl.pca_variance_ratio(adtest2, n_pcs=50)\n</pre> adtest2 = adQuery.copy() adtest2.layers['counts'] = adtest2.X.copy() sc.pp.normalize_total(adtest2) sc.pp.log1p(adtest2) sc.pp.highly_variable_genes(adtest2, n_top_genes=3000, flavor='seurat_v3', layer='counts') sc.tl.pca(adtest2, mask_var='highly_variable') sc.pl.pca_variance_ratio(adtest2, n_pcs=50) In\u00a0[48]: Copied! <pre>def_npcs = 30\ndef_nneigh = 10\nsc.pp.neighbors(adtest2, n_neighbors = def_nneigh,  n_pcs = def_npcs)\nsc.tl.umap(adtest2)\nsc.pl.umap(adtest2, color=['SCN_class_argmax', 'SCN_class_type'], size=50, alpha=.95,frameon=False)\n</pre> def_npcs = 30 def_nneigh = 10 sc.pp.neighbors(adtest2, n_neighbors = def_nneigh,  n_pcs = def_npcs) sc.tl.umap(adtest2) sc.pl.umap(adtest2, color=['SCN_class_argmax', 'SCN_class_type'], size=50, alpha=.95,frameon=False) <pre>WARNING: The following color value found in adata.uns['SCN_class_argmax_colors'] is not valid: 'Anterior.PS'. Default colors will be used instead.\n</pre>"},{"location":"notebooks/integration.html#cell-typing-by-data-integration-and-by-classification","title":"Cell typing by data integration and by classification\u00b6","text":"<p>Here, we walk you through three ways to predict the cell types in your query scRNAseq data set by leveraging another, well-anntated reference dataset. The first way is to directly combine the datasets an cluster them together. The second way is called 'Batch Balanced KNN', which works by finding kNN across batches. The third way is to classify the query data with classifier that was trained with the reference data.</p>"},{"location":"notebooks/integration.html#data","title":"Data\u00b6","text":"<p>We will use mouse cells from gastrula-stage embryos from two studies.</p> <p>The reference data comes from Pijuan-Sala et al 2019 which describes a single cell census of gastrulation in mouse (E6.5 to E8.5). You can download the .h5ad file here.</p> <p>The query data comes from another gastula census Grosswendt et al 2020. You can download the .h5ad file here.</p> <p>For the sake of computational efficiency, we have taken only a small subset of the cells from each of these studies. The cell type label is stored in <code>.obs['celltype']</code></p>"},{"location":"notebooks/integration.html#naive-concatenation-of-anndata-objects-then-clustering","title":"Naive concatenation of anndata objects, then clustering\u00b6","text":""},{"location":"notebooks/integration.html#method-2-bbknn","title":"Method 2: BBKNN\u00b6","text":"<p>For details on how the <code>sc.external.pp.bbknn()</code> function works, go to scanpy's documentation.</p> <p>Also see the section on graph based integration in the online best practices book</p>"},{"location":"notebooks/integration.html#method-3-ml-classification","title":"Method 3: ML Classification\u00b6","text":"<p>In the third approach, we will directly annotate query cells by classifying them using a model trained on reference data. Our PySingleCellNet (pySCN) package was designed for this task.</p>"},{"location":"notebooks/scBasics.html","title":"scBasics","text":"<p>Here is a more detailed glimpse of what is happening here:</p> CellRanger flow chart 2 from 10X genomics CellRanger mapping from 10X genomics In\u00a0[1]: Copied! <pre># !pip install scanpy scipy umap-learn leidenalg\n</pre> # !pip install scanpy scipy umap-learn leidenalg In\u00a0[2]: Copied! <pre># wget for linux/unix\n# !wget https://cf.10xgenomics.com/samples/cell-exp/3.0.0/pbmc_10k_v3/pbmc_10k_v3_filtered_feature_bc_matrix.h5\n# !wget https://cf.10xgenomics.com/samples/cell-exp/6.1.0/20k_PBMC_3p_HT_nextgem_Chromium_X/20k_PBMC_3p_HT_nextgem_Chromium_X_filtered_feature_bc_matrix.h5\n\n# curl for macOS; i have no clue what to use for Windows\n# !curl https://cf.10xgenomics.com/samples/cell-exp/3.0.0/pbmc_10k_v3/pbmc_10k_v3_filtered_feature_bc_matrix.h5 -o pbmc_10k_v3_filtered_feature_bc_matrix.h5\n# !curl https://cf.10xgenomics.com/samples/cell-exp/6.1.0/20k_PBMC_3p_HT_nextgem_Chromium_X/20k_PBMC_3p_HT_nextgem_Chromium_X_filtered_feature_bc_matrix.h5 -o 20k_PBMC_3p_HT_nextgem_Chromium_X_filtered_feature_bc_matrix.h5\n</pre> # wget for linux/unix # !wget https://cf.10xgenomics.com/samples/cell-exp/3.0.0/pbmc_10k_v3/pbmc_10k_v3_filtered_feature_bc_matrix.h5 # !wget https://cf.10xgenomics.com/samples/cell-exp/6.1.0/20k_PBMC_3p_HT_nextgem_Chromium_X/20k_PBMC_3p_HT_nextgem_Chromium_X_filtered_feature_bc_matrix.h5  # curl for macOS; i have no clue what to use for Windows # !curl https://cf.10xgenomics.com/samples/cell-exp/3.0.0/pbmc_10k_v3/pbmc_10k_v3_filtered_feature_bc_matrix.h5 -o pbmc_10k_v3_filtered_feature_bc_matrix.h5 # !curl https://cf.10xgenomics.com/samples/cell-exp/6.1.0/20k_PBMC_3p_HT_nextgem_Chromium_X/20k_PBMC_3p_HT_nextgem_Chromium_X_filtered_feature_bc_matrix.h5 -o 20k_PBMC_3p_HT_nextgem_Chromium_X_filtered_feature_bc_matrix.h5 In\u00a0[3]: Copied! <pre>import scanpy as sc\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport warnings\n# warnings.filterwarnings('ignore')\nplt.rcParams['figure.dpi'] = 300\nsc.logging.print_header()\n</pre> import scanpy as sc import numpy as np import pandas as pd import matplotlib.pyplot as plt import warnings # warnings.filterwarnings('ignore') plt.rcParams['figure.dpi'] = 300 sc.logging.print_header() <pre>/opt/homebrew/Caskroom/miniforge/base/envs/scnpy/lib/python3.12/site-packages/tqdm/auto.py:21: TqdmWarning: IProgress not found. Please update jupyter and ipywidgets. See https://ipywidgets.readthedocs.io/en/stable/user_install.html\n  from .autonotebook import tqdm as notebook_tqdm\n</pre> <pre>scanpy==1.10.4 anndata==0.11.3 umap==0.5.7 numpy==1.26.4 scipy==1.14.1 pandas==2.2.3 scikit-learn==1.6.1 statsmodels==0.14.4 igraph==0.11.8 pynndescent==0.5.13\n</pre> In\u00a0[4]: Copied! <pre># I have stored these data files in another dir\nad10f = sc.read_10x_h5(\"data/pbmc_10k_v3_filtered_feature_bc_matrix.h5\")\n# If you stored yours in the cwd on Colab, you should uncomment and run this line instead to load your data:\n# ad10f = sc.read_10x_h5(\"pbmc_10k_v3_filtered_feature_bc_matrix.h5\")\n</pre> # I have stored these data files in another dir ad10f = sc.read_10x_h5(\"data/pbmc_10k_v3_filtered_feature_bc_matrix.h5\") # If you stored yours in the cwd on Colab, you should uncomment and run this line instead to load your data: # ad10f = sc.read_10x_h5(\"pbmc_10k_v3_filtered_feature_bc_matrix.h5\") <pre>/opt/homebrew/Caskroom/miniforge/base/envs/scnpy/lib/python3.12/site-packages/anndata/_core/anndata.py:1758: UserWarning: Variable names are not unique. To make them unique, call `.var_names_make_unique`.\n  utils.warn_names_duplicates(\"var\")\n/opt/homebrew/Caskroom/miniforge/base/envs/scnpy/lib/python3.12/site-packages/anndata/_core/anndata.py:1758: UserWarning: Variable names are not unique. To make them unique, call `.var_names_make_unique`.\n  utils.warn_names_duplicates(\"var\")\n</pre> In\u00a0[5]: Copied! <pre>ad10f.var_names_make_unique()\n\n#?sc.read_10x_h5\n</pre> ad10f.var_names_make_unique()  #?sc.read_10x_h5 In\u00a0[6]: Copied! <pre>print(ad10f)\n</pre> print(ad10f) <pre>AnnData object with n_obs \u00d7 n_vars = 11769 \u00d7 33538\n    var: 'gene_ids', 'feature_types', 'genome'\n</pre> In\u00a0[7]: Copied! <pre>ad10f.shape\n</pre> ad10f.shape Out[7]: <pre>(11769, 33538)</pre> In\u00a0[8]: Copied! <pre>type(ad10f)\n</pre> type(ad10f) Out[8]: <pre>anndata._core.anndata.AnnData</pre> In\u00a0[9]: Copied! <pre>ncells = 3\nngenes = 4\nrandGenes = np.random.choice(ad10f.var_names, size=ngenes, replace=False)\nrandCells = np.random.choice(ad10f.obs_names, size=ncells, replace=False)\n</pre> ncells = 3 ngenes = 4 randGenes = np.random.choice(ad10f.var_names, size=ngenes, replace=False) randCells = np.random.choice(ad10f.obs_names, size=ncells, replace=False) In\u00a0[10]: Copied! <pre>print(randCells)\n</pre> print(randCells) <pre>['TTCCACGCAGACGATG-1' 'CATTGCCAGGTACAAT-1' 'ACTTTCAGTTGAGAGC-1']\n</pre> In\u00a0[11]: Copied! <pre>print(randGenes)\n</pre> print(randGenes) <pre>['AC130352.1' 'AC092354.2' 'MOAP1' 'POLR3B']\n</pre> In\u00a0[12]: Copied! <pre>newAnndata = ad10f[ randCells ]\nnewAnndata\n</pre> newAnndata = ad10f[ randCells ] newAnndata Out[12]: <pre>View of AnnData object with n_obs \u00d7 n_vars = 3 \u00d7 33538\n    var: 'gene_ids', 'feature_types', 'genome'</pre> In\u00a0[13]: Copied! <pre>ad10f[ randGenes ]\n</pre> ad10f[ randGenes ] <pre>\n---------------------------------------------------------------------------\nKeyError                                  Traceback (most recent call last)\nCell In[13], line 1\n----&gt; 1 ad10f[ randGenes ]\n\nFile /opt/homebrew/Caskroom/miniforge/base/envs/scnpy/lib/python3.12/site-packages/anndata/_core/anndata.py:1022, in AnnData.__getitem__(self, index)\n   1020 def __getitem__(self, index: Index) -&gt; AnnData:\n   1021     \"\"\"Returns a sliced view of the object.\"\"\"\n-&gt; 1022     oidx, vidx = self._normalize_indices(index)\n   1023     return AnnData(self, oidx=oidx, vidx=vidx, asview=True)\n\nFile /opt/homebrew/Caskroom/miniforge/base/envs/scnpy/lib/python3.12/site-packages/anndata/_core/anndata.py:1003, in AnnData._normalize_indices(self, index)\n   1002 def _normalize_indices(self, index: Index | None) -&gt; tuple[slice, slice]:\n-&gt; 1003     return _normalize_indices(index, self.obs_names, self.var_names)\n\nFile /opt/homebrew/Caskroom/miniforge/base/envs/scnpy/lib/python3.12/site-packages/anndata/_core/index.py:32, in _normalize_indices(index, names0, names1)\n     30     index = tuple(i.values if isinstance(i, pd.Series) else i for i in index)\n     31 ax0, ax1 = unpack_index(index)\n---&gt; 32 ax0 = _normalize_index(ax0, names0)\n     33 ax1 = _normalize_index(ax1, names1)\n     34 return ax0, ax1\n\nFile /opt/homebrew/Caskroom/miniforge/base/envs/scnpy/lib/python3.12/site-packages/anndata/_core/index.py:105, in _normalize_index(indexer, index)\n    103         if np.any(positions &lt; 0):\n    104             not_found = indexer[positions &lt; 0]\n--&gt; 105             raise KeyError(\n    106                 f\"Values {list(not_found)}, from {list(indexer)}, \"\n    107                 \"are not valid obs/ var names or indices.\"\n    108             )\n    109         return positions  # np.ndarray[int]\n    110 raise IndexError(f\"Unknown indexer {indexer!r} of type {type(indexer)}\")\n\nKeyError: \"Values ['AC130352.1', 'AC092354.2', 'MOAP1', 'POLR3B'], from ['AC130352.1', 'AC092354.2', 'MOAP1', 'POLR3B'], are not valid obs/ var names or indices.\"</pre> In\u00a0[14]: Copied! <pre>ad10f[:, randGenes ]\n</pre> ad10f[:, randGenes ] Out[14]: <pre>View of AnnData object with n_obs \u00d7 n_vars = 11769 \u00d7 4\n    var: 'gene_ids', 'feature_types', 'genome'</pre> In\u00a0[15]: Copied! <pre>gname_counts = ad10f.var_names.value_counts()\nprint(gname_counts)\nnp.any(gname_counts&gt;1)\n</pre> gname_counts = ad10f.var_names.value_counts() print(gname_counts) np.any(gname_counts&gt;1) <pre>MIR1302-2HG    1\nDCT            1\nGPC6-AS2       1\nGPC6           1\nAL354811.1     1\n              ..\nORC3           1\nRARS2          1\nSLC35A1        1\nAL049697.1     1\nFAM231C        1\nName: count, Length: 33538, dtype: int64\n</pre> Out[15]: <pre>False</pre> In\u00a0[16]: Copied! <pre>duplicates = gname_counts[gname_counts &gt; 1]\nprint(duplicates)\n</pre> duplicates = gname_counts[gname_counts &gt; 1] print(duplicates) <pre>Series([], Name: count, dtype: int64)\n</pre> In\u00a0[17]: Copied! <pre>ad10f.var_names_make_unique()\nad10f[:, randGenes ]\n</pre> ad10f.var_names_make_unique() ad10f[:, randGenes ] Out[17]: <pre>View of AnnData object with n_obs \u00d7 n_vars = 11769 \u00d7 4\n    var: 'gene_ids', 'feature_types', 'genome'</pre> In\u00a0[18]: Copied! <pre>ad10f[randCells, randGenes ]\n</pre> ad10f[randCells, randGenes ] Out[18]: <pre>View of AnnData object with n_obs \u00d7 n_vars = 3 \u00d7 4\n    var: 'gene_ids', 'feature_types', 'genome'</pre> Views Views are pointers to memory where original anndata is stored. They are not copies of the variable.   In\u00a0[19]: Copied! <pre>ad10f[randCells, randGenes ].X\n</pre> ad10f[randCells, randGenes ].X Out[19]: <pre>&lt;Compressed Sparse Row sparse matrix of dtype 'float32'\n\twith 1 stored elements and shape (3, 4)&gt;</pre> In\u00a0[20]: Copied! <pre>print(ad10f.obs.columns)\n</pre> print(ad10f.obs.columns) <pre>Index([], dtype='object')\n</pre> In\u00a0[21]: Copied! <pre>ad10f.obs['sample_name'] = \"sample_1\"\nprint(ad10f.obs.columns)\n</pre> ad10f.obs['sample_name'] = \"sample_1\" print(ad10f.obs.columns) <pre>Index(['sample_name'], dtype='object')\n</pre> In\u00a0[22]: Copied! <pre>print(ad10f[randCells].obs)\n</pre> print(ad10f[randCells].obs) <pre>                   sample_name\nTTCCACGCAGACGATG-1    sample_1\nCATTGCCAGGTACAAT-1    sample_1\nACTTTCAGTTGAGAGC-1    sample_1\n</pre> In\u00a0[23]: Copied! <pre>print(ad10f.var.columns)\n</pre> print(ad10f.var.columns) <pre>Index(['gene_ids', 'feature_types', 'genome'], dtype='object')\n</pre> In\u00a0[24]: Copied! <pre>print(ad10f[:,randGenes].var)\n</pre> print(ad10f[:,randGenes].var) <pre>                   gene_ids    feature_types  genome\nAC130352.1  ENSG00000270154  Gene Expression  GRCh38\nAC092354.2  ENSG00000272370  Gene Expression  GRCh38\nMOAP1       ENSG00000165943  Gene Expression  GRCh38\nPOLR3B      ENSG00000013503  Gene Expression  GRCh38\n</pre> In\u00a0[25]: Copied! <pre>print(ad10f.var.loc[randGenes])\n</pre> print(ad10f.var.loc[randGenes]) <pre>                   gene_ids    feature_types  genome\nAC130352.1  ENSG00000270154  Gene Expression  GRCh38\nAC092354.2  ENSG00000272370  Gene Expression  GRCh38\nMOAP1       ENSG00000165943  Gene Expression  GRCh38\nPOLR3B      ENSG00000013503  Gene Expression  GRCh38\n</pre> In\u00a0[26]: Copied! <pre>ad10f.var['mt'] = ad10f.var_names.str.startswith('MT-')\nribo_prefix = (\"RPS\",\"RPL\")\nad10f.var['ribo'] = ad10f.var_names.str.startswith(ribo_prefix)\nsc.pp.calculate_qc_metrics(ad10f, qc_vars=['mt','ribo'], percent_top=None, log1p=False, inplace=True)\n</pre> ad10f.var['mt'] = ad10f.var_names.str.startswith('MT-') ribo_prefix = (\"RPS\",\"RPL\") ad10f.var['ribo'] = ad10f.var_names.str.startswith(ribo_prefix) sc.pp.calculate_qc_metrics(ad10f, qc_vars=['mt','ribo'], percent_top=None, log1p=False, inplace=True) In\u00a0[27]: Copied! <pre>adClean = ad10f.copy()\n\nfig, (ax1, ax2, ax3) = plt.subplots(1, 3, figsize=(10,4), gridspec_kw={'wspace':0.25}, constrained_layout=True)\nax1_dict = sc.pl.scatter(adClean, x='total_counts', y='pct_counts_mt', ax=ax1, show=False)\nax2_dict = sc.pl.scatter(adClean, x='total_counts', y='n_genes_by_counts',ax=ax2, show=False)\nax3_dict = sc.pl.scatter(adClean, x='pct_counts_ribo', y='n_genes_by_counts',ax=ax3, show=False)\nplt.show()\n</pre> adClean = ad10f.copy()  fig, (ax1, ax2, ax3) = plt.subplots(1, 3, figsize=(10,4), gridspec_kw={'wspace':0.25}, constrained_layout=True) ax1_dict = sc.pl.scatter(adClean, x='total_counts', y='pct_counts_mt', ax=ax1, show=False) ax2_dict = sc.pl.scatter(adClean, x='total_counts', y='n_genes_by_counts',ax=ax2, show=False) ax3_dict = sc.pl.scatter(adClean, x='pct_counts_ribo', y='n_genes_by_counts',ax=ax3, show=False) plt.show() <p>Now, do the filtering.</p> <p>First, keep cells with fewer than 20% mitochondrially encoded gene total UMIs</p> In\u00a0[28]: Copied! <pre>adClean = adClean[adClean.obs['pct_counts_mt']&lt;20,:].copy()\nadClean.n_obs\n</pre> adClean = adClean[adClean.obs['pct_counts_mt']&lt;20,:].copy() adClean.n_obs Out[28]: <pre>11047</pre> <p>Second, filter based on total number of genes detected (at least 500). Third, filter based on total number of counts (fewer than than 30,000) Fourth, keep genes that are detected in at least 3 cells.</p> In\u00a0[29]: Copied! <pre>sc.pp.filter_cells(adClean, min_genes=500)\nprint(adClean.n_obs)\n\nsc.pp.filter_cells(adClean, max_counts=30000)\nprint(adClean.n_obs)\n\nsc.pp.filter_genes(adClean, min_cells=3)\nprint(adClean.shape)\n</pre> sc.pp.filter_cells(adClean, min_genes=500) print(adClean.n_obs)  sc.pp.filter_cells(adClean, max_counts=30000) print(adClean.n_obs)  sc.pp.filter_genes(adClean, min_cells=3) print(adClean.shape) <pre>10924\n10891\n(10891, 20181)\n</pre> In\u00a0[30]: Copied! <pre>adNorm = adClean.copy()\nadNorm.layers['counts'] = adNorm.X.copy()\nsc.pp.normalize_total(adNorm , target_sum=1e4)\nsc.pp.log1p(adNorm)\nadNorm.layers['lognorm'] = adNorm.X.copy()\n</pre> adNorm = adClean.copy() adNorm.layers['counts'] = adNorm.X.copy() sc.pp.normalize_total(adNorm , target_sum=1e4) sc.pp.log1p(adNorm) adNorm.layers['lognorm'] = adNorm.X.copy() In\u00a0[31]: Copied! <pre>sc.pp.highly_variable_genes(adNorm , min_mean=0.0125, max_mean=6, min_disp=0.25)\nadNorm.var\n</pre> sc.pp.highly_variable_genes(adNorm , min_mean=0.0125, max_mean=6, min_disp=0.25) adNorm.var Out[31]: gene_ids feature_types genome mt ribo n_cells_by_counts mean_counts pct_dropout_by_counts total_counts n_cells highly_variable means dispersions dispersions_norm AL627309.1 ENSG00000238009 Gene Expression GRCh38 False False 60 0.005183 99.490186 61.0 60 False 0.007519 0.595591 -0.001919 AL627309.3 ENSG00000239945 Gene Expression GRCh38 False False 4 0.000340 99.966012 4.0 4 False 0.000389 0.144284 -1.366927 AL669831.5 ENSG00000237491 Gene Expression GRCh38 False False 679 0.062367 94.230606 734.0 665 False 0.077585 0.586329 -0.029932 FAM87B ENSG00000177757 Gene Expression GRCh38 False False 13 0.001190 99.889540 14.0 13 False 0.001139 0.169543 -1.290532 LINC00115 ENSG00000225880 Gene Expression GRCh38 False False 350 0.031269 97.026085 368.0 337 False 0.038579 0.459107 -0.414723 ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... AC011043.1 ENSG00000276256 Gene Expression GRCh38 False False 77 0.006882 99.345739 81.0 74 False 0.010262 0.738345 0.429851 AL592183.1 ENSG00000273748 Gene Expression GRCh38 False False 32 0.002719 99.728099 32.0 30 False 0.003977 0.799225 0.613985 AC007325.4 ENSG00000278817 Gene Expression GRCh38 False False 239 0.020902 97.969241 246.0 233 False 0.023936 0.329110 -0.807909 AL354822.1 ENSG00000278384 Gene Expression GRCh38 False False 319 0.028210 97.289489 332.0 303 False 0.038089 0.594378 -0.005588 AC240274.1 ENSG00000271254 Gene Expression GRCh38 False False 101 0.008752 99.141813 103.0 99 False 0.010213 0.301150 -0.892475 <p>20181 rows \u00d7 14 columns</p> In\u00a0[32]: Copied! <pre>sc.pl.highly_variable_genes(adNorm)\n</pre> sc.pl.highly_variable_genes(adNorm) In\u00a0[33]: Copied! <pre>sc.tl.pca(adNorm , mask_var='highly_variable')\n</pre> sc.tl.pca(adNorm , mask_var='highly_variable') In\u00a0[34]: Copied! <pre>markerGenes = ['CD14','CLEC4C', 'CD19',  'GNLY', 'CD3D']\nsc.pl.pca(adNorm , color=markerGenes, ncols=2, layer='counts')\n</pre> markerGenes = ['CD14','CLEC4C', 'CD19',  'GNLY', 'CD3D'] sc.pl.pca(adNorm , color=markerGenes, ncols=2, layer='counts') In\u00a0[35]: Copied! <pre>sc.pl.pca(adNorm , color=markerGenes, ncols=2)\n</pre> sc.pl.pca(adNorm , color=markerGenes, ncols=2) In\u00a0[36]: Copied! <pre>sc.pl.pca(adNorm, color=['total_counts', 'pct_counts_mt', 'pct_counts_ribo'], s=25,ncols=3)\n</pre> sc.pl.pca(adNorm, color=['total_counts', 'pct_counts_mt', 'pct_counts_ribo'], s=25,ncols=3) In\u00a0[37]: Copied! <pre>sc.pl.pca_variance_ratio(adNorm, 50)\n</pre> sc.pl.pca_variance_ratio(adNorm, 50) In\u00a0[38]: Copied! <pre>np.shape(adNorm.varm[\"PCs\"])\n</pre> np.shape(adNorm.varm[\"PCs\"]) Out[38]: <pre>(20181, 50)</pre> <p>Where are the PC values of each cell (i.e. the PC scores) stored in anndata? .obsm</p> In\u00a0[39]: Copied! <pre>np.shape(adNorm.obsm[\"X_pca\"])\n</pre> np.shape(adNorm.obsm[\"X_pca\"]) Out[39]: <pre>(10891, 50)</pre> In\u00a0[40]: Copied! <pre>n_neighbors = 20\nn_pcs = 10\nsc.pp.neighbors(adNorm, n_neighbors=n_neighbors, n_pcs=n_pcs)\n</pre> n_neighbors = 20 n_pcs = 10 sc.pp.neighbors(adNorm, n_neighbors=n_neighbors, n_pcs=n_pcs) In\u00a0[41]: Copied! <pre>sc.tl.umap(adNorm, 0.25)\n</pre> sc.tl.umap(adNorm, 0.25) <pre>/var/folders/1_/v5grqr5n7kj42276bb6ryxj00000gn/T/ipykernel_66578/2021512077.py:1: FutureWarning: The specified parameters ('min_dist',) are no longer positional. Please specify them like `min_dist=0.25`\n  sc.tl.umap(adNorm, 0.25)\n</pre> In\u00a0[42]: Copied! <pre>sc.pl.umap(adNorm, color=markerGenes, alpha=.75, s=15, ncols=2)\n</pre> sc.pl.umap(adNorm, color=markerGenes, alpha=.75, s=15, ncols=2) In\u00a0[43]: Copied! <pre>sc.tl.leiden(adNorm,.1)\n</pre> sc.tl.leiden(adNorm,.1) <pre>/var/folders/1_/v5grqr5n7kj42276bb6ryxj00000gn/T/ipykernel_66578/3992796732.py:1: FutureWarning: In the future, the default backend for leiden will be igraph instead of leidenalg.\n\n To achieve the future defaults please pass: flavor=\"igraph\" and n_iterations=2.  directed must also be False to work with igraph's implementation.\n  sc.tl.leiden(adNorm,.1)\n</pre> In\u00a0[44]: Copied! <pre>sc.pl.umap(adNorm,color=['leiden'], alpha=.75, s=15, legend_loc='on data')\n</pre> sc.pl.umap(adNorm,color=['leiden'], alpha=.75, s=15, legend_loc='on data') Discordance Embeddings do not always agree with cluster results! See cluster 2 above.  <p>We can try to rectify this by using PAGA, which tries to infer dynamic relationships between clusters, to seed an initial embedding for UMAP that reflects overall cluster similarities.</p> <p>In the next cell, we call the following functions</p> <p><code>tl.paga()</code> computes intercluster similarities</p> <p><code>pl.paga()</code> creates an intial embedding based on this</p> <p><code>tl.umap()</code> uses this embedding to start its optimization</p> <p>Let's restart with the cleaned data.</p> In\u00a0[45]: Copied! <pre>adNorm = adClean.copy()\n\n## Norm, HVG, PCA, kNN\nsc.pp.normalize_total(adNorm , target_sum=1e4)\nsc.pp.log1p(adNorm)\nsc.pp.highly_variable_genes(adNorm , min_mean=0.0125, max_mean=6, min_disp=0.25)\nsc.tl.pca(adNorm , use_highly_variable=True)\n\nn_neighbors = 20\nn_pcs = 10\nsc.pp.neighbors(adNorm, n_neighbors=n_neighbors, n_pcs=n_pcs)\nsc.tl.leiden(adNorm,.1)\nsc.tl.paga(adNorm)\nsc.pl.paga(adNorm, plot=False)\nsc.tl.umap(adNorm, 0.25, init_pos='paga')\nsc.pl.umap(adNorm,color=['leiden'], alpha=.75, s=15, legend_loc='on data')\n</pre> adNorm = adClean.copy()  ## Norm, HVG, PCA, kNN sc.pp.normalize_total(adNorm , target_sum=1e4) sc.pp.log1p(adNorm) sc.pp.highly_variable_genes(adNorm , min_mean=0.0125, max_mean=6, min_disp=0.25) sc.tl.pca(adNorm , use_highly_variable=True)  n_neighbors = 20 n_pcs = 10 sc.pp.neighbors(adNorm, n_neighbors=n_neighbors, n_pcs=n_pcs) sc.tl.leiden(adNorm,.1) sc.tl.paga(adNorm) sc.pl.paga(adNorm, plot=False) sc.tl.umap(adNorm, 0.25, init_pos='paga') sc.pl.umap(adNorm,color=['leiden'], alpha=.75, s=15, legend_loc='on data') <pre>/opt/homebrew/Caskroom/miniforge/base/envs/scnpy/lib/python3.12/site-packages/scanpy/preprocessing/_pca.py:374: FutureWarning: Argument `use_highly_variable` is deprecated, consider using the mask argument. Use_highly_variable=True can be called through mask_var=\"highly_variable\". Use_highly_variable=False can be called through mask_var=None\n  warn(msg, FutureWarning)\n/var/folders/1_/v5grqr5n7kj42276bb6ryxj00000gn/T/ipykernel_66578/3419511010.py:15: FutureWarning: The specified parameters ('min_dist',) are no longer positional. Please specify them like `min_dist=0.25`\n  sc.tl.umap(adNorm, 0.25, init_pos='paga')\n</pre> In\u00a0[46]: Copied! <pre>sc.pl.umap(adNorm , color=markerGenes, ncols=2)\n</pre> sc.pl.umap(adNorm , color=markerGenes, ncols=2) <p>Make a figure that shows the embedding and expression of marker genes side-by-side. Note that I am adding markers for T cell, B cell, and Monocyte sub-types</p> In\u00a0[47]: Copied! <pre>marker_genes_broad_dict = {\n    'B cell': ['CD79A', 'PAX5'],\n    'Dendritic': ['CLEC4C', 'FCER1A'],\n    'Monocyte': ['CSF1R', 'FCGR3A'],\n    'NK cell': ['NKG7', 'GNLY'],\n    'T cell': ['TRAC', 'CD3E'],\n}\n\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10,4), gridspec_kw={'wspace':0.25})\nax1_dict = sc.pl.umap(adNorm,color=['leiden'], alpha=.75, s=10, legend_loc='on data', ax=ax1, show=False)\nax2_dict = sc.pl.dotplot(adNorm, marker_genes_broad_dict, 'leiden', dendrogram=True,ax=ax2, show=False)\nplt.show()\n</pre> marker_genes_broad_dict = {     'B cell': ['CD79A', 'PAX5'],     'Dendritic': ['CLEC4C', 'FCER1A'],     'Monocyte': ['CSF1R', 'FCGR3A'],     'NK cell': ['NKG7', 'GNLY'],     'T cell': ['TRAC', 'CD3E'], }  fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10,4), gridspec_kw={'wspace':0.25}) ax1_dict = sc.pl.umap(adNorm,color=['leiden'], alpha=.75, s=10, legend_loc='on data', ax=ax1, show=False) ax2_dict = sc.pl.dotplot(adNorm, marker_genes_broad_dict, 'leiden', dendrogram=True,ax=ax2, show=False) plt.show() <pre>WARNING: dendrogram data not found (using key=dendrogram_leiden). Running `sc.tl.dendrogram` with default parameters. For fine tuning it is recommended to run `sc.tl.dendrogram` independently.\nWARNING: Groups are not reordered because the `groupby` categories and the `var_group_labels` are different.\ncategories: 0, 1, 2, etc.\nvar_group_labels: B cell, Dendritic, Monocyte, etc.\n</pre> In\u00a0[48]: Copied! <pre>sc.tl.leiden(adNorm,.1, restrict_to=[\"leiden\",[\"5\"]])\nsc.tl.dendrogram(adNorm, \"leiden_R\")\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10,4), gridspec_kw={'wspace':0.25})\nax1_dict = sc.pl.umap(adNorm,color=['leiden_R'], alpha=.75, s=10, legend_loc='on data', ax=ax1, show=False)\nax2_dict = sc.pl.dotplot(adNorm, marker_genes_broad_dict, 'leiden_R', dendrogram=True,ax=ax2, show=False)\nplt.show()\n</pre> sc.tl.leiden(adNorm,.1, restrict_to=[\"leiden\",[\"5\"]]) sc.tl.dendrogram(adNorm, \"leiden_R\") fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10,4), gridspec_kw={'wspace':0.25}) ax1_dict = sc.pl.umap(adNorm,color=['leiden_R'], alpha=.75, s=10, legend_loc='on data', ax=ax1, show=False) ax2_dict = sc.pl.dotplot(adNorm, marker_genes_broad_dict, 'leiden_R', dendrogram=True,ax=ax2, show=False) plt.show() <pre>WARNING: Groups are not reordered because the `groupby` categories and the `var_group_labels` are different.\ncategories: 0, 1, 2, etc.\nvar_group_labels: B cell, Dendritic, Monocyte, etc.\n</pre> <p>Cluster 5 is split into 2 clusters now. Both of these sub-clusters express the Monocyte marker CD14, but are distinguished by their expression of dendritic marker FCER1A and the B cell genes CD79A and PAX5. Let's look at the QC metrics to see if that can give us additional hints as to whether these are real cells or are doublets.</p> In\u00a0[49]: Copied! <pre>sc.pl.violin(adNorm, ['total_counts'], groupby='leiden_R' )\n</pre> sc.pl.violin(adNorm, ['total_counts'], groupby='leiden_R' ) <p>Cluster 5 (and each sub-cluster) has a high number of Total counts. So let's annotate these as 'doublet'.</p> <p>What about the other questionable clusters 4 and 2? Can we refine those?</p> In\u00a0[50]: Copied! <pre># cluster 2 first\nsc.tl.leiden(adNorm,.05, restrict_to=[\"leiden\",[\"2\"]])\nsc.tl.dendrogram(adNorm, \"leiden_R\")\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10,4), gridspec_kw={'wspace':0.25})\nax1_dict = sc.pl.umap(adNorm,color=['leiden_R'], alpha=.75, s=10, legend_loc='on data', ax=ax1, show=False)\nax2_dict = sc.pl.dotplot(adNorm, marker_genes_broad_dict, 'leiden_R', dendrogram=True,ax=ax2, show=False)\nplt.show()\n</pre> # cluster 2 first sc.tl.leiden(adNorm,.05, restrict_to=[\"leiden\",[\"2\"]]) sc.tl.dendrogram(adNorm, \"leiden_R\") fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10,4), gridspec_kw={'wspace':0.25}) ax1_dict = sc.pl.umap(adNorm,color=['leiden_R'], alpha=.75, s=10, legend_loc='on data', ax=ax1, show=False) ax2_dict = sc.pl.dotplot(adNorm, marker_genes_broad_dict, 'leiden_R', dendrogram=True,ax=ax2, show=False) plt.show() <pre>WARNING: Groups are not reordered because the `groupby` categories and the `var_group_labels` are different.\ncategories: 0, 1, 2,0, etc.\nvar_group_labels: B cell, Dendritic, Monocyte, etc.\n</pre> <p>It looks like 2,0 is T cell, and 2,1 is Natural Killer cell. Note that 2,0 still has a distinct profile as compared to 0.</p> <p>What about cluster 4? And this time, when we do the sub-clustering, let's keep the way that we split up cluster 2.</p> In\u00a0[51]: Copied! <pre>sc.tl.leiden(adNorm,.1, restrict_to=[\"leiden_R\",[\"4\"]])\nsc.tl.dendrogram(adNorm, \"leiden_R\")\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10,4), gridspec_kw={'wspace':0.25})\nax1_dict = sc.pl.umap(adNorm,color=['leiden_R'], alpha=.75, s=10, legend_loc='on data', ax=ax1, show=False)\nax2_dict = sc.pl.dotplot(adNorm, marker_genes_broad_dict, 'leiden_R', dendrogram=True,ax=ax2, show=False)\nplt.show()\n</pre> sc.tl.leiden(adNorm,.1, restrict_to=[\"leiden_R\",[\"4\"]]) sc.tl.dendrogram(adNorm, \"leiden_R\") fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10,4), gridspec_kw={'wspace':0.25}) ax1_dict = sc.pl.umap(adNorm,color=['leiden_R'], alpha=.75, s=10, legend_loc='on data', ax=ax1, show=False) ax2_dict = sc.pl.dotplot(adNorm, marker_genes_broad_dict, 'leiden_R', dendrogram=True,ax=ax2, show=False) plt.show() <pre>WARNING: Groups are not reordered because the `groupby` categories and the `var_group_labels` are different.\ncategories: 0, 1, 2,0, etc.\nvar_group_labels: B cell, Dendritic, Monocyte, etc.\n</pre> <p>Is 4,1 multiplet?</p> In\u00a0[52]: Copied! <pre>sc.pl.violin(adNorm, ['total_counts', 'n_genes_by_counts'], groupby='leiden_R' )\n</pre> sc.pl.violin(adNorm, ['total_counts', 'n_genes_by_counts'], groupby='leiden_R' ) <p>Yes, it looks like 4,1 is similar in these QC profiles to cluster 5.</p> <p>So our updated annotation table is now:</p> cluster markers  of cell type 5 B, Dendritic, Mono doublet 1 Monocyte Monocyte 4,0 Monocyte Monocyte 3 B B-cell 6 Dendritic (B/Mono?) Dendritic cell 7 none Mystery cell 0 T cell T cell 2,0 T cell T cell 2,1 NK cell NK cell <p>Why do we have two Monocyte clusters and two T cells clusters?</p> In\u00a0[53]: Copied! <pre>marker_genes_sub_dict = {\n    'B cell': ['CD79A'],\n    'Dendritic': ['CLEC4C'],\n    'CD14 monocyte': ['CD14'],\n    'CD16 monocyte': ['FCGR3A'],\n    'NK cell': ['GNLY'],\n    'CD4 T cell': ['CD4', 'GATA3'],\n    'CD8 T cell': ['CD8A', 'EOMES']\n}\n\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10,4), gridspec_kw={'wspace':0.25})\nax1_dict = sc.pl.umap(adNorm,color=['leiden_R'], alpha=.75, s=10, legend_loc='on data', ax=ax1, show=False)\nax2_dict = sc.pl.dotplot(adNorm, marker_genes_sub_dict, 'leiden_R', dendrogram=True,ax=ax2, show=False)\nplt.show()\n</pre> marker_genes_sub_dict = {     'B cell': ['CD79A'],     'Dendritic': ['CLEC4C'],     'CD14 monocyte': ['CD14'],     'CD16 monocyte': ['FCGR3A'],     'NK cell': ['GNLY'],     'CD4 T cell': ['CD4', 'GATA3'],     'CD8 T cell': ['CD8A', 'EOMES'] }  fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10,4), gridspec_kw={'wspace':0.25}) ax1_dict = sc.pl.umap(adNorm,color=['leiden_R'], alpha=.75, s=10, legend_loc='on data', ax=ax1, show=False) ax2_dict = sc.pl.dotplot(adNorm, marker_genes_sub_dict, 'leiden_R', dendrogram=True,ax=ax2, show=False) plt.show() <pre>WARNING: Groups are not reordered because the `groupby` categories and the `var_group_labels` are different.\ncategories: 0, 1, 2,0, etc.\nvar_group_labels: B cell, Dendritic, CD14 monocyte, etc.\n</pre> <p>We are close to a final annotation now:</p> cluster markers  of cell type 5 B, Dendritic, Mono doublet 1 Monocyte CD14 Monocyte 4,0 Monocyte CD16 Monocyte 3 B B-cell 6 Dendritic (B/Mono?) Dendritic cell 7 none Mystery cell 0 T cell CD4 T cell 2,0 T cell CD8 T cell 2,1 NK cell NK cell <p>But what is cluster 7? It has low counts. If it is just ambient 'soup', then we would not expect it to have high levels of cell type specific genes. Let's do differential gene expression analysis to see what is upregulated in this cluster.</p> In\u00a0[54]: Copied! <pre>sc.tl.rank_genes_groups(adNorm, use_raw=False, groupby=\"leiden_R\")\n</pre> sc.tl.rank_genes_groups(adNorm, use_raw=False, groupby=\"leiden_R\") In\u00a0[55]: Copied! <pre>sc.pl.rank_genes_groups_dotplot(adNorm, n_genes=5, groupby=\"leiden_R\", dendrogram=True, key='rank_genes_groups')\n</pre> sc.pl.rank_genes_groups_dotplot(adNorm, n_genes=5, groupby=\"leiden_R\", dendrogram=True, key='rank_genes_groups') In\u00a0[56]: Copied! <pre>sc.pl.rank_genes_groups_dotplot(adNorm, n_genes=20, groupby=\"leiden_R\", dendrogram=True, key='rank_genes_groups', groups=['7'])\n</pre> sc.pl.rank_genes_groups_dotplot(adNorm, n_genes=20, groupby=\"leiden_R\", dendrogram=True, key='rank_genes_groups', groups=['7']) <pre>WARNING: Groups are not reordered because the `groupby` categories and the `var_group_labels` are different.\ncategories: 0, 1, 2,0, etc.\nvar_group_labels: 7\n</pre> <p>Although this result could be refined and explored a lot, it is sufficient for us to address our question about the identity of cluster 7 as follows:</p> Help from ChatGPT to annotate cells <p>Now, let's add the annotation to the anndata.obs and discard the other cells</p> cluster markers  of cell type 1 Monocyte CD14 Monocyte 4,0 Monocyte CD16 Monocyte 3 B B-cell 6 Dendritic (B/Mono?) Dendritic cell 7 none Platelet 0 T cell CD4 T cell 2,0 T cell CD8 T cell 2,1 NK cell NK cell In\u00a0[57]: Copied! <pre>tokeep = [\"1\", \"4,0\", \"3\", \"6\", \"7\", \"0\", \"2,0\", \"2,1\"]\nadNorm2 = adNorm.copy()\nadNorm2 = adNorm2[adNorm2.obs['leiden_R'].isin(tokeep)].copy()\nadNorm2.shape\nadNorm2.obs['leiden_R'].value_counts()\n</pre> tokeep = [\"1\", \"4,0\", \"3\", \"6\", \"7\", \"0\", \"2,0\", \"2,1\"] adNorm2 = adNorm.copy() adNorm2 = adNorm2[adNorm2.obs['leiden_R'].isin(tokeep)].copy() adNorm2.shape adNorm2.obs['leiden_R'].value_counts() Out[57]: <pre>leiden_R\n0      3563\n1      3115\n3      1604\n2,0    1031\n2,1     611\n4,0     368\n6        81\n7        60\nName: count, dtype: int64</pre> In\u00a0[58]: Copied! <pre>cell_dict = {'Dendritic': ['6'],\n             'CD14 Monocyte': ['1'],\n             'CD16 Monocyte': [\"4,0\"],\n             'B cell': ['3'],\n             'Platelet': ['7'],\n             'CD4 T cell': ['0'],\n             'CD8 T cell': [\"2,0\"],\n             'NK cell': [\"2,1\"]\n}\n\nmarker_genes_dict = {\n    'B cell': ['CD79A'],\n    'Dendritic': ['CLEC4C'],\n    'CD14 monocyte': ['CD14'],\n    'CD16 monocyte': ['FCGR3A'],\n    'NK cell': ['GNLY'],\n    'CD4 T cell': ['CD4', 'GATA3'],\n    'CD8 T cell': ['CD8A', 'EOMES'],\n    'Platelet': ['PF4', 'CAVIN2']\n}\n\n\nnew_obs_name = 'cell_type'\nadNorm2.obs[new_obs_name] = np.nan\n\nfor i in cell_dict.keys():\n    ind = pd.Series(adNorm2.obs.leiden_R).isin(cell_dict[i])\n    adNorm2.obs.loc[ind,new_obs_name] = i\n\nadNorm2.obs['cell_type'] = adNorm2.obs['cell_type'].astype(\"category\")\n</pre> cell_dict = {'Dendritic': ['6'],              'CD14 Monocyte': ['1'],              'CD16 Monocyte': [\"4,0\"],              'B cell': ['3'],              'Platelet': ['7'],              'CD4 T cell': ['0'],              'CD8 T cell': [\"2,0\"],              'NK cell': [\"2,1\"] }  marker_genes_dict = {     'B cell': ['CD79A'],     'Dendritic': ['CLEC4C'],     'CD14 monocyte': ['CD14'],     'CD16 monocyte': ['FCGR3A'],     'NK cell': ['GNLY'],     'CD4 T cell': ['CD4', 'GATA3'],     'CD8 T cell': ['CD8A', 'EOMES'],     'Platelet': ['PF4', 'CAVIN2'] }   new_obs_name = 'cell_type' adNorm2.obs[new_obs_name] = np.nan  for i in cell_dict.keys():     ind = pd.Series(adNorm2.obs.leiden_R).isin(cell_dict[i])     adNorm2.obs.loc[ind,new_obs_name] = i  adNorm2.obs['cell_type'] = adNorm2.obs['cell_type'].astype(\"category\")   <pre>/var/folders/1_/v5grqr5n7kj42276bb6ryxj00000gn/T/ipykernel_66578/4042500018.py:28: FutureWarning: Setting an item of incompatible dtype is deprecated and will raise an error in a future version of pandas. Value 'Dendritic' has dtype incompatible with float64, please explicitly cast to a compatible dtype first.\n  adNorm2.obs.loc[ind,new_obs_name] = i\n</pre> In\u00a0[59]: Copied! <pre>sc.tl.dendrogram(adNorm2, \"cell_type\")\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12,5), gridspec_kw={'wspace':0.4})\nax1_dict = sc.pl.umap(adNorm2,color=['cell_type'], alpha=.75, s=10, legend_loc='on data', ax=ax1, show=False)\nax2_dict = sc.pl.dotplot(adNorm2, marker_genes_dict, 'cell_type', dendrogram=True,ax=ax2, show=False)\nplt.show()\n</pre> sc.tl.dendrogram(adNorm2, \"cell_type\") fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12,5), gridspec_kw={'wspace':0.4}) ax1_dict = sc.pl.umap(adNorm2,color=['cell_type'], alpha=.75, s=10, legend_loc='on data', ax=ax1, show=False) ax2_dict = sc.pl.dotplot(adNorm2, marker_genes_dict, 'cell_type', dendrogram=True,ax=ax2, show=False) plt.show()  <pre>WARNING: Groups are not reordered because the `groupby` categories and the `var_group_labels` are different.\ncategories: B cell, CD14 Monocyte, CD16 Monocyte, etc.\nvar_group_labels: B cell, Dendritic, CD14 monocyte, etc.\n</pre> In\u00a0[60]: Copied! <pre>sc.pl.pca(adNorm2, color=['cell_type', 'GNLY'], alpha=.75, s=15, projection='3d')\n</pre> sc.pl.pca(adNorm2, color=['cell_type', 'GNLY'], alpha=.75, s=15, projection='3d') In\u00a0[61]: Copied! <pre>sc.tl.rank_genes_groups(adNorm2, use_raw=False, groupby=\"cell_type\")\n</pre> sc.tl.rank_genes_groups(adNorm2, use_raw=False, groupby=\"cell_type\") In\u00a0[62]: Copied! <pre>sc.tl.filter_rank_genes_groups(adNorm2, min_fold_change=.7, min_in_group_fraction=.5, max_out_group_fraction=.15)\nsc.pl.rank_genes_groups_dotplot(adNorm2, n_genes=6, groupby=\"cell_type\", dendrogram=True, key='rank_genes_groups_filtered')\n</pre> sc.tl.filter_rank_genes_groups(adNorm2, min_fold_change=.7, min_in_group_fraction=.5, max_out_group_fraction=.15) sc.pl.rank_genes_groups_dotplot(adNorm2, n_genes=6, groupby=\"cell_type\", dendrogram=True, key='rank_genes_groups_filtered')"},{"location":"notebooks/scBasics.html#fundamentals-of-scrna-seq-analysis-in-python-lecture-3-01-28-2025","title":"Fundamentals of scRNA-seq analysis in Python Lecture 3, 01-28-2025\u00b6","text":"<p>This notebook is part the course 580.447/647 Computational Stem Cell Biology taught by Patrick Cahan at Johns Hopkins University in Winter/Spring 2025. Many parts of this notebook are derived from the sources listed in the Resources section at the end of this notebook.</p>"},{"location":"notebooks/scBasics.html#objectives-for-today","title":"Objectives for today\u00b6","text":"<p>After completing this tutorial, students will be familiar with:</p> <ol> <li>Basics of Scanpy<ol> <li>annData</li> <li>loading and saving files</li> <li>getting var info</li> <li>getting more help: scanpy docs, tutorials, ChatGPT</li> </ol> </li> <li>Quality control</li> <li>Normalization</li> <li>Dimension reduction</li> <li>Cell-cell distance</li> <li>Unsupervised clustering</li> <li>Differential gene expression</li> <li>Cell annotation</li> </ol>"},{"location":"notebooks/scBasics.html#background-on-the-data","title":"Background on the data\u00b6","text":"<p>Let's start with some background + motivation for the data set that we are going to analyze: hematopoietic cells from peripheral blood.</p>"},{"location":"notebooks/scBasics.html#hematopoiesis","title":"Hematopoiesis\u00b6","text":"Traditional model of hematopoiesis. Image from Slack 2017 <p>These cells are produced in the bone marrow and then move into the vascular so that they can move about the body and perform their functions (transport oxygen, clot, do adaptive and innate immune things).</p>"},{"location":"notebooks/scBasics.html#peripheral-blood-mononuclear-cells-pbmcs","title":"Peripheral blood mononuclear cells (PBMCs)\u00b6","text":"<p>It is possible to enrich for what are called PBMCs from vein by subjecting sample to density gradient centrifugation. This enrichs for cells that have one, round nucleus, and excludes cells that do not have nuclie, or that have multi-lobed structures. PBMCs typically contain:</p> <p>... several classes of immune cells, including T cells (~70%), B cells (~15%), monocytes (~5%), dendritic cells (~1%) and natural killer (NK) cells (~10%)     --  Sen et al 2019</p> <p>and</p> <p>... The CD3+ lymphocytes are composed of CD4+ and CD8+ T cells, roughly in a 2:1 ratio.     -- Kleiveland, 2015</p>"},{"location":"notebooks/scBasics.html#bio-questions-for-the-day","title":"Bio question(s) for the day\u00b6","text":"<ul> <li>What does scRNAseq estimate as their relative proportion? and how does it compare to the estimate above?</li> <li>To what extent does cell type composition vary between samples?</li> <li>Are there other genes that are better at distinguishing between these populations than marker genes listed below?</li> <li>How many cells do you need to reliably detect a sub-population?</li> </ul>"},{"location":"notebooks/scBasics.html#data","title":"Data\u00b6","text":"<p>10X Genomics scRNA-seq on human PBMCs</p>"},{"location":"notebooks/scBasics.html#sample-1","title":"Sample 1\u00b6","text":"<ul> <li>http://cf.10xgenomics.com/samples/cell-exp/1.1.0/pbmc3k/pbmc3k_filtered_gene_bc_matrices.tar.gz</li> </ul>"},{"location":"notebooks/scBasics.html#sample-2","title":"Sample 2\u00b6","text":"<ul> <li>https://colab.research.google.com/corgiredirector?site=https%3A%2F%2Fcf.10xgenomics.com%2Fsamples%2Fcell-exp%2F6.1.0%2F20k_PBMC_3p_HT_nextgem_Chromium_X%2F20k_PBMC_3p_HT_nextgem_Chromium_X_filtered_feature_bc_matrix.h5</li> <li>20k Human PBMCs, 3\u2019 HT v3.1, Chromium X</li> <li>Sourced from a healthy female donor</li> <li>23,837 cells</li> <li>35,000 reads per cell</li> <li>Filtered data in .h5 format</li> </ul>"},{"location":"notebooks/scBasics.html#cellranger","title":"CellRanger\u00b6","text":"<p>CellRanger is the program that converts sequencing reads into gene expression counts.</p> CellRanger flow chart from 10X genomics"},{"location":"notebooks/scBasics.html#installation","title":"Installation\u00b6","text":"<p>If you choose to analyze data from your own computer, please use an environment manager like conda.</p>"},{"location":"notebooks/scBasics.html#fetch-data-files","title":"Fetch data file(s)\u00b6","text":""},{"location":"notebooks/scBasics.html#scanpy-basics","title":"Scanpy basics\u00b6","text":""},{"location":"notebooks/scBasics.html#load-packages","title":"load packages\u00b6","text":""},{"location":"notebooks/scBasics.html#load-sample-1","title":"Load Sample 1\u00b6","text":""},{"location":"notebooks/scBasics.html#getting-information-about-functions","title":"Getting information about functions\u00b6","text":"<p>You can get info about functions using</p> <p>help(functionName)</p> <p>or</p> <p>?functionName</p>"},{"location":"notebooks/scBasics.html#inspecting-the-data-gross-properties","title":"Inspecting the data -- gross properties\u00b6","text":""},{"location":"notebooks/scBasics.html#package-documentation","title":"Package documentation\u00b6","text":"<p>Often, the best source of help is the package's documentation.</p> <p>Scanpy's documentation</p>"},{"location":"notebooks/scBasics.html#anndata","title":"AnnData\u00b6","text":"<p>AnnData is a Python package that defines a data structure designed to efficiently store large data sets like scRNA-seq.</p> AnnData schema. AnnData documentation. See Resouces below for more"},{"location":"notebooks/scBasics.html#slicing-or-subsetting","title":"Slicing or subsetting\u00b6","text":"<p>There are lots of ways to get parts of an adata obkect. Here, let's randomly select a subset of cells and genes.</p>"},{"location":"notebooks/scBasics.html#gene-counts","title":"Gene counts\u00b6","text":"<p>So, where is the data?</p>"},{"location":"notebooks/scBasics.html#the-metadata","title":"The Metadata\u00b6","text":"<ul> <li>for cells, see .obs</li> <li>for genesm see .var</li> </ul>"},{"location":"notebooks/scBasics.html#loc","title":".loc\u00b6","text":"<p>.obs and .var are Pandas dataframes and so you can access subsets of them using .loc and .iloc</p>"},{"location":"notebooks/scBasics.html#quality-control-qc","title":"Quality Control (QC)\u00b6","text":"<p>Broadly speaking there are two things that we apply quality control to:</p> <ol> <li>Cells: We want to find putative doublets and low quality cell barcodes and hold them out of downstram analysis.</li> <li>Genes: We also can remove genes that are not detected in vast majority of cell</li> </ol> <p>The function <code>sc.pp.calculate_qc_metrics()</code> will calculate a set of metrics on adata and place the results in .obs or .var. The results can then be used to filter the adata. <code>pp.calculate_qc_metrics()</code> can also take inputs to specify other, custom metrics to compute.</p> <p>Below, we use it to compute the fraction of all UMIs in each cell that are mitochondrially encoded or that encode for ribosomal genes.</p>"},{"location":"notebooks/scBasics.html#visualize","title":"Visualize\u00b6","text":"<p>Take a look some typical QC values across these data</p>"},{"location":"notebooks/scBasics.html#normalization","title":"Normalization\u00b6","text":"<p>Simple library size scaling, then log transform. There are many other ways to correct for cell-to-cell technical variation, for example different cell lysis efficiencies, but this method is good enough for this data set and our goals.</p>"},{"location":"notebooks/scBasics.html#highly-variable-genes-hvg","title":"Highly variable genes (HVG)\u00b6","text":"<p>It is common practice to limit some parts of analysis to those variables/genes that exhibit some degree of variation in their values across the data. We call these highly variable genes, or HVG for short. To find these, calculate some gene statistics, which when combined with thresholds below, determine which genes are considered HVG. The relevant metrics are:</p> <ol> <li>mean expression</li> <li>dispersion, which is the variance / mean.</li> </ol> <p>Variance is defined as the expected squared deviation of gene expression. The normalized dispersion is calculated by scaling based on a bin of mean expression.</p>"},{"location":"notebooks/scBasics.html#dimensionality-reduction-with-principal-components-analysis-pca","title":"Dimensionality reduction with Principal components analysis (PCA)\u00b6","text":"<p>Why performan dimentaionality reduction?</p> <ol> <li>Genes are expressed in coordinated fashion, meaning that many have correlated expression patterns and so PCA reduces the computational complexity of downstream analysis</li> <li>scRNA-seq data is noisy on a per gene basis.</li> </ol> <p>PCA allows us to reduce a high dimensional data set into a lower dimension in which much of the total variation is maintained. To understand PCA, you need to know linear algebra. In essence, it identifies sets of linear combinations of genes in such a way that a PC is uncorrelated with other PCs and that explains most variation in the data. The function call <code>sc.tl.pca</code> does the following:</p> <ol> <li>computes the covariance matrix (correlation between each pair of genes)</li> <li>finds eigenvectors (directions of axes that maximize that variance), orthogonal to each other</li> </ol> <p>Later, we select a threshold (n_pcs) as the number of PCs that contribute most to the total variation on our data. We use these n_pcs PCs to compute cell-to-cell distances for embedding (2D visualization via UMAP) and for clustering of cells.</p>"},{"location":"notebooks/scBasics.html#marker-genes","title":"Marker genes\u00b6","text":"<p>Here PBMC cell types and some genes that have been used to identify them: Monocytes: CD14, CD68, LYZ Dendritic: CLEC4C, FLT3 NK cells: GNLY, NCAM1 B cells: CD19, CD79A, CD79B T cells: CD3D, CD3E, TRAC, TRBC</p>"},{"location":"notebooks/scBasics.html#pca-loadings","title":"PCA Loadings\u00b6","text":"<p>Where are PCs (i.e. loadings -- the contribution of each gene to each PC) stored in anndata? .varm (see figure of anndata way above)?</p>"},{"location":"notebooks/scBasics.html#knn-cell-cell-distances","title":"kNN cell-cell distances\u00b6","text":"<p>The k-nearest neighbor graph generates an adjacency matrix by finding, for each cell, the k cells that are closest to it. This helps to reduce noise in computing cell-cell distances or similarities and is important for embedding the cells in a 2D space, and for community detection algorithms. Two arguments are n_neighbors, or k, and the number of PCs to use when computing cell-cell distances.</p>"},{"location":"notebooks/scBasics.html#visualization-of-cell-cell-similarities","title":"Visualization of cell-cell similarities\u00b6","text":""},{"location":"notebooks/scBasics.html#umap-embedding","title":"UMAP embedding\u00b6","text":"<p>This an elaboration on the t-SNE embedding approach. Both of these methods try to project cells into a reduced (typically 2) dimensional coordinate system while maintaining both the global and local structure of the high dimensional space of the data (i.e. cells that are distant from each other high dimensions should still be distant in the reduced embedding; same is true for cells that are near each other). The distances come from the kNN graph.</p>"},{"location":"notebooks/scBasics.html#unsupervised-clustering","title":"Unsupervised clustering\u00b6","text":"<p>Let's try to assign cells to distinct groups or clusters based on the cell-to-cell distances. Leiden and Louvain are examples of community detection methods that perform this task by searching for the group assignment that maximize within group similarity (which is equivalent to within group edges of a knn graph) and to minimize between group similarity.</p>"},{"location":"notebooks/scBasics.html#cluster-annotation","title":"Cluster annotation\u00b6","text":"<p>We can walk down the rows of the dotplot and guess at the cell types of some of these clusters based on the specificty of marker expression:</p> cluster markers  of cell type 5 B, Dendritic, Mono ??? 1 Monocyte Monocyte 4 Monocyte, T ??? 3 B B-cell 6 Dendritic (B/Mono?) Dendritic cell 7 none Mystery cell 0 T cell T cell 2 NK/T ??? <p>Some clusters are ambiguous because they express markers of more than one cell type. This could be due to the cluster containing &gt; 1 cell type, or because the cell barcodes are doublets. If the former, then we should be able to sub cluster them. Let's try this.</p> <p>Clusters to refine are 5, 4, and 2.</p>"},{"location":"notebooks/scBasics.html#differential-gene-expression","title":"Differential gene expression\u00b6","text":""},{"location":"notebooks/scBasics.html#differential-expression-analysis","title":"Differential expression analysis\u00b6","text":"<p>Let's identify genes that are preferenntially expressed in each cluster versus all the others as a final step to annotate these clusters and to remove ones that are likely to be doublets.</p>"},{"location":"notebooks/scBasics.html#dot-plot-of-differentially-expressed-genes","title":"Dot plot of differentially expressed genes\u00b6","text":"<p>First, we will apply a filter so that we only display genes that meet additional criteria beyond statistical: fold change, % expressed in cluster, % expressed in other cells</p>"},{"location":"notebooks/scBasics.html#resources","title":"Resources\u00b6","text":""},{"location":"notebooks/scBasics.html#tools","title":"Tools\u00b6","text":"<ul> <li>Colab<ul> <li>https://colab.research.google.com/</li> </ul> </li> <li>Jupyter<ul> <li>https://jupyter.org/</li> </ul> </li> <li>CellRanger<ul> <li>https://www.10xgenomics.com/support/software/cell-ranger/latest/advanced/cr-barcode-rank-plot</li> <li>https://www.10xgenomics.com/support/software/cell-ranger/latest/algorithms-overview/cr-gex-algorithm</li> </ul> </li> </ul>"},{"location":"notebooks/scBasics.html#literature","title":"Literature\u00b6","text":"<ul> <li>Best practices<ul> <li>best practices in sc analysis online book</li> <li>paper associated with the above online book</li> </ul> </li> <li>Scanpy<ul> <li>https://scanpy.readthedocs.io/en/stable/</li> <li>https://scanpy.readthedocs.io/en/stable/tutorials.html</li> <li>https://scanpy-tutorials.readthedocs.io/en/latest/pbmc3k.html</li> <li>https://scanpy-tutorials.readthedocs.io/en/latest/plotting/advanced.html</li> <li>https://scanpy-tutorials.readthedocs.io/en/latest/plotting/core.html</li> </ul> </li> <li>AnnData<ul> <li>https://anndata.readthedocs.io/en/latest/tutorials/notebooks/getting-started.html</li> <li>https://anndata.readthedocs.io/en/latest/index.html</li> </ul> </li> <li>QC<ul> <li>https://genomebiology.biomedcentral.com/articles/10.1186/s13059-020-02136-7</li> </ul> </li> </ul>"},{"location":"notebooks/scFates.html","title":"scFates","text":"<p>For more details on scFates, please see the documentation</p> <p>Point interpreter to R, import packages, fetch data.</p> In\u00a0[97]: Copied! <pre>import os, sys\nos.environ['R_HOME'] = sys.exec_prefix+\"/lib/R/\"\n</pre> import os, sys os.environ['R_HOME'] = sys.exec_prefix+\"/lib/R/\" In\u00a0[2]: Copied! <pre>print(os.environ['R_HOME'])\n</pre> print(os.environ['R_HOME']) <pre>/opt/homebrew/Caskroom/miniforge/base/envs/scFates/lib/R/\n</pre> In\u00a0[3]: Copied! <pre>import scanpy as sc\nimport scFates as scf\nimport numpy as np\nimport pandas as pd\n</pre> import scanpy as sc import scFates as scf import numpy as np import pandas as pd In\u00a0[4]: Copied! <pre>!wget https://compstemcellbio.s3.amazonaws.com/2024/TI/adata_Stam_250_022224.h5ad\n</pre> !wget https://compstemcellbio.s3.amazonaws.com/2024/TI/adata_Stam_250_022224.h5ad <pre>--2025-03-05 17:14:33--  https://compstemcellbio.s3.amazonaws.com/2024/TI/adata_Stam_250_022224.h5ad\nResolving compstemcellbio.s3.amazonaws.com (compstemcellbio.s3.amazonaws.com)... 52.217.84.52, 3.5.28.109, 3.5.20.136, ...\nconnected. to compstemcellbio.s3.amazonaws.com (compstemcellbio.s3.amazonaws.com)|52.217.84.52|:443... \nHTTP request sent, awaiting response... 200 OK\nLength: 30948532 (30M) [binary/octet-stream]\nSaving to: \u2018adata_Stam_250_022224.h5ad.1\u2019\n\nadata_Stam_250_0222 100%[===================&gt;]  29.51M  19.1MB/s    in 1.5s    \n\n2025-03-05 17:14:35 (19.1 MB/s) - \u2018adata_Stam_250_022224.h5ad.1\u2019 saved [30948532/30948532]\n\n</pre> In\u00a0[5]: Copied! <pre>adata = sc.read_h5ad(\"adata_Stam_250_022224.h5ad\")\n</pre> adata = sc.read_h5ad(\"adata_Stam_250_022224.h5ad\") In\u00a0[6]: Copied! <pre>adata\n</pre> adata Out[6]: <pre>AnnData object with n_obs \u00d7 n_vars = 2750 \u00d7 36601\n    obs: 'day', 'sample', 'experiment', 'n_counts', 'n_genes_by_counts', 'total_counts', 'total_counts_mt', 'pct_counts_mt'\n    var: 'Accession', 'Chromosome', 'End', 'Start', 'Strand'</pre> In\u00a0[7]: Copied! <pre>adata.obs['sample'].value_counts()\n</pre> adata.obs['sample'].value_counts() Out[7]: <pre>sample\ncd34.day0    250\nery.day2     250\nery.day4     250\nery.day6     250\nery.day8     250\nery.day11    250\nmk.day2      250\nmk.day4      250\nmk.day6      250\nmk.day8      250\nmk.day11     250\nName: count, dtype: int64</pre> <p>Note that this partcular dataset is already normalized (your HW data will not be). Now find HVG</p> In\u00a0[8]: Copied! <pre>sc.pp.highly_variable_genes(adata , min_mean=0.0125, max_mean=6, min_disp=0.25)\n</pre> sc.pp.highly_variable_genes(adata , min_mean=0.0125, max_mean=6, min_disp=0.25) <p>Perform PCA, plot embedding, and color with marker genes for CD34 HSPCs, Erythrocytes, and Megakaryocytes (Human)</p> In\u00a0[9]: Copied! <pre>sc.tl.pca(adata, mask_var='highly_variable')\nsc.pl.pca(adata, color=[\"CD34\", \"HBA1\", \"PF4\"], s=20)\n</pre> sc.tl.pca(adata, mask_var='highly_variable') sc.pl.pca(adata, color=[\"CD34\", \"HBA1\", \"PF4\"], s=20) In\u00a0[10]: Copied! <pre>sc.pl.pca(adata, color='sample')\n</pre> sc.pl.pca(adata, color='sample') <p><code>cf.tl.tree()</code> fits a principal tree to this embedding.</p> <p>See documentation for parameters</p> In\u00a0[11]: Copied! <pre>adata\n</pre> adata Out[11]: <pre>AnnData object with n_obs \u00d7 n_vars = 2750 \u00d7 36601\n    obs: 'day', 'sample', 'experiment', 'n_counts', 'n_genes_by_counts', 'total_counts', 'total_counts_mt', 'pct_counts_mt'\n    var: 'Accession', 'Chromosome', 'End', 'Start', 'Strand', 'highly_variable', 'means', 'dispersions', 'dispersions_norm'\n    uns: 'hvg', 'pca', 'sample_colors'\n    obsm: 'X_pca'\n    varm: 'PCs'</pre> In\u00a0[12]: Copied! <pre>adata.obsm['X_pca'].shape\n</pre> adata.obsm['X_pca'].shape Out[12]: <pre>(2750, 50)</pre> In\u00a0[13]: Copied! <pre>scf.tl.tree(adata,method=\"ppt\",Nodes=10,use_rep=\"X_pca\")\n</pre> scf.tl.tree(adata,method=\"ppt\",Nodes=10,use_rep=\"X_pca\") <pre>inferring a principal tree --&gt; parameters used \n    10 principal points, sigma = 0.1, lambda = 1, metric = euclidean\n    fitting:   2%|\u258c                              | 1/50 [00:00&lt;00:24,  2.03it/s]\n    converged\n    finished (0:00:00) --&gt; added \n    .uns['ppt'], dictionnary containing inferred tree.\n    .obsm['X_R'] soft assignment of cells to principal points.\n    .uns['graph']['B'] adjacency matrix of the principal points.\n    .uns['graph']['F'] coordinates of principal points in representation space.\n</pre> <p>Plot the tree on top of the pca embedding with scf.pl.graph()</p> In\u00a0[14]: Copied! <pre>scf.pl.graph(adata, basis='pca')\n</pre> scf.pl.graph(adata, basis='pca') <p>Why does the trajectory bend back (top left)?</p> In\u00a0[15]: Copied! <pre>sc.pl.pca(adata, color=[\"sample\"],projection=\"3d\", components = ['1,2,3', '1,3,2'], s=20)\n</pre> sc.pl.pca(adata, color=[\"sample\"],projection=\"3d\", components = ['1,2,3', '1,3,2'], s=20) <p>We should restrict tree finding to 1st 3 PCs</p> In\u00a0[16]: Copied! <pre>scf.tl.tree(adata, method=\"ppt\", Nodes=10, use_rep=\"X_pca\", ndims_rep = 3)\n</pre> scf.tl.tree(adata, method=\"ppt\", Nodes=10, use_rep=\"X_pca\", ndims_rep = 3) <pre>inferring a principal tree --&gt; parameters used \n    10 principal points, sigma = 0.1, lambda = 1, metric = euclidean\n    fitting:   0%|                                       | 0/50 [00:00&lt;?, ?it/s]\n    converged\n    finished (0:00:00) --&gt; added \n    .uns['ppt'], dictionnary containing inferred tree.\n    .obsm['X_R'] soft assignment of cells to principal points.\n    .uns['graph']['B'] adjacency matrix of the principal points.\n    .uns['graph']['F'] coordinates of principal points in representation space.\n</pre> In\u00a0[17]: Copied! <pre>scf.pl.graph(adata, basis='pca')\n</pre> scf.pl.graph(adata, basis='pca') <p>Explore other parameters:</p> <ul> <li><code>nodes</code></li> <li><code>ppt_lambda</code></li> <li><code>ppt_sigma</code></li> </ul> In\u00a0[18]: Copied! <pre>scf.tl.tree(adata,method=\"ppt\",Nodes=50,use_rep=\"X_pca\", ndims_rep = 3)\nscf.pl.graph(adata, basis='pca')\n</pre> scf.tl.tree(adata,method=\"ppt\",Nodes=50,use_rep=\"X_pca\", ndims_rep = 3) scf.pl.graph(adata, basis='pca') <pre>inferring a principal tree --&gt; parameters used \n    50 principal points, sigma = 0.1, lambda = 1, metric = euclidean\n    fitting:  42%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258f                | 21/50 [00:00&lt;00:00, 121.76it/s]\n    converged\n    finished (0:00:00) --&gt; added \n    .uns['ppt'], dictionnary containing inferred tree.\n    .obsm['X_R'] soft assignment of cells to principal points.\n    .uns['graph']['B'] adjacency matrix of the principal points.\n    .uns['graph']['F'] coordinates of principal points in representation space.\n</pre> In\u00a0[19]: Copied! <pre>scf.tl.tree(adata,method=\"ppt\",Nodes=100,use_rep=\"X_pca\", ppt_lambda=100,ppt_sigma=0.75,ppt_nsteps=100, ndims_rep = 3)\nscf.pl.graph(adata, basis='pca')\n</pre> scf.tl.tree(adata,method=\"ppt\",Nodes=100,use_rep=\"X_pca\", ppt_lambda=100,ppt_sigma=0.75,ppt_nsteps=100, ndims_rep = 3) scf.pl.graph(adata, basis='pca') <pre>inferring a principal tree --&gt; parameters used \n    100 principal points, sigma = 0.75, lambda = 100, metric = euclidean\n    fitting:  30%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d                   | 30/100 [00:00&lt;00:00, 116.04it/s]\n    converged\n    finished (0:00:00) --&gt; added \n    .uns['ppt'], dictionnary containing inferred tree.\n    .obsm['X_R'] soft assignment of cells to principal points.\n    .uns['graph']['B'] adjacency matrix of the principal points.\n    .uns['graph']['F'] coordinates of principal points in representation space.\n</pre> <p>Set a root node with scf.tl.root()</p> <p>Then compute Pseudotime with scf.tl.pseudotime()</p> In\u00a0[20]: Copied! <pre>scf.tl.root(adata, 96)\n</pre> scf.tl.root(adata, 96) <pre>node 96 selected as a root --&gt; added\n    .uns['graph']['root'] selected root.\n    .uns['graph']['pp_info'] for each PP, its distance vs root and segment assignment.\n    .uns['graph']['pp_seg'] segments network information.\n</pre> <p>tl.pseudotime also assigns cells to:</p> <p>obs. \"seg\", \"milestones\"</p> <p>plot PCA colored by ^^</p> In\u00a0[21]: Copied! <pre>scf.tl.pseudotime(adata,seed=42)\n</pre> scf.tl.pseudotime(adata,seed=42)  <pre>projecting cells onto the principal graph\n    finished (0:00:00) --&gt; added\n    .obs['edge'] assigned edge.\n    .obs['t'] pseudotime value.\n    .obs['seg'] segment of the tree assigned.\n    .obs['milestones'] milestone assigned.\n    .uns['pseudotime_list'] list of cell projection from all mappings.\n</pre> In\u00a0[22]: Copied! <pre>sc.pl.pca(adata, color=[\"seg\", \"milestones\"])\n</pre> sc.pl.pca(adata, color=[\"seg\", \"milestones\"]) In\u00a0[23]: Copied! <pre>sc.pl.pca(adata, color=[\"seg\", \"milestones\"],projection=\"3d\", components = ['1,2,3', '1,3,2'], s=20)\n</pre> sc.pl.pca(adata, color=[\"seg\", \"milestones\"],projection=\"3d\", components = ['1,2,3', '1,3,2'], s=20) <p>You can overlay trajectory, PT, on the embedding with scf.pl.trajectory()</p> In\u00a0[24]: Copied! <pre>scf.pl.trajectory(adata, basis='pca')\n</pre> scf.pl.trajectory(adata, basis='pca') <p>And you can use scany plotting to show pseudotime for each cell</p> In\u00a0[25]: Copied! <pre>sc.pl.pca(adata, color='t')\nsc.pl.pca(adata, color=[\"t\"],projection=\"3d\", components = ['1,2,3', '1,3,2'], s=20)\n</pre> sc.pl.pca(adata, color='t') sc.pl.pca(adata, color=[\"t\"],projection=\"3d\", components = ['1,2,3', '1,3,2'], s=20) <p>cluster cells into a real tree with scf.tl.dendrogram() and plot with scf.pl.dendrogram()</p> In\u00a0[26]: Copied! <pre>scf.tl.dendrogram(adata)\n</pre> scf.tl.dendrogram(adata) <pre>Generating dendrogram of tree\n    segment : 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3/3 [00:00&lt;00:00,  3.29it/s]\n    finished (0:00:00) --&gt; added \n    .obsm['X_dendro'], new embedding generated.\n    .uns['dendro_segments'] tree segments used for plotting.\n</pre> In\u00a0[28]: Copied! <pre>scf.pl.dendrogram(adata, color=['HBA1'])\n</pre> scf.pl.dendrogram(adata, color=['HBA1']) <p>Test for genes whose expresion is associated with PT and branching</p> <p>First, subset the data so that this is quick</p> In\u00a0[39]: Copied! <pre>ad2 = adata.copy()\nad2 = ad2[:,ad2.var['highly_variable']]\n# to speed up execution of test_association, sub-sample the data as below\n# ad2 = ad2[:,np.random.choice(ad2.n_vars, 500, replace=False)]\n\n# you can also specify the number of jobs to run in parallel if you system supports this with the n_jobs parameter\n</pre> ad2 = adata.copy() ad2 = ad2[:,ad2.var['highly_variable']] # to speed up execution of test_association, sub-sample the data as below # ad2 = ad2[:,np.random.choice(ad2.n_vars, 500, replace=False)]  # you can also specify the number of jobs to run in parallel if you system supports this with the n_jobs parameter <p>Now perform the test</p> In\u00a0[75]: Copied! <pre>scf.tl.test_association(ad2, fdr_cut=0.25, A_cut=.4, n_jobs = 20)\n</pre> scf.tl.test_association(ad2, fdr_cut=0.25, A_cut=.4, n_jobs = 20) <pre>test features for association with the trajectory\n    single mapping : 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 4639/4639 [00:49&lt;00:00, 93.67it/s]\n    found 699 significant features (0:00:49) --&gt; added\n    .var['p_val'] values from statistical test.\n    .var['fdr'] corrected values from multiple testing.\n    .var['st'] proportion of mapping in which feature is significant.\n    .var['A'] amplitue of change of tested feature.\n    .var['signi'] feature is significantly changing along pseudotime.\n    .uns['stat_assoc_list'] list of fitted features on the graph for all mappings.\n</pre> <pre>/opt/homebrew/Caskroom/miniforge/base/envs/scFates/lib/python3.12/site-packages/scFates/tools/test_association.py:413: ImplicitModificationWarning: Trying to modify attribute `.var` of view, initializing view as actual.\n  adata.var[c] = stat_assoc[c]\n</pre> In\u00a0[76]: Copied! <pre># ad2.var['signi'].value_counts()\n</pre> # ad2.var['signi'].value_counts()  In\u00a0[77]: Copied! <pre>ad3 = ad2.copy()\nscf.tl.fit(ad3, n_jobs=20) # fits genes to trajectory\nad3.var\n</pre> ad3 = ad2.copy() scf.tl.fit(ad3, n_jobs=20) # fits genes to trajectory ad3.var <pre>fit features associated with the trajectory\n    single mapping :  71%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258f     | 497/699 [00:10&lt;00:04, 48.73it/s]</pre> <pre>/opt/homebrew/Caskroom/miniforge/base/envs/scFates/lib/python3.12/site-packages/joblib/externals/loky/process_executor.py:752: UserWarning: A worker stopped while some jobs were given to the executor. This can be caused by a too short worker timeout or by a memory leak.\n  warnings.warn(\n</pre> <pre>    single mapping :  73%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c     | 510/699 [00:11&lt;00:04, 46.21it/s]</pre> <pre>Numba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\n</pre> <pre>    single mapping : 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 699/699 [00:17&lt;00:00, 39.97it/s]\n    finished (adata subsetted to keep only fitted features!) (0:00:17) --&gt; added\n    .layers['fitted'], fitted features on the trajectory for all mappings.\n    .raw, unfiltered data.\n</pre> Out[77]: Accession Chromosome End Start Strand highly_variable means dispersions dispersions_norm p_val A fdr st signi HP1BP3 ENSG00000127483 1 20787323 20742679 - True 0.769912 1.865717 0.448787 1.181477e-16 0.499296 5.480873e-13 1 True EIF4G3 ENSG00000075151 1 21176888 20806292 - True 0.450619 1.914048 0.730141 1.092165e-93 0.827920 5.066555e-90 1 True HNRNPR ENSG00000125944 1 23344336 23303771 - True 0.582793 1.787895 0.273731 3.026882e-40 0.529806 1.404171e-36 1 True ID3 ENSG00000117318 1 23559501 23557926 - True 0.331609 2.872770 4.198693 4.870580e-212 1.142615 2.259462e-208 1 True RHCE ENSG00000188672 1 25430192 25362249 - True 0.428462 1.796913 0.306358 0.000000e+00 1.337406 0.000000e+00 1 True ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... PGRMC1 ENSG00000101856 X 119244466 119236245 + True 0.555356 1.794529 0.297733 1.834102e-19 0.440285 8.508400e-16 1 True RAB33A ENSG00000134594 X 130184870 130171962 + True 0.470637 1.811213 0.358095 1.758523e-75 0.713661 8.157787e-72 1 True PHF6 ENSG00000156531 X 134428791 134373253 + True 0.425871 1.936639 0.811870 8.659728e-20 0.405178 4.017248e-16 1 True FHL1 ENSG00000022267 X 136211359 136146702 + True 0.591447 2.977816 4.578740 2.898772e-143 1.173347 1.344740e-139 1 True ATP6AP1 ENSG00000071553 X 154436516 154428645 + True 0.499192 1.795571 0.301502 1.386872e-26 0.513673 6.433700e-23 1 True <p>699 rows \u00d7 14 columns</p> In\u00a0[78]: Copied! <pre>ad3.var['st'].value_counts()\n</pre> ad3.var['st'].value_counts() Out[78]: <pre>st\n1    699\nName: count, dtype: int64</pre> In\u00a0[79]: Copied! <pre>scf.pl.single_trend(ad3,\"HBA1\",basis=\"pca\")\n</pre> scf.pl.single_trend(ad3,\"HBA1\",basis=\"pca\") In\u00a0[80]: Copied! <pre>scf.pl.single_trend(ad3,\"ID3\",basis=\"pca\")\n</pre> scf.pl.single_trend(ad3,\"ID3\",basis=\"pca\") In\u00a0[81]: Copied! <pre>scf.pl.single_trend(ad3,\"PF4\",basis=\"pca\")\n</pre> scf.pl.single_trend(ad3,\"PF4\",basis=\"pca\") In\u00a0[82]: Copied! <pre>scf.pl.single_trend(ad3,\"PF4\",basis=\"dendro\")\n</pre> scf.pl.single_trend(ad3,\"PF4\",basis=\"dendro\") In\u00a0[84]: Copied! <pre>scf.pl.single_trend(ad3,\"PF4\",basis=\"dendro\")\nscf.pl.single_trend(ad3,\"HBA1\",basis=\"dendro\")\n</pre> scf.pl.single_trend(ad3,\"PF4\",basis=\"dendro\") scf.pl.single_trend(ad3,\"HBA1\",basis=\"dendro\") In\u00a0[85]: Copied! <pre>scf.tl.test_fork(ad3,root_milestone=\"96\",milestones=[\"66\",\"92\"],n_jobs=20,rescale=True)\n</pre> scf.tl.test_fork(ad3,root_milestone=\"96\",milestones=[\"66\",\"92\"],n_jobs=20,rescale=True) <pre>testing fork\n    single mapping\n    Differential expression:   2%|\u258e            | 15/699 [00:00&lt;00:21, 32.44it/s]</pre> <pre>/opt/homebrew/Caskroom/miniforge/base/envs/scFates/lib/python3.12/site-packages/joblib/externals/loky/process_executor.py:752: UserWarning: A worker stopped while some jobs were given to the executor. This can be caused by a too short worker timeout or by a memory leak.\n  warnings.warn(\n</pre> <pre>    Differential expression:   2%|\u258e            | 16/699 [00:01&lt;01:07, 10.17it/s]</pre> <pre>Numba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\n/opt/homebrew/Caskroom/miniforge/base/envs/scFates/lib/python3.12/site-packages/joblib/externals/loky/process_executor.py:752: UserWarning: A worker stopped while some jobs were given to the executor. This can be caused by a too short worker timeout or by a memory leak.\n  warnings.warn(\n</pre> <pre>    Differential expression:   3%|\u258e            | 18/699 [00:02&lt;01:24,  8.07it/s]</pre> <pre>Numba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\n/opt/homebrew/Caskroom/miniforge/base/envs/scFates/lib/python3.12/site-packages/joblib/externals/loky/process_executor.py:752: UserWarning: A worker stopped while some jobs were given to the executor. This can be caused by a too short worker timeout or by a memory leak.\n  warnings.warn(\n</pre> <pre>    Differential expression:   3%|\u258e            | 20/699 [00:02&lt;01:37,  6.96it/s]</pre> <pre>Numba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\n/opt/homebrew/Caskroom/miniforge/base/envs/scFates/lib/python3.12/site-packages/joblib/externals/loky/process_executor.py:752: UserWarning: A worker stopped while some jobs were given to the executor. This can be caused by a too short worker timeout or by a memory leak.\n  warnings.warn(\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\n</pre> <pre>    Differential expression:   8%|\u2588            | 54/699 [00:05&lt;01:06,  9.66it/s]</pre> <pre>Numba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\n</pre> <pre>    Differential expression:   8%|\u2588            | 58/699 [00:05&lt;01:02, 10.34it/s]</pre> <pre>/opt/homebrew/Caskroom/miniforge/base/envs/scFates/lib/python3.12/site-packages/joblib/externals/loky/process_executor.py:752: UserWarning: A worker stopped while some jobs were given to the executor. This can be caused by a too short worker timeout or by a memory leak.\n  warnings.warn(\n</pre> <pre>    Differential expression:   9%|\u2588            | 60/699 [00:06&lt;01:13,  8.70it/s]</pre> <pre>Numba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\n/opt/homebrew/Caskroom/miniforge/base/envs/scFates/lib/python3.12/site-packages/joblib/externals/loky/process_executor.py:752: UserWarning: A worker stopped while some jobs were given to the executor. This can be caused by a too short worker timeout or by a memory leak.\n  warnings.warn(\n</pre> <pre>    Differential expression:  10%|\u2588\u258e           | 71/699 [00:07&lt;01:09,  9.05it/s]</pre> <pre>Numba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\n/opt/homebrew/Caskroom/miniforge/base/envs/scFates/lib/python3.12/site-packages/joblib/externals/loky/process_executor.py:752: UserWarning: A worker stopped while some jobs were given to the executor. This can be caused by a too short worker timeout or by a memory leak.\n  warnings.warn(\nNumba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\n</pre> <pre>    Differential expression:  12%|\u2588\u258c           | 82/699 [00:09&lt;01:14,  8.28it/s]</pre> <pre>Numba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\n</pre> <pre>    Differential expression:  15%|\u2588\u258a          | 102/699 [00:10&lt;00:58, 10.14it/s]</pre> <pre>/opt/homebrew/Caskroom/miniforge/base/envs/scFates/lib/python3.12/site-packages/joblib/externals/loky/process_executor.py:752: UserWarning: A worker stopped while some jobs were given to the executor. This can be caused by a too short worker timeout or by a memory leak.\n  warnings.warn(\n</pre> <pre>    Differential expression:  18%|\u2588\u2588\u258f         | 126/699 [00:11&lt;00:53, 10.78it/s]</pre> <pre>Numba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\n</pre> <pre>    Differential expression:  32%|\u2588\u2588\u2588\u258a        | 225/699 [00:14&lt;00:30, 15.52it/s]</pre> <pre>/opt/homebrew/Caskroom/miniforge/base/envs/scFates/lib/python3.12/site-packages/joblib/externals/loky/process_executor.py:752: UserWarning: A worker stopped while some jobs were given to the executor. This can be caused by a too short worker timeout or by a memory leak.\n  warnings.warn(\n</pre> <pre>    Differential expression:  36%|\u2588\u2588\u2588\u2588\u258e       | 251/699 [00:15&lt;00:28, 15.84it/s]</pre> <pre>Numba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\n</pre> <pre>    Differential expression:  39%|\u2588\u2588\u2588\u2588\u258b       | 273/699 [00:16&lt;00:25, 16.93it/s]</pre> <pre>/opt/homebrew/Caskroom/miniforge/base/envs/scFates/lib/python3.12/site-packages/joblib/externals/loky/process_executor.py:752: UserWarning: A worker stopped while some jobs were given to the executor. This can be caused by a too short worker timeout or by a memory leak.\n  warnings.warn(\n</pre> <pre>    Differential expression:  41%|\u2588\u2588\u2588\u2588\u2589       | 289/699 [00:17&lt;00:25, 16.40it/s]</pre> <pre>Numba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\n</pre> <pre>    Differential expression:  45%|\u2588\u2588\u2588\u2588\u2588\u258d      | 315/699 [00:17&lt;00:21, 17.63it/s]</pre> <pre>/opt/homebrew/Caskroom/miniforge/base/envs/scFates/lib/python3.12/site-packages/joblib/externals/loky/process_executor.py:752: UserWarning: A worker stopped while some jobs were given to the executor. This can be caused by a too short worker timeout or by a memory leak.\n  warnings.warn(\n</pre> <pre>    Differential expression:  48%|\u2588\u2588\u2588\u2588\u2588\u258b      | 333/699 [00:19&lt;00:21, 17.26it/s]</pre> <pre>Numba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\n</pre> <pre>    Differential expression:  95%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d| 666/699 [00:26&lt;00:01, 25.47it/s]</pre> <pre>/opt/homebrew/Caskroom/miniforge/base/envs/scFates/lib/python3.12/site-packages/joblib/externals/loky/process_executor.py:752: UserWarning: A worker stopped while some jobs were given to the executor. This can be caused by a too short worker timeout or by a memory leak.\n  warnings.warn(\n</pre> <pre>    Differential expression: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2589| 697/699 [00:27&lt;00:00, 25.71it/s]</pre> <pre>Numba: Attempted to fork from a non-main thread, the TBB library may be in an invalid state in the child process.\n</pre> <pre>    Differential expression: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 699/699 [00:28&lt;00:00, 24.71it/s]\n    test for upregulation for each leave vs root\n    upreg 66: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 141/141 [00:00&lt;00:00, 1108.33it/s]\n    upreg 92: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 558/558 [00:03&lt;00:00, 143.33it/s]\n    finished (0:00:32) --&gt; added \n    .uns['96-&gt;66&lt;&gt;92']['fork'], DataFrame with fork test results.\n</pre> In\u00a0[86]: Copied! <pre>scf.tl.branch_specific(ad3,root_milestone=\"96\",milestones=[\"66\",\"92\"],effect=0.25)\n</pre> scf.tl.branch_specific(ad3,root_milestone=\"96\",milestones=[\"66\",\"92\"],effect=0.25) <pre>    branch specific features: 92: 276, 66: 48\n    finished --&gt; updated \n    .uns['96-&gt;66&lt;&gt;92']['fork'], DataFrame updated with additionnal 'branch' column.\n</pre> In\u00a0[88]: Copied! <pre>g1=scf.pl.trends(ad3,\n                 root_milestone=\"96\",\n                 milestones=[\"66\", \"92\"],\n                 branch=\"66\",\n                 plot_emb=False,ordering=\"max\",return_genes=True, n_features=12)\n</pre> g1=scf.pl.trends(ad3,                  root_milestone=\"96\",                  milestones=[\"66\", \"92\"],                  branch=\"66\",                  plot_emb=False,ordering=\"max\",return_genes=True, n_features=12)  In\u00a0[89]: Copied! <pre>g2=scf.pl.trends(ad3,\n                 root_milestone=\"96\",\n                 milestones=[\"66\", \"92\"],\n                 branch=\"92\",\n                 plot_emb=False,ordering=\"max\",return_genes=True, n_features=12)\n</pre> g2=scf.pl.trends(ad3,                  root_milestone=\"96\",                  milestones=[\"66\", \"92\"],                  branch=\"92\",                  plot_emb=False,ordering=\"max\",return_genes=True, n_features=12) In\u00a0[90]: Copied! <pre>gg=g1.tolist()+g2.tolist()\n</pre> gg=g1.tolist()+g2.tolist() In\u00a0[91]: Copied! <pre>scf.pl.trends(ad3,gg,figsize=(4,4),annot=\"milestones\",n_features=12,\n        plot_emb=False,ordering=None,return_genes=True)\n</pre> scf.pl.trends(ad3,gg,figsize=(4,4),annot=\"milestones\",n_features=12,         plot_emb=False,ordering=None,return_genes=True)  Out[91]: <pre>Index(['APOE', 'GSTM3', 'EZR', 'HMGB2', 'APOC1', 'NMU', 'MT1X', 'S100A6',\n       'FAM178B', 'MT1G',\n       ...\n       'SPARC', 'TNFAIP8', 'MTSS1', 'FRMD4B', 'GLA', 'NT5C3A', 'TUBB1',\n       'ENDOD1', 'SQSTM1', 'ITM2B'],\n      dtype='object', length=324)</pre> In\u00a0[93]: Copied! <pre>scf.pl.matrix(ad3,gg,norm=\"minmax\",cmap=\"RdBu_r\",colorbar=False)\n</pre> scf.pl.matrix(ad3,gg,norm=\"minmax\",cmap=\"RdBu_r\",colorbar=False) In\u00a0[94]: Copied! <pre>scf.tl.cluster(ad3,n_neighbors=10,metric=\"correlation\")\n</pre> scf.tl.cluster(ad3,n_neighbors=10,metric=\"correlation\") <pre>Clustering features using fitted layer\n    finished (0:00:00) --&gt; added \n    .var['clusters'] identified modules.\n</pre> In\u00a0[95]: Copied! <pre>ad3.var.clusters.unique()\n</pre> ad3.var.clusters.unique() Out[95]: <pre>['5', '1', '4', '8', '0', '3', '6', '7', '9', '2']\nCategories (10, object): ['0', '1', '2', '3', ..., '6', '7', '8', '9']</pre> In\u00a0[96]: Copied! <pre>for c in ad3.var[\"clusters\"].unique():\n    scf.pl.trends(ad3,features=ad3.var_names[ad3.var.clusters==c],basis=\"pca\")\n</pre> for c in ad3.var[\"clusters\"].unique():     scf.pl.trends(ad3,features=ad3.var_names[ad3.var.clusters==c],basis=\"pca\") In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"notebooks/stemness.html","title":"Stemness","text":"In\u00a0[1]: Copied! <pre>import scanpy as sc\nimport numpy as np\nimport pandas as pd\nimport cellrank as cr\nimport scvelo as scv\nimport warnings\nwarnings.simplefilter(\"ignore\", category=UserWarning)\n</pre> import scanpy as sc import numpy as np import pandas as pd import cellrank as cr import scvelo as scv import warnings warnings.simplefilter(\"ignore\", category=UserWarning) In\u00a0[2]: Copied! <pre>adata = sc.read_h5ad(\"data/adRusso22_clusters_abc_sub_031925.h5ad\")\nadata\n</pre> adata = sc.read_h5ad(\"data/adRusso22_clusters_abc_sub_031925.h5ad\") adata Out[2]: <pre>AnnData object with n_obs \u00d7 n_vars = 597 \u00d7 26328\n    obs: 'n_genes_by_counts', 'total_counts', 'total_counts_ribo', 'pct_counts_ribo', 'total_counts_mt', 'pct_counts_mt', 'n_genes', 'n_counts', 'cluster', 'timepoint', 'sorting', 'cellid'\n    var: 'mt', 'ribo', 'n_cells_by_counts', 'mean_counts', 'pct_dropout_by_counts', 'total_counts'</pre> <p>Filter out undetected genes</p> In\u00a0[3]: Copied! <pre>adstart = adata.copy()\nmin_cell_percent = 0.005\nmin_cells = min_cell_percent * adstart.shape[0]\nmin_cells\n</pre> adstart = adata.copy() min_cell_percent = 0.005 min_cells = min_cell_percent * adstart.shape[0] min_cells Out[3]: <pre>2.985</pre> In\u00a0[4]: Copied! <pre>sc.pp.filter_genes(adstart, min_cells = min_cells)\nadstart.shape\n</pre> sc.pp.filter_genes(adstart, min_cells = min_cells) adstart.shape Out[4]: <pre>(597, 17500)</pre> <p>Normalize and define HVG, then PCA</p> In\u00a0[5]: Copied! <pre>n_hvg = 2000\nadstart.layers['counts'] = adstart.X.copy()\nsc.pp.normalize_total(adstart)\nsc.pp.log1p(adstart)\nsc.pp.highly_variable_genes(adstart, n_top_genes=n_hvg, flavor='seurat_v3', layer='counts')\n</pre> n_hvg = 2000 adstart.layers['counts'] = adstart.X.copy() sc.pp.normalize_total(adstart) sc.pp.log1p(adstart) sc.pp.highly_variable_genes(adstart, n_top_genes=n_hvg, flavor='seurat_v3', layer='counts') In\u00a0[6]: Copied! <pre>sc.tl.pca(adstart, mask_var='highly_variable')\nsc.pl.pca_variance_ratio(adstart, 50)\n</pre> sc.tl.pca(adstart, mask_var='highly_variable') sc.pl.pca_variance_ratio(adstart, 50) <p>kNN and UMAP</p> In\u00a0[7]: Copied! <pre>def_npcs = 30\ndef_nneigh = 5\nsc.pp.neighbors(adstart, n_neighbors = def_nneigh,  n_pcs = def_npcs)\nsc.tl.umap(adstart)\n</pre> def_npcs = 30 def_nneigh = 5 sc.pp.neighbors(adstart, n_neighbors = def_nneigh,  n_pcs = def_npcs) sc.tl.umap(adstart) In\u00a0[8]: Copied! <pre>sc.pl.umap(adstart, color=['timepoint', 'Nanog', 'T','Mesp1', 'Tbx6','Sox1', 'Tubb3', 'cluster'], size=80, alpha=.75,frameon=False, ncols=2)\n</pre> sc.pl.umap(adstart, color=['timepoint', 'Nanog', 'T','Mesp1', 'Tbx6','Sox1', 'Tubb3', 'cluster'], size=80, alpha=.75,frameon=False, ncols=2) <p>We will comute two different kernels. First, the ConnectivityKernel that computes cell-cell transitions based purely on transcriptional similarity.</p> In\u00a0[9]: Copied! <pre>from cellrank.kernels import ConnectivityKernel\nck = ConnectivityKernel(adstart, conn_key='connectivities')\nck.compute_transition_matrix()\n</pre> from cellrank.kernels import ConnectivityKernel ck = ConnectivityKernel(adstart, conn_key='connectivities') ck.compute_transition_matrix() Out[9]: <pre>ConnectivityKernel[n=597, dnorm=True, key='connectivities']</pre> <p>Once a transition matrix has been computed, we can use it to take random walks. These simulate the sequence of cell states that a given starting cell state will proceed through over time. In the resulting plot, black and yellow circles are initial and end states, respectively.</p> In\u00a0[10]: Copied! <pre>ck.plot_random_walks(seed=0,n_sims=100,start_ixs={\"cluster\": \"A\"},basis=\"umap\")\n</pre> ck.plot_random_walks(seed=0,n_sims=100,start_ixs={\"cluster\": \"A\"},basis=\"umap\") <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 100/100 [00:00&lt;00:00, 185.51sim/s]\n</pre> <p>You might find it interesting to see how vaying the kNN parameters impact this result.</p> <p>Now, let's run CytoTrace. There is a bit of a word-around that we need to perform in oder to get this to work:</p> In\u00a0[11]: Copied! <pre>adstart.layers[\"spliced\"] = adstart.layers['counts']\nadstart.layers[\"unspliced\"] = adstart.layers['counts']\nscv.pp.moments(adstart, n_pcs=def_npcs, n_neighbors=def_nneigh)\n</pre> adstart.layers[\"spliced\"] = adstart.layers['counts'] adstart.layers[\"unspliced\"] = adstart.layers['counts'] scv.pp.moments(adstart, n_pcs=def_npcs, n_neighbors=def_nneigh) <pre>computing moments based on connectivities\n    finished (0:00:00) --&gt; added \n    'Ms' and 'Mu', moments of un/spliced abundances (adata.layers)\n</pre> In\u00a0[12]: Copied! <pre>from cellrank.kernels import CytoTRACEKernel\nctk = CytoTRACEKernel(adstart).compute_cytotrace()\n</pre> from cellrank.kernels import CytoTRACEKernel ctk = CytoTRACEKernel(adstart).compute_cytotrace() In\u00a0[13]: Copied! <pre>sc.pl.embedding(adstart, color=[\"ct_pseudotime\", \"timepoint\"],basis=\"umap\")\n</pre> sc.pl.embedding(adstart, color=[\"ct_pseudotime\", \"timepoint\"],basis=\"umap\") In\u00a0[14]: Copied! <pre>sc.pl.pca(adstart, color=[\"ct_pseudotime\", \"timepoint\"], projection='3d', ncols=1)\n</pre> sc.pl.pca(adstart, color=[\"ct_pseudotime\", \"timepoint\"], projection='3d', ncols=1) In\u00a0[15]: Copied! <pre>ctk.compute_transition_matrix(threshold_scheme=\"soft\", nu=0.5)\n</pre> ctk.compute_transition_matrix(threshold_scheme=\"soft\", nu=0.5) <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 597/597 [00:00&lt;00:00, 6364.41cell/s]\n</pre> Out[15]: <pre>CytoTRACEKernel[n=597, dnorm=False, scheme='soft', b=10.0, nu=0.5]</pre> <p>We can visualize the transition matrix as a vector field as popularized by RNA velocity.</p> In\u00a0[16]: Copied! <pre>ctk.plot_projection(basis=\"pca\", color=\"cluster\", legend_loc=\"right\", size=75)\n</pre> ctk.plot_projection(basis=\"pca\", color=\"cluster\", legend_loc=\"right\", size=75) In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"notebooks/stemness.html#introduction","title":"Introduction\u00b6","text":"<p>This notebook will show you how to run CytoTrace to infer degree of differentiation as implemented in the the CellRank package. Recall from the CytoTrace paper that this inference is based on the total number of genes expressed.</p> <p>CellRank performs several other useful tasks:</p> <ul> <li>Estimate differentiation direction based a variety of biological priors, including pseudotime, developmental potential, RNA velocity, experimental time points, and more</li> <li>Compute initial, terminal, and intermediate 'macrostates'</li> <li>Infer fate probabilities and identify driver genes</li> <li>Cluster and visualize gene expression trends</li> </ul> <p>In CellRank parlance, kernels are methods that compute cell-cell transition probabilities. Go here to learn more about the different kernels available in CellRank.</p>"},{"location":"notebooks/stemness.html#data","title":"Data\u00b6","text":"<p>adRusso22_clusters_abc_sub_031925.h5ad: Directed differentiation of mouse embryonic stem cells and sampled at day 2, 3, 4, and 5. See Russo et al 2022. We have subset the cells to make it quicker to run this notebook.</p> <p>You can fetch the data from Canvas</p>"},{"location":"notebooks/stemness.html#other-resources","title":"Other resources\u00b6","text":"<ul> <li>CellRank CytoTrace tutorial</li> <li>How to install CellRank</li> <li>CytoTrace2</li> </ul>"},{"location":"notebooks/stemness.html#setup","title":"Setup\u00b6","text":"<p>First, we will import necessary packages and load the data</p>"}]}